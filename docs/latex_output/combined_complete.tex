\documentclass[12pt,a4paper,oneside]{report}
\usepackage[utf8]{inputenc}
\usepackage[spanish,english]{babel}
\renewcommand{\chaptername}{Capítulo}
\renewcommand{\figurename}{Figura}
\usepackage[margin=2.5cm,top=3cm,bottom=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tocloft}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{calc}
\usepackage{float}
\usepackage{setspace}
\usepackage{parskip}

% Definir tightlist si no existe
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

% Definir pandocbounded si no existe
\providecommand{\pandocbounded}[1]{#1}

% Definir passthrough si no existe
\providecommand{\passthrough}[1]{\texttt{#1}}

% Configuración de spacing
\onehalfspacing
\setlength{\parskip}{6pt}

% Configuración de imágenes para ajuste automático
\usepackage{adjustbox}
\graphicspath{{processed/images/}}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuración de listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Headers y footers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\small\leftmark}
\fancyfoot[C]{\thepage}
\setlength{\headheight}{14pt}

% Configurar estilo plain para páginas de capítulo (sin espacio extra)
\fancypagestyle{plain}{%
  \fancyhf{}
  \fancyfoot[C]{\thepage}
  \renewcommand{\headrulewidth}{0pt}
  \setlength{\headheight}{0pt}
}

% Configurar marks para mostrar nombres de capítulos correctamente
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

% Configuración de títulos
\titleformat{\chapter}[hang]
{\normalfont\huge\bfseries}{\thechapter.}{1em}{}
\titlespacing*{\chapter}{0pt}{-50pt}{40pt}

% Configuración de hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    citecolor=red,
    pdftitle={Plataforma de Gestión de TFG - Documentación Técnica},
    pdfauthor={Tu Nombre},
    pdfsubject={Trabajo de Fin de Grado - Ingeniería Informática},
    pdfcreator={Pandoc with LaTeX},
    pdfkeywords={TFG, React, Symfony, Plataforma Web}
}

% Configuración de tabla de contenidos
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

% Redefinir el comando de inclusión de imágenes de Pandoc
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>0.8\textheight 0.8\textheight\else\Gin@nat@height\fi}
\makeatother
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}

\begin{document}

% Incluir portada
\input{template/portada.tex}

% Tabla de contenidos
\renewcommand{\contentsname}{Índice}
\thispagestyle{plain}
\tableofcontents
\clearpage

% Lista de figuras
\renewcommand{\listfigurename}{Lista de Figuras}
\thispagestyle{plain}
\listoffigures
\clearpage

% Limpiar marks antes del contenido principal
\markboth{}{}

% Configurar numeración de capítulos
\setcounter{chapter}{0}

% Contenido principal
\chapter{Visión general del
proyecto}\label{visiuxf3n-general-del-proyecto}
Este capítulo presenta una visión general del proyecto desarrollado: desde la motivación inicial hasta los objetivos y el alcance definido. También incluye la estructura del documento, los estándares aplicados y las definiciones de los conceptos clave.

La plataforma de gestión de TFG nace de una necesidad real detectada en el entorno universitario, donde los procesos académicos requieren mayor digitalización y automatización. Este capítulo establece las bases que justifican el desarrollo del sistema y define una guía de su implementación.

\section{Motivación}\label{motivaciuxf3n}

La gestión de Trabajos de Fin de Grado en las universidades involucra a múltiples participantes: estudiantes, profesores tutores, tribunales y personal administrativo. Tradicionalmente, este proceso se gestionaba de forma fragmentada usando correo electrónico, documentos físicos y hojas de cálculo, lo que causa ineficiencias, pérdida de información y dificultades para hacer seguimiento del progreso.

La pandemia de COVID-19 aceleró la digitalización educativa, evidenciando la necesidad de algún sistema informático que facilite tanto la gestión remota como presencial. Las universidades necesitan plataformas que no solo digitalicen los procesos existentes, sino que los optimicen mediante automatización, seguimiento en tiempo real y generación de reportes.

El cumplimiento de normativas académicas, la gestión de plazos estrictos y la coordinación entre departamentos requieren una solución tecnológica que centralice toda la información de los TFG en un sistema único, accesible y seguro.

\section{Objetivos}\label{objetivos}

Esta sección establece tanto el objetivo general como los objetivos específicos que guían la implementación, organizados según su naturaleza funcional, técnica y de calidad para facilitar su seguimiento y evaluación.

Todos los objetivos se formularon aplicando la metodología SMART (Específicos, Medibles, Alcanzables, Relevantes y Temporales), garantizando que cada objetivo contribuya efectivamente al propósito del proyecto y pueda ser evaluado de manera objetiva durante el desarrollo.

\subsection{Objetivo General}\label{objetivo-general}

Desarrollar una plataforma web para la gestión completa del ciclo de vida de los TFG, desde la propuesta inicial hasta la defensa final, mejorando la eficiencia, transparencia y seguimiento del proceso académico.

\subsection{Objetivos Específicos}\label{objetivos-especuxedficos}

\textbf{Objetivos Funcionales:}

\begin{itemize}
\tightlist
\item
  \textbf{OF1}: Implementar un sistema de autenticación seguro basado en
  JWT que soporte múltiples roles de usuario (estudiante, profesor,
  presidente de tribunal, administrador).
\item
  \textbf{OF2}: Desarrollar un módulo completo para estudiantes que
  permita la subida, edición y seguimiento del estado de sus TFG.
\item
  \textbf{OF3}: Crear un sistema de gestión para profesores tutores que
  facilite la supervisión, evaluación y retroalimentación de los TFG
  asignados.
\item
  \textbf{OF4}: Implementar un módulo de gestión de tribunales que
  permita la creación, asignación y coordinación de defensas.
\item
  \textbf{OF5}: Desarrollar un sistema de calendario integrado para la
  programación y gestión de defensas presenciales.
\item
  \textbf{OF6}: Crear un panel administrativo completo para la gestión
  de usuarios, reportes de errores y configuración del sistema.
\item
  \textbf{OF7}: Implementar un sistema de notificaciones en tiempo real
  para mantener informados a todos los actores del proceso.
\end{itemize}

\textbf{Objetivos Técnicos:}

\begin{itemize}
\tightlist
\item
  \textbf{OT1}: Diseñar una arquitectura frontend moderna basada en
  React 19 con componentes reutilizables y diseño responsivo.
\item
  \textbf{OT2}: Implementar un backend con Symfony 6.4 LTS que
  proporcione APIs REST seguras y escalables.
\item
  \textbf{OT3}: Establecer un sistema de base de datos optimizado con
  MySQL 8.0 que garantice la integridad y consistencia de los datos.
\item
  \textbf{OT4}: Desarrollar un sistema de gestión de archivos seguro
  para el almacenamiento y descarga de documentos TFG.
\item
  \textbf{OT5}: Implementar un sistema de testing automatizado que cubra
  tanto frontend como backend.
\item
  \textbf{OT6}: Configurar un entorno de desarrollo containerizado con
  DDEV para facilitar la colaboración y despliegue.
\end{itemize}

\textbf{Objetivos de Calidad:}

\begin{itemize}
\tightlist
\item
  \textbf{OC1}: Garantizar un tiempo de respuesta menor a 2 segundos
  para todas las operaciones críticas del sistema.
\item
  \textbf{OC2}: Implementar medidas de seguridad que cumplan con
  estándares académicos de protección de datos.
\item
  \textbf{OC3}: Diseñar una interfaz de usuario intuitiva con una curva
  de aprendizaje mínima para todos los roles.
\item
  \textbf{OC4}: Asegurar compatibilidad entre diferentes navegadores para dispositivos móviles y tablets.
\item
  \textbf{OC5}: Establecer un sistema de copia de seguridad y recuperación de datos
  que garantice la disponibilidad del servicio.
\end{itemize}

\section{Alcance}\label{alcance}

El alcance del proyecto se organiza en tres dimensiones: funcional, técnica y temporal. Cada dimensión aborda aspectos específicos del desarrollo, desde las funcionalidades concretas que se implementarán hasta las tecnologías seleccionadas y los plazos de entrega comprometidos.

\subsection{Alcance Funcional}\label{alcance-funcional}

\textbf{Incluido en el proyecto:}

\begin{itemize}
\tightlist
\item
  \textbf{Gestión completa del ciclo de vida del TFG}: Desde la creación
  inicial hasta la calificación final.
\item
  \textbf{Sistema multi-rol}: Soporte para cuatro tipos de usuario con
  permisos diferenciados.
\item
  \textbf{Gestión de archivos}: Subida, almacenamiento y descarga segura
  de documentos PDF.
\item
  \textbf{Sistema de calendario}: Programación y gestión de defensas con
  disponibilidad de tribunales.
\item
  \textbf{Panel de reportes}: Generación de estadísticas y exportación
  de datos en múltiples formatos.
\item
  \textbf{API REST completa}: Endpoints documentados para todas las
  funcionalidades del sistema.
\end{itemize}

\textbf{No incluido en el proyecto:}

\begin{itemize}
\tightlist
\item
  Sistema de notificaciones, alertas en tiempo real y
  notificaciones por email.
\item
  Sistema de videoconferencia integrado para defensas remotas.
\item
  Integración con sistemas de información universitarios existentes (ERP
  académico).
\item
  Módulo de plagio o análisis de contenido automático.
\item
  Sistema de facturación o pagos.
\item
  Funcionalidades de red social o colaboración entre estudiantes.
\item
  Soporte multiidioma (solo español en esta versión).
\end{itemize}

\subsection{Alcance Técnico}\label{alcance-tuxe9cnico}

\textbf{Tecnologías implementadas:}

\begin{itemize}
\tightlist
\item
  \textbf{Frontend}: React 19, Vite, Tailwind CSS v4, React Router DOM
  v7.
\item
  \textbf{Backend}: Symfony 6.4 LTS, PHP 8.2+, API Platform 3.x.
\item
  \textbf{Base de datos}: MySQL 8.0 con Doctrine ORM.
\item
  \textbf{Autenticación}: JWT con refresh tokens.
\item
  \textbf{Gestión de archivos}: VichUploaderBundle con validaciones de
  seguridad.
\item
  \textbf{Testing}: PHPUnit (backend), Vitest (frontend).
\item
  \textbf{Despliegue}: DDEV con Docker, Composer, npm.
\end{itemize}

\textbf{Limitaciones técnicas:}

\begin{itemize}
\tightlist
\item
  Soporte únicamente para archivos PDF (no otros formatos de documento).
\item
  Base de datos relacional (no NoSQL para este alcance).
\item
  Despliegue en servidor único (no arquitectura de microservicios).
\item
  Almacenamiento local de archivos (no integración con servicios cloud
  en esta versión).
\end{itemize}

\subsection{Alcance Temporal}\label{alcance-temporal}

El proyecto se desarrolla en 8 fases distribuidas a lo largo de 10
semanas académicas:

\begin{itemize}
\tightlist
\item
  \textbf{Fases 1-6}: Desarrollo frontend completo.
\item
  \textbf{Fase 7}: Implementación backend Symfony.
\item
  \textbf{Fase 8}: Testing, optimización y despliegue.
\end{itemize}

\section{Visión general del
documento}\label{visiuxf3n-general-del-documento}

Este documento está estructurado para proporcionar una comprensión completa y progresiva del proyecto desarrollado. Cada capítulo aborda aspectos específicos del desarrollo, desde la idea inicial hasta la implementación final.

El documento sigue el estándar ISO/IEEE 16326 para documentación de sistemas software, adaptado al contexto académico de un TFG. La estructura es la siguiente:

\textbf{Capítulo 1 - Visión general del proyecto}: Establece la
motivación, objetivos y alcance del proyecto, proporcionando el contexto
necesario para comprender la necesidad y los beneficios de la plataforma
desarrollada.

\textbf{Capítulo 2 - Contexto del proyecto}: Describe en detalle el
entorno tecnológico, las características de los usuarios objetivo y el
modelo de ciclo de vida adoptado para el desarrollo del sistema.

\textbf{Capítulo 3 - Planificación}: Presenta la metodología de
desarrollo por fases, cronogramas de implementación y la distribución
temporal de las actividades del proyecto.

\textbf{Capítulo 4 - Análisis del sistema}: Contiene la especificación
completa de requisitos funcionales y no funcionales, casos de uso,
diagramas UML y criterios de garantía de calidad.

\textbf{Capítulo 5 - Diseño}: Documenta la arquitectura del sistema
tanto a nivel físico como lógico, incluyendo el diseño de la base de
datos y la interfaz de usuario.

\textbf{Capítulo 6 - Implementación}: Detalla los aspectos técnicos de
la implementación, incluyendo la estructura del código, patrones de
diseño utilizados y decisiones de arquitectura.

\textbf{Capítulo 7 - Entrega del producto}: Describe los procesos de
configuración, despliegue y entrega del sistema en entorno de
producción.

\textbf{Capítulo 8 - Procesos de soporte y pruebas}: Documenta las
estrategias de testing, gestión de riesgos y procesos de validación
implementados.

\textbf{Capítulo 9 - Conclusiones y trabajo futuro}: Presenta una
evaluación crítica del proyecto, cumplimiento de objetivos y propuestas
de mejoras futuras.

Los anexos incluyen manuales técnicos de instalación y usuario, así como
documentación adicional de referencia.

\section{Estandarización del
documento}\label{estandarizaciuxf3n-del-documento}

Este documento sigue las directrices del estándar \textbf{ISO/IEEE 16326:2009} - ``Systems and software engineering - Life cycle processes - Project management'', adaptado para proyectos académicos.

Existen apartados que se han omitido ya que carecían de sentido en el contexto de este proyecto, ya que el estándar está orientado a proyectos de desarrollo de software a gran escala. Por ejemplo, no se incluyen secciones sobre gestión de proveedores o adquisiciones.

Además se ha tomado la decisión de incluir la bibliografía al final del documento, ya que el estándar no especifica un formato concreto para la bibliografía y se ha optado por un formato más adecuado para un TFG.

\subsection{Normas aplicadas}\label{normas-aplicadas}

\begin{itemize}
\tightlist
\item
  \textbf{ISO/IEEE 16326:2009}: Estructura principal del documento y
  gestión de proyectos.
\item
  \textbf{IEEE Std 830-1998}: Especificación de requisitos software
  (Capítulo 4).
\item
  \textbf{IEEE Std 1016-2009}: Descripciones de diseño software
  (Capítulo 5).
\item
  \textbf{ISO/IEC 25010:2011}: Modelo de calidad del producto software
  (Capítulo 4.2).
\end{itemize}

\subsection{Convenciones del
documento}\label{convenciones-del-documento}

\textbf{Formato de texto:} - Títulos principales: Numeración decimal
(1., 1.1., 1.1.1.). - Términos técnicos: Primera aparición en
\textbf{negrita}. - Acrónimos: MAYÚSCULAS con definición en primera
aparición.

\textbf{Diagramas y figuras:} - Numeración correlativa: Figura 1.1,
Figura 1.2, etc. - Pie de figura descriptivo con fuente cuando
corresponda.

\textbf{Tablas:} - Numeración correlativa: Tabla 1.1, Tabla 1.2, etc. -
Encabezados en negrita.

\textbf{Referencias:} - Bibliografía al final del documento. - Formato
APA para referencias académicas. - Enlaces web con fecha de acceso.

\section{Acrónimos}\label{acruxf3nimos}

Este documento utiliza diversos acrónimos técnicos comunes en ingeniería de software y desarrollo web. Esta sección proporciona una referencia completa de todos los términos abreviados, facilitando la comprensión para lectores con diferentes niveles de especialización.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4348}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5652}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Acrónimo
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Significado
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{API} & Application Programming Interface (Interfaz de
Programación de Aplicaciones) \\
\textbf{CORS} & Cross-Origin Resource Sharing (Intercambio de Recursos
de Origen Cruzado) \\
\textbf{CRUD} & Create, Read, Update, Delete (Crear, Leer, Actualizar,
Eliminar) \\
\textbf{CSS} & Cascading Style Sheets (Hojas de Estilo en Cascada) \\
\textbf{DDEV} & Docker Development Environment \\
\textbf{DOM} & Document Object Model (Modelo de Objetos del
Documento) \\
\textbf{EPL} & Event Processing Language (Lenguaje de Procesamiento de
Eventos) \\
\textbf{HMR} & Hot Module Replacement (Reemplazo de Módulos en
Caliente) \\
\textbf{HTML} & HyperText Markup Language (Lenguaje de Marcado de
Hipertexto) \\
\textbf{HTTP} & HyperText Transfer Protocol (Protocolo de Transferencia
de Hipertexto) \\
\textbf{IEEE} & Institute of Electrical and Electronics Engineers \\
\textbf{ISO} & International Organization for Standardization \\
\textbf{JSON} & JavaScript Object Notation (Notación de Objetos
JavaScript) \\
\textbf{JWT} & JSON Web Token (Token Web JSON) \\
\textbf{LTS} & Long Term Support (Soporte a Largo Plazo) \\
\textbf{MVC} & Model-View-Controller (Modelo-Vista-Controlador) \\
\textbf{ORM} & Object-Relational Mapping (Mapeo Objeto-Relacional) \\
\textbf{PDF} & Portable Document Format (Formato de Documento
Portable) \\
\textbf{PHP} & PHP: Hypertext Preprocessor \\
\textbf{REST} & Representational State Transfer (Transferencia de Estado
Representacional) \\
\textbf{RTL} & React Testing Library \\
\textbf{SPA} & Single Page Application (Aplicación de Página Única) \\
\textbf{SQL} & Structured Query Language (Lenguaje de Consulta
Estructurado) \\
\textbf{TFG} & Trabajo de Fin de Grado \\
\textbf{UI} & User Interface (Interfaz de Usuario) \\
\textbf{UML} & Unified Modeling Language (Lenguaje de Modelado
Unificado) \\
\textbf{URL} & Uniform Resource Locator (Localizador Uniforme de
Recursos) \\
\textbf{UX} & User Experience (Experiencia de Usuario) \\
\end{longtable}

\section{Definiciones}\label{definiciones}

Esta sección presenta las definiciones de los conceptos técnicos y
términos especializados más relevantes utilizados a lo largo del
proyecto. Estas definiciones han sido elaboradas específicamente en el
contexto de la plataforma de gestión de TFG desarrollada, proporcionando
claridad sobre el significado y uso de cada término.

La comprensión de estos conceptos es fundamental para entender tanto la
arquitectura técnica como las funcionalidades del sistema implementado.
Cada definición incluye el contexto específico de aplicación dentro del
proyecto.

\textbf{Backend}: Conjunto de tecnologías y servicios del lado del
servidor que procesan la lógica de negocio, gestionan la base de datos y
proporcionan APIs para el frontend.

\textbf{Bundle}: En el contexto de Symfony, un bundle es un plugin que
agrupa código relacionado (controladores, servicios, configuración) en
una unidad reutilizable.

\textbf{Componente React}: Función o clase de JavaScript que retorna
elementos JSX y encapsula lógica de interfaz de usuario reutilizable.

\textbf{Context API}: Sistema de gestión de estado global de React que
permite compartir datos entre componentes sin necesidad de pasar props
manualmente a través del árbol de componentes.

\textbf{Custom Hook}: Función JavaScript que comienza con ``use'' y
permite extraer y reutilizar lógica de estado entre múltiples
componentes React.

\textbf{Defensa de TFG}: Acto académico en el cual el estudiante
presenta oralmente su Trabajo de Fin de Grado ante un tribunal evaluador
para su calificación final.

\textbf{Doctrine ORM}: Herramienta de mapeo objeto-relacional para PHP
que proporciona una capa de abstracción para interactuar con bases de
datos relacionales.

\textbf{Endpoint}: URL específica de una API REST que acepta peticiones
HTTP y devuelve respuestas estructuradas, representando un recurso o
acción del sistema.

\textbf{Frontend}: Parte de la aplicación web que se ejecuta en el
navegador del usuario, responsable de la interfaz de usuario y la
interacción directa con el usuario final.

\textbf{Hot Module Replacement (HMR)}: Tecnología de desarrollo que
permite actualizar módulos de código en tiempo real sin perder el estado
de la aplicación.

\textbf{Middleware}: Función que se ejecuta durante el ciclo de vida de
una petición HTTP, permitiendo modificar la petición o respuesta antes
de llegar al destino final.

\textbf{Migración de Base de Datos}: Script que modifica la estructura
de la base de datos de manera versionada, permitiendo evolucionar el
esquema de datos de forma controlada.

\textbf{Monorepo}: Estrategia de organización de código donde múltiples
proyectos relacionados (frontend, backend) se almacenan en un único
repositorio Git.

\textbf{Props}: Abreviación de ``properties'', son argumentos que se
pasan a los componentes React para configurar su comportamiento y
apariencia.

\textbf{Protected Route}: Ruta de la aplicación que requiere
autenticación y/o autorización específica para ser accedida,
implementando control de acceso basado en roles.

\textbf{Responsive Design}: Enfoque de diseño web que permite que las
interfaces se adapten automáticamente a diferentes tamaños de pantalla y
dispositivos.

\textbf{Serialización}: Proceso de convertir objetos de programación en
formatos de intercambio de datos como JSON o XML para transmisión o
almacenamiento.

\textbf{State Management}: Gestión del estado de la aplicación,
refiriéndose a cómo se almacenan, actualizan y comparten los datos entre
diferentes partes de la aplicación.

\textbf{Token de Acceso}: Credencial digital temporal que permite a un
usuario autenticado acceder a recursos protegidos de la aplicación sin
necesidad de reenviar credenciales.

\textbf{Tribunal de TFG}: Comisión evaluadora compuesta por profesores
académicos (presidente, secretario y vocal) responsable de evaluar y
calificar las defensas de TFG.

\textbf{Utility-First CSS}: Metodología de CSS que utiliza clases
pequeñas y específicas para construir interfaces, característica
principal de frameworks como Tailwind CSS.

\textbf{Validación del lado del servidor}: Proceso de verificación y
sanitización de datos recibidos en el backend antes de su procesamiento
o almacenamiento.

\textbf{Virtual DOM}: Representación en memoria de la estructura DOM
real que permite a React calcular eficientemente los cambios mínimos
necesarios para actualizar la interfaz.

\chapter{Contexto del proyecto}\label{contexto-del-proyecto}

Este capítulo establece el contexto del proyecto, proporcionando los fundamentos necesarios antes de pasar a la planificacion y el desarrollo. Incluye una descripción detallada del proyecto, un análisis extenso de los perfiles de usuario, la justificación del modelo de desarrollo seleccionado, y una explicación completa de las tecnologías, lenguajes y herramientas utilizadas.

\section{Descripción general del
proyecto}\label{descripciuxf3n-general-del-proyecto}

La Plataforma de Gestión de TFG es un sistema web diseñado para automatizar y optimizar la gestión completa de Trabajos de Fin de Grado en universidades. El sistema implementa una arquitectura moderna basada en tecnologías web actuales y proporciona una solución a los procesos actuales de evaluación de los TFG.

La plataforma gestiona el flujo completo del proceso académico, desde la
creación inicial del TFG por parte del estudiante hasta la calificación
final tras la defensa ante el tribunal. El sistema implementa un modelo
de estados bien definido (Borrador → En Revisión → Aprobado → Defendido)
que garantiza la trazabilidad y el cumplimiento de los procedimientos
académicos establecidos.
La arquitectura se basa en la separación de responsabilidades: el frontend en React 19 maneja la presentación e interacción con el usuario, mientras que el backend en Symfony 6.4 LTS gestiona la lógica de negocio, persistencia de datos y seguridad.

El sistema incluye funcionalidades como un calendario interactivo para programar defensas, gestión segura de archivos PDF, y panel administrativo con capacidades para elaborar reportes de errores y exportación de datos.

\section{Características del
usuario}\label{caracteruxedsticas-del-usuario}

El sistema satisface las necesidades de cuatro perfiles de usuario diferenciados, cada uno con roles, permisos y flujos de trabajo específicos.

\subsection{Estudiante}\label{estudiante}

\textbf{Perfil}: Estudiante universitario en proceso de realización de
su Trabajo de Fin de Grado, con conocimientos básicos de tecnologías web
y experiencia en el uso de plataformas académicas digitales.

\textbf{Responsabilidades principales}: El estudiante debe crear y mantener actualizada la información básica de su TFG: título, resumen y palabras clave. Gestiona la subida y actualización de archivos PDF, asegurando que el sistema tenga siempre la versión más reciente. Realiza seguimiento del estado de progreso de su TFG y consulta regularmente los comentarios del tutor para integrarlos en nuevas versiones. También visualiza la información de su defensa (fecha, tribunal, aula) y gestiona las notificaciones del sistema sobre cambios de estado.

\textbf{Competencias técnicas esperadas}: Manejo básico de navegadores web modernos y formularios online. Capacidad para subir y descargar archivos de manera segura, comprendiendo aspectos básicos de seguridad. Conocimientos básicos de gestión documental digital (control de versiones, nomenclatura de archivos). Familiaridad con herramientas de notificación electrónica.

\subsection{Profesor/Tutor}\label{profesortutor}

\textbf{Perfil}: Docente universitario con experiencia en dirección de
TFG, responsable de la supervisión académica y evaluación de trabajos
asignados.

\textbf{Responsabilidades principales}: Supervisa el progreso de todos los TFG asignados, asegurando que los estudiantes mantengan un ritmo adecuado de trabajo. Realiza revisiones periódicas y evaluaciones de los documentos. Proporciona feedback mediante el sistema de comentarios, ofreciendo orientación específica para la mejora del trabajo. Gestiona los cambios de estado de los TFG bajo su supervisión, tomando decisiones sobre la aprobación para defensa. Participa en tribunales de evaluación como miembro experto y coordina con otros miembros para la programación de defensas.

\textbf{Competencias técnicas esperadas}: Experiencia sólida en evaluación de trabajos académicos, metodologías de investigación y criterios de calidad académica. Manejo avanzado de herramientas digitales de gestión académica para seguimiento, evaluación y comunicación con estudiantes. Capacidad para proporcionar feedback constructivo a través de plataformas digitales. Comprensión de flujos de trabajo colaborativos online, coordinación con colegas y gestión de calendarios compartidos.

\subsection{Presidente del Tribunal}\label{presidente-del-tribunal}

\textbf{Perfil}: Profesor universitario con experiencia avanzada en
evaluación académica, responsable de liderar tribunales de evaluación y
coordinar el proceso de defensas.

\textbf{Responsabilidades principales}: Crea y configura tribunales de evaluación según criterios académicos, asegurando la composición adecuada para evaluar los trabajos asignados. Realiza la asignación de miembros de tribunal considerando expertise técnico, carga de trabajo y equilibrio de roles. Programa fechas y horarios de defensas utilizando el calendario integrado, optimizando recursos y minimizando conflictos. Coordina la disponibilidad entre miembros del tribunal y supervisa el proceso de evaluación, manteniendo estándares académicos. Genera actas de defensa y documentación oficial requerida.

\textbf{Competencias técnicas esperadas}: Experiencia avanzada en gestión de procesos académicos, normativas universitarias y procedimientos de evaluación. Capacidad de liderazgo y coordinación de equipos multidisciplinarios. Manejo experto de herramientas de calendario y programación digital, gestión de recursos y resolución de conflictos de agenda. Comprensión de procedimientos administrativos universitarios, aspectos legales y documentación oficial.

\subsection{Administrador}\label{administrador}

\textbf{Perfil}: Personal técnico o administrativo responsable de la
gestión global del sistema, con conocimientos avanzados en
administración de plataformas web y gestión de usuarios.

\textbf{Responsabilidades principales}: Gestiona el catálogo completo de usuarios mediante operaciones CRUD, garantizando la integridad de la base de usuarios. Asigna y modifica roles y permisos de acceso, asegurando que cada usuario tenga los privilegios necesarios sin comprometer la seguridad. Genera reportes estadísticos del sistema para la toma de decisiones académicas. Facilita la exportación de datos en múltiples formatos (PDF, Excel, CSV). Configura y mantiene parámetros del sistema, supervisando el funcionamiento general y coordinando tareas de mantenimiento.

\textbf{Competencias técnicas esperadas}: Experiencia avanzada en administración de sistemas web complejos, arquitecturas de aplicaciones, servidores web y bases de datos. Conocimientos sólidos en gestión de bases de datos relacionales, generación de reportes y análisis de rendimiento. Capacidad analítica para interpretación de estadísticas y métricas del sistema, identificación de tendencias y patrones de uso. Comprensión de seguridad informática y gestión de accesos, políticas de seguridad y cumplimiento de normativas de protección de datos.

\section{Modelo de ciclo de vida}\label{modelo-de-ciclo-de-vida}

La selección del modelo de ciclo de vida es una decisión estratégica que determina la estructura, organización y metodología del proceso de desarrollo. Esta elección impacta en la gestión de riesgos, la adaptación a cambios y la entrega de valor del proyecto.

El desarrollo de la plataforma sigue un \textbf{modelo iterativo incremental}, estructurado en ocho fases que permiten la entrega progresiva de funcionalidades y la validación continua de requisitos. Este enfoque facilita la identificación temprana de problemas, permite ajustes del flujo del proyecto y garantiza que cada incremento aporte valor al producto final.

\subsection{Metodología de
desarrollo}\label{metodologuxeda-de-desarrollo}

\textbf{Enfoque adoptado}: El proyecto implementa una metodología ágil
adaptada al contexto académico, combinando elementos de Scrum para la
gestión con prácticas de desarrollo incremental que permiten
la entrega con gran valor en cada fase.

\textbf{Justificación de la metodología}: Esta metodología proporciona flexibilidad para adaptarse a cambios de requisitos durante el desarrollo, es una característica esencial en proyectos académicos donde los requerimientos pueden evolucionar. Permite la validación temprana del sistema ya que cada fase entrega funcionalidades completas y operativas, facilitando la detección de problemas antes de seguir con el desarrollo. Facilita feedback continuo que permite realizar ajustes basados en la evaluación de fases o entregas anteriores.

\subsection{Fases del proyecto}\label{fases-del-proyecto}

\textbf{Fase 1-2: Fundación del sistema (Semanas 1-2)} - Configuración
del entorno de desarrollo. - Implementación del sistema de enrutamiento y
navegación. - Desarrollo del sistema de autenticación básico. -
Establecimiento de la arquitectura de componentes React.

\textbf{Fase 3: Módulo de estudiante (Semanas 3-4)} - Implementación
completa de funcionalidades para estudiantes. - Interfaces de seguimiento de estado de TFG. -
Integración con sistema de notificaciones.

\textbf{Fase 4: Módulo de profesor (Semanas 4-5)} - Desarrollo de
herramientas de supervisión para tutores. - Sistema de feedback y
comentarios estructurados. - Interfaces de gestión de TFG asignados.

\textbf{Fase 5: Sistema de defensas (Semanas 5-6)} - Implementación del
calendario interactivo con FullCalendar.js. - Sistema de gestión de
tribunales. - Programación y coordinación de defensas. - Gestión de
disponibilidad de miembros de tribunal.

\textbf{Fase 6: Panel administrativo (Semanas 6-7)} - Sistema completo
de gestión de usuarios (CRUD). - Generación de reportes de errores y estadísticas
avanzadas. - Funcionalidades de exportación de datos. - Configuración
global del sistema.

\textbf{Fase 7: Backend Symfony (Semanas 7-9)} - Implementación completa
del backend con Symfony 6.4 LTS. - Desarrollo de APIs REST con API
Platform. - Sistema de subida y gestión de archivos. - Sistema de autenticación JWT con refresh tokens. - Migración
de datos desde sistema mock a base de datos MySQL.

\textbf{Fase 8: Pulimiento final (Semanas 9-10)} - Testing exhaustivo
(unitario, integración y E2E). - Optimización de rendimiento. -
Configuración de despliegue en producción. - Documentación técnica y
manuales de usuario.

\section{Tecnologías}\label{tecnologuxedas}

La elección de tecnologías es fundamental en el desarrollo de cualquier sistema software. Estas decisiones impactan directamente en la escalabilidad, mantenibilidad, rendimiento y viabilidad a largo plazo del proyecto. Esta sección detalla las principales tecnologías utilizadas, explicando las razones de su selección y cómo contribuyen al cumplimiento de los objetivos.

\subsection{React 19}\label{react-19}

React 19 constituye la biblioteca principal para el desarrollo del
frontend de la aplicación, proporcionando un marco de trabajo robusto
para la construcción de interfaces de usuario interactivas y componentes
reutilizables.

\textbf{Ventajas para el proyecto}: React ofrece un ecosistema maduro con amplia disponibilidad de librerías y componentes de terceros que aceleran el desarrollo, reduciendo la implementación desde cero. Proporciona rendimiento optimizado mediante su Virtual DOM y la curva de aprendizaje es razonable gracias a documentación extensa y una comunidad activa. Ofrece una gran compatibilidad con herramientas modernas de desarrollo y testing, incluyendo DevTools, frameworks de testing y herramientas de build como Vite.

\subsection{Symfony 6.4 LTS}\label{symfony-6.4-lts}

Symfony 6.4 LTS se utiliza como framework principal para el desarrollo
del backend, proporcionando una arquitectura sólida basada en
componentes modulares y principios de desarrollo empresarial.

\textbf{Ventajas para el proyecto}: La versión LTS (Long Term Support) garantiza soporte continuo y actualizaciones de seguridad hasta noviembre de 2027, proporcionando estabilidad a largo plazo. Su arquitectura modular ofrece flexibilidad para utilizar únicamente los componentes necesarios. El cumplimiento de estándares PSR asegura interoperabilidad con otras librerías de la comunidad PHP y facilita el mantenimiento del código.

\subsection{MySQL 8.0}\label{mysql-8.0}

MySQL 8.0 actúa como sistema de gestión de base de datos relacional,
proporcionando persistencia segura y eficiente para todos los datos del
sistema.

\textbf{Ventajas para el proyecto}: MySQL 8.0 ofrece fiabilidad excepcional como sistema probado en entornos de producción exigentes, con millones de instalaciones que demuestran su estabilidad. Proporciona cumplimiento completo de propiedades ACID que garantizan consistencia e integridad de datos, fundamentales para un sistema académico donde la pérdida de información de TFG sería inaceptable. Ofrece capacidades de escalabilidad horizontal y vertical, permitiendo crecimiento sin degradación significativa del rendimiento. Cuenta con un ecosistema rico de herramientas de administración y monitorización que facilitan el mantenimiento operativo y optimización continua.

\subsection{JWT Authentication
(LexikJWTAuthenticationBundle)}\label{jwt-authentication-lexikjwtauthenticationbundle}

La autenticación JWT proporciona un sistema de seguridad stateless,
escalable y moderno para el control de acceso a la aplicación.

\textbf{Implementación específica}: El sistema utiliza access tokens de corta duración (1 hora) para operaciones sensibles, minimizando la exposición en caso de compromiso. Se implementan refresh tokens de larga duración (30 días) que permiten renovación automática sin reautenticación constante, equilibrando seguridad con experiencia de usuario. La información de roles está incluida en el payload del token mediante peticiones, eliminando consultas adicionales a la base de datos. La seguridad se maximiza mediante el algoritmo RS256 que utiliza firma asimétrica.

\subsection{FullCalendar.js}\label{fullcalendar.js}

FullCalendar.js proporciona la funcionalidad de calendario interactivo esencial para la gestión visual de defensas y programación de eventos académicos, transformando la coordinación tradicional de fechas en una experiencia intuitiva y visual.

\textbf{Implementación específica}: El sistema integra múltiples vistas de calendario (mensual, semanal y diaria) que permiten diferentes niveles de detalle según las necesidades de programación. La funcionalidad drag \& drop facilita la reprogramación de defensas mediante arrastre visual, eliminando la necesidad de formularios complejos. La adaptación responsiva asegura funcionalidad completa en dispositivos móviles, manteniendo la usabilidad en tablets y smartphones.

\subsection{Tailwind CSS v4}\label{tailwind-css-v4}

Tailwind CSS v4 actúa como framework de estilos, proporcionando un sistema de diseño consistente y eficiente que unifica el diseño en toda la aplicación mediante un enfoque altamente escalable y mantenible.

\textbf{Implementación específica}: El sistema permite la construcción de interfaces complejas mediante la composición de clases personalizadas, eliminando la necesidad de escribir CSS personalizado. La implementación responsive utiliza breakpoints móvil-first que aseguran una experiencia óptima en dispositivos de cualquier tamaño, con transiciones suaves entre diferentes resoluciones. La preparación para modo oscuro mediante CSS custom properties facilita futuras implementaciones de temas alternativos sin refactoring del código base.

\subsection{DDEV}\label{ddev}

DDEV proporciona un entorno de desarrollo containerizado que garantiza consistencia absoluta entre diferentes máquinas de desarrollo y facilita significativamente la incorporación de nuevos desarrolladores, eliminando los problemas tradicionales de configuración de entorno.

\textbf{Ventajas para el proyecto}: La consistencia se garantiza mediante un entorno idéntico independientemente del sistema operativo host (Windows, macOS, Linux), eliminando por completo los problemas de "funciona en mi máquina". La facilidad de setup permite levantar todo el entorno de desarrollo con un único comando, reduciendo el tiempo de configuración inicial de horas a minutos. El aislamiento mediante contenedores asegura que las dependencias del proyecto no interfieran con el sistema host ni con otros proyectos, manteniendo limpio el entorno de desarrollo.

\section{Lenguajes}\label{lenguajes}

Los lenguajes de programación seleccionados se eligieron considerando madurez, rendimiento, ecosistema de desarrollo y compatibilidad con las tecnologías del stack principal. Esta sección detalla las características específicas utilizadas de cada lenguaje y los patrones de programación aplicados.

\subsection{JavaScript/TypeScript}\label{javascripttypescript}

JavaScript se utiliza como lenguaje principal para el desarrollo del frontend, aprovechando las características modernas de ECMAScript 2023 y manteniendo una arquitectura preparada para migración incremental hacia TypeScript conforme evolucionen los requisitos de tipado del proyecto.

\textbf{Patrones de programación aplicados}: La programación funcional se implementa mediante uso extensivo de métodos como map, filter y reduce para transformaciones de datos inmutables. El enfoque declarativo prevalece sobre el imperativo, describiendo qué debe ocurrir en lugar de cómo debe implementarse, mejorando la legibilidad y mantenibilidad del código.

\subsection{PHP 8.2+}\label{php-8.2}

PHP 8.2+ actúa como lenguaje de backend robusto, aprovechando las significativas mejoras de rendimiento y las características avanzadas de tipado fuerte introducidas en versiones recientes, proporcionando una base sólida para la API y lógica de negocio del sistema.

\textbf{Principios de programación aplicados}: Los principios SOLID guían todo el diseño orientado a objetos, implementando responsabilidad única, principio abierto/cerrado, sustitución de Liskov, segregación de interfaces e inversión de dependencias para código mantenible y extensible. La dependency injection se utiliza sistemáticamente para inversión de control, mejorando significativamente la testabilidad del código y permitiendo mock de dependencias durante testing. El cumplimiento de estándares PSR asegura interoperabilidad con el ecosistema PHP, incluyendo PSR-4 para autoloading, PSR-12 para estilo de código y PSR-15 para middleware HTTP.

\subsection{SQL}\label{sql}

SQL se utiliza para la definición de esquemas de base de datos, consultas analíticas complejas y procedimientos de migración segura, aprovechando las características avanzadas y optimizaciones de rendimiento específicas de MySQL 8.0.

\textbf{Implementación específica}: El DDL avanzado define esquemas completos con constraints sofisticados, índices optimizados para patrones de consulta específicos y relaciones complejas que garantizan integridad referencial y performance consistente.

\subsection{HTML/CSS}\label{htmlcss}

HTML5 y CSS3 proporcionan la estructura semántica robusta y presentación visual cohesiva de la aplicación, implementando rigurosamente estándares web modernos y las mejores prácticas de accesibilidad para garantizar una experiencia inclusiva y compatible con tecnologías asistivas.

\section{Herramientas}\label{herramientas}

La selección apropiada de herramientas de desarrollo, testing y gestión de proyecto es determinante en la productividad y calidad del desarrollo software. Las herramientas elegidas deben integrarse eficientemente, proporcionando un flujo de trabajo fluido que minimice los errores y maximice la capacidad de desarrollo y debugging.

Esta sección detalla las principales herramientas utilizadas durante el ciclo de vida del proyecto, explicando su configuración específica y las ventajas que aportan al proceso de desarrollo.

\subsection{Visual Studio Code}\label{visual-studio-code}

VS Code actúa como IDE principal de desarrollo, meticulosamente configurado con extensiones específicas para el stack tecnológico del proyecto que maximizan la productividad y minimizan los errores durante el desarrollo full-stack.

\subsection{Vite}\label{vite}

Vite se utiliza como build tool moderno y servidor de desarrollo para el frontend, proporcionando una experiencia de desarrollo excepcionalmente optimizada mediante Hot Module Replacement ultra-rápido y arquitectura basada en módulos ES nativos.

\textbf{Ventajas para el proyecto}: El plugin oficial de React proporciona soporte completo y optimizado para React y JSX, incluyendo Fast Refresh que preserva el estado de componentes durante recarga. La integración de ESLint en tiempo de desarrollo muestra errores de código instantáneamente en el browser, mejorando la calidad del código durante la escritura. La preparación para PWA mediante vite-plugin-pwa establece la base para futuras funcionalidades offline y notificaciones push, anticipando evoluciones del sistema hacia aplicaciones más ricas.

\subsection{Composer}\label{composer}

Composer gestiona las dependencias PHP del backend, garantizando versiones consistentes, resolución automática de dependencias y reproducibilidad completa de entornos entre diferentes fases de desarrollo y producción.

\subsection{Docker / DDEV}\label{docker-ddev}

Docker proporciona containerización robusta del entorno de desarrollo, mientras DDEV ofrece una capa de abstracción especializada para desarrollo web que simplifica la gestión de contenedores y optimiza el flujo de trabajo full-stack.

\subsection{Git / GitHub}\label{git-github}

Git actúa como sistema de control de versiones distribuido, mientras GitHub proporciona hosting remoto centralizado, herramientas avanzadas de colaboración y pipelines automatizados de CI/CD que facilitan el desarrollo colaborativo y la entrega continua.

\chapter{Planificación}\label{planificaciuxf3n}
Este capítulo detalla la planificación temporal y de metodología seguida durante el desarrollo de la plataforma: desde la trabajo inicial hasta la entrega final. Se presenta la estructuración en fases diferenciadas y la gestión de recursos temporales del proyecto.

La plataforma de gestión de TFG se desarrolló siguiendo un modelo iterativo incremental que permite entregas funcionales progresivas y validación continua de requisitos. Este enfoque divide el desarrollo en iteraciones bien definidas donde cada fase aborda análisis, diseño, implementación y pruebas de forma integrada.

Una planificación efectiva resulta fundamental para el éxito de cualquier proyecto de software, especialmente en el contexto académico donde los plazos son estrictos y los recursos limitados. Este capítulo establece las bases de la metodología que guiaron todo el proceso de desarrollo y justifica las decisiones temporales adoptadas.

\section{Iniciación del proyecto}\label{iniciaciuxf3n-del-proyecto}

\subsection{Contexto de inicio}\label{contexto-de-inicio}

La idea del proyecto “Plataforma de Gestión de TFG” nació al darme cuenta de que los procesos tradicionales de gestión de los Trabajos de Fin de Grado en la universidad podían mejorar. Al observar la plataforma que ya existía, pensé que sería posible crear una versión más completa y eficiente, que facilitara la coordinación entre estudiantes, tutores y coordinadores.

Decidí embarcarme en el desarrollo porque vi una buena oportunidad: hoy en día las tecnologías web están lo suficientemente maduras como para crear aplicaciones robustas de forma ágil, además yo ya tenía experiencia trabajando con herramientas modernas como React y Symfony. Con esos recursos, me propuse diseñar una solución que integrara en un solo espacio a todos los actores implicados en el proceso académico, mejorando la eficiencia, la trazabilidad y la comunicación.

\subsection{Análisis de viabilidad}\label{anuxe1lisis-de-viabilidad}

\textbf{Viabilidad técnica}: El proyecto demuestra alta viabilidad técnica al basarse en tecnologías consolidadas y bien documentadas. React 19 y Symfony 6.4 LTS ofrecen ecosistemas maduros respaldados por comunidades activas y extensiva documentación. La arquitectura seleccionada (aplicación SPA con API backend) representa un patrón probado que garantiza escalabilidad y mantenibilidad a largo plazo.

\textbf{Viabilidad temporal}: La planificación de 10 semanas estructurada en 8 fases iterativas facilita un desarrollo incremental con validaciones continuas. El conocimiento previo de las tecnologías empleadas minimiza los riesgos de retrasos significativos y permite estimaciones más precisas de los tiempos de desarrollo.

\textbf{Viabilidad de recursos}: El desarrollo requiere exclusivamente herramientas de software libre y recursos educativos de acceso gratuito. La containerización mediante DDEV asegura un entorno de desarrollo consistente independientemente de la plataforma de hardware utilizada.

\subsection{Definición del alcance
inicial}\label{definiciuxf3n-del-alcance-inicial}

El alcance inicial del proyecto se definió estableciendo los requisitos mínimos viables (MVP) para cada perfil de usuario, asegurando que cada rol disponga de las funcionalidades esenciales para sus responsabilidades académicas.

El MVP para \textbf{Estudiantes} incluye las capacidades fundamentales de gestión de TFG: subida de documentos con validación automática, seguimiento del estado del trabajo a través del flujo académico establecido, y acceso al feedback del tutor para facilitar las mejoras continuas. Para \textbf{Profesores}, el sistema proporciona herramientas de supervisión centralizadas con vista unificada de todos los TFG asignados, sistema de comentarios estructurado para feedback constructivo, y gestión de estados del trabajo conforme avanza el proceso de supervisión. El \textbf{Presidente de Tribunal} dispone de funcionalidades para crear y configurar tribunales académicos, asignar miembros evaluadores y programar defensas coordinando disponibilidades y recursos. El rol de \textbf{Administrador} cuenta con gestión completa de usuarios mediante operaciones CRUD, generación de reportes de seguimiento del sistema y configuración de parámetros adaptativos a políticas institucionales.

Esta aproximación MVP facilita la validación temprana de conceptos y permite el refinamiento progresivo de funcionalidades basado en el feedback de usuarios reales.

\section{Iteraciones del proceso de
desarrollo}\label{iteraciones-del-proceso-de-desarrollo}

El desarrollo de la plataforma se estructura mediante una metodología iterativa incremental que se materializa en ocho fases diferenciadas. Cada fase cuenta con objetivos específicos, criterios de aceptación claros y entregables funcionales que aportan valor al producto final. Esta aproximación facilita la gestión de la complejidad del sistema y permite adaptaciones continuas basadas en la validación de resultados.

\subsection{Fase 1-2: Setup inicial y autenticación (Semanas
1-2)}\label{fase-1-2-setup-inicial-y-autenticaciuxf3n-semanas-1-2}

\textbf{Objetivos de la fase}: Esta fase inicial establece los cimientos tecnológicos del proyecto, configurando la arquitectura frontend base, implementando el sistema de navegación con protección por roles, desarrollando un sistema de autenticación funcional y estableciendo las herramientas de desarrollo que garantizan la calidad del código.

\textbf{Actividades principales}:

\emph{Semana 1: Configuración del entorno} - Inicialización del proyecto React utilizando Vite como herramienta de construcción. - Configuración de Tailwind CSS v4 y establecimiento del sistema de diseño base de la aplicación. - Instalación y configuración de ESLint, Prettier y herramientas complementarias para mantener la calidad del código. - Desarrollo de componentes fundamentales de Layout y navegación que servirán como base para toda la aplicación.

\emph{Semana 2: Sistema de autenticación} - Implementación del AuthContext para la gestión centralizada del estado de autenticación. - Desarrollo de los componentes de interfaz para inicio de sesión y registro de usuarios. - Creación del sistema ProtectedRoute que valida permisos según el rol del usuario. - Configuración de la persistencia de sesión utilizando localStorage. - Implementación de tests básicos para validar los flujos de autenticación principales.

\textbf{Entregables}: Al finalizar esta fase se obtiene una aplicación React completamente funcional con navegación adaptativa por roles, un sistema de autenticación mock completamente operativo, una arquitectura de componentes sólida y bien estructurada, y documentación técnica detallada de las decisiones arquitectónicas adoptadas.

\textbf{Criterios de aceptación}: Los cuatro perfiles de usuario definidos pueden autenticarse correctamente en el sistema. El sistema de rutas protege adecuadamente el acceso basándose en el rol del usuario autenticado. La interfaz responde correctamente en diferentes dispositivos siguiendo el sistema de diseño establecido. Todo el código desarrollado cumple los estándares de calidad definidos por las herramientas de linting configuradas.

\subsection{Fase 3: Módulo de estudiante (Semanas
3-4)}\label{fase-3-muxf3dulo-de-estudiante-semanas-3-4}

\textbf{Objetivos de la fase}: Esta fase se centra en desarrollar todas las funcionalidades necesarias para el perfil de estudiante, implementando un sistema de gestión de archivos funcional, creando interfaces intuitivas para el seguimiento del estado del TFG e integrando un sistema básico de notificaciones que mantenga informados a los usuarios.

\textbf{Actividades principales}:

\emph{Semana 3: Gestión de TFG} - Desarrollo del custom hook useTFGs que encapsula toda la lógica de negocio relacionada con la gestión de trabajos. - Implementación de formularios intuitivos para la creación y edición de TFG con validaciones en tiempo real. - Construcción de un sistema robusto de subida de archivos que incluye validación de formatos y seguimiento del progreso de carga. - Diseño de interfaces claras para la visualización de TFG que muestren metadatos de forma organizada y accesible.

\emph{Semana 4: Seguimiento y notificaciones} - Implementación completa del sistema de estados que gestiona la transición Borrador → En Revisión → Aprobado → Defendido con validaciones apropiadas. - Desarrollo de componentes visuales tipo timeline que permiten a los estudiantes hacer seguimiento claro del progreso de su trabajo. - Integración del NotificacionesContext para proporcionar feedback inmediato sobre cambios de estado. - Creación de interfaces especializadas para la visualización de comentarios y feedback proporcionado por el tutor.

\textbf{Entregables}: Al completar esta fase se obtiene un módulo de estudiante completamente funcional y operativo, un sistema integral de subida y gestión de archivos con validaciones apropiadas, interfaces claras y efectivas para el seguimiento del estado del TFG, y un sistema de notificaciones totalmente integrado que mantiene informados a los usuarios.

\textbf{Criterios de aceptación}: Los estudiantes pueden crear, editar y subir archivos de TFG de manera intuitiva y sin errores. El sistema de estados funciona correctamente implementando todas las validaciones necesarias para garantizar la integridad del flujo académico. Las notificaciones se muestran de forma inmediata y clara cuando ocurren cambios relevantes. Todas las interfaces desarrolladas son intuitivas, accesibles y completamente responsive en diferentes dispositivos.

\subsection{Fase 4: Módulo de profesor (Semanas
4-5)}\label{fase-4-muxf3dulo-de-profesor-semanas-4-5}

\textbf{Objetivos de la fase}: Esta fase desarrolla las herramientas especializadas de supervisión necesarias para profesores tutores, implementa un sistema estructurado de feedback académico, crea interfaces eficientes para la gestión de TFG asignados e integra capacidades de cambio de estado con las validaciones de permisos apropiadas.

\textbf{Actividades principales}:

\emph{Semana 4 (solapada): Bases del módulo profesor} - Desarrollo de interfaces completas para el listado y gestión de todos los TFG asignados al profesor. - Implementación de sistemas avanzados de filtros y búsqueda que permiten organizar trabajos por estado, estudiante y fechas relevantes. - Construcción de un sistema robusto de visualización de archivos PDF que facilite la revisión de documentos subidos por estudiantes.

\emph{Semana 5: Sistema de feedback y evaluación} - Desarrollo de formularios especializados para comentarios estructurados que faciliten feedback constructivo y detallado. - Implementación de un sistema integral de calificaciones y evaluaciones académicas con criterios claros. - Creación de interfaces intuitivas para cambio de estado que incluyen validación de permisos y flujos de aprobación. - Integración completa con el sistema de notificaciones para asegurar que los estudiantes reciban feedback inmediato sobre cambios relevantes.

\textbf{Entregables}: Al finalizar esta fase se cuenta con un módulo de profesor completamente funcional y optimizado para tareas de supervisión, un sistema comprensivo de feedback y comentarios que facilita la comunicación académica, interfaces especializadas para evaluación y gestión de estados de TFG, y validaciones de permisos por rol completamente operativas y seguras.

\textbf{Criterios de aceptación}: Los profesores pueden gestionar de manera eficiente y efectiva todos sus TFG asignados utilizando herramientas intuitivas. El sistema de comentarios facilita la provisión de feedback estructurado y constructivo de calidad académica. Los cambios de estado se comunican de manera apropiada y automática a los estudiantes correspondientes. Las validaciones de permisos funcionan correctamente garantizando la seguridad e integridad del sistema académico.

\subsection{Fase 5: Sistema de defensas y calendario (Semanas
5-6)}\label{fase-5-sistema-de-defensas-y-calendario-semanas-5-6}

\textbf{Objetivos de la fase}: Esta fase integra FullCalendar.js para proporcionar gestión visual avanzada de defensas académicas, implementa un sistema completo de gestión de tribunales, desarrolla funcionalidades intuitivas para la programación de defensas y crea un sistema automatizado de coordinación de disponibilidad entre todos los actores académicos.

\textbf{Actividades principales}:

\emph{Semana 5 (solapada): Integración de calendario} - Instalación y configuración completa de FullCalendar.js optimizada para React con todas sus funcionalidades avanzadas. - Desarrollo del custom hook useCalendario que encapsula toda la lógica de gestión de eventos y estados del calendario. - Implementación de múltiples vistas especializadas (mensual, semanal y diaria) que faciliten diferentes niveles de detalle según las necesidades. - Configuración de eventos personalizados específicamente diseñados para representar defensas académicas con toda su información relevante.

\emph{Semana 6: Gestión de tribunales y defensas} - Desarrollo completo del módulo de creación y gestión de tribunales académicos con todas las validaciones institucionales necesarias. - Implementación de un sistema inteligente de asignación de miembros de tribunal que considere expertise y disponibilidad. - Creación de interfaces avanzadas de programación de defensas que incluyen funcionalidad drag & drop para facilitar la reorganización intuitiva. - Desarrollo de un sistema comprensivo de notificaciones que mantenga informados tanto a tribunales como a estudiantes sobre cambios y actualizaciones.

\textbf{Entregables}: Al completar esta fase se obtiene un calendario interactivo completamente funcional con todas las características avanzadas necesarias, un sistema robusto de gestión de tribunales completamente operativo, funcionalidades completas de programación de defensas que faciliten la coordinación académica, y un sistema automatizado de coordinación de disponibilidad que optimice la planificación de recursos.

\textbf{Criterios de aceptación}: El calendario muestra de manera clara y precisa todas las defensas programadas con información detallada y actualizada. Los tribunales pueden crearse, modificarse y gestionarse de manera eficiente siguiendo los procedimientos académicos establecidos. La programación de defensas resulta intuitiva y completamente funcional para todos los usuarios autorizados. Las notificaciones se envían de manera automática y oportuna a todos los actores relevantes en cada proceso de defensa.

\subsection{Fase 6: Panel administrativo (Semanas
6-7)}\label{fase-6-panel-administrativo-semanas-6-7}

\textbf{Objetivos de la fase}: Esta fase desarrolla un sistema integral de gestión de usuarios con operaciones CRUD completas, implementa capacidades avanzadas de generación de reportes y estadísticas institucionales, crea funcionalidades robustas de exportación de datos en múltiples formatos y establece un sistema de configuración global que permita adaptar la plataforma a diferentes contextos institucionales.

\textbf{Actividades principales}:

\emph{Semana 6 (solapada): Gestión de usuarios} - Desarrollo del custom hook useUsuarios que encapsula toda la lógica de gestión de usuarios y permisos del sistema. - Implementación de interfaces CRUD completas y intuitivas para la gestión eficiente de todos los usuarios de la plataforma. - Construcción de un sistema robusto de asignación de roles que incluye validaciones de seguridad y flujos de aprobación. - Desarrollo de filtros avanzados y funcionalidades de búsqueda que faciliten la localización y gestión de usuarios específicos.

\emph{Semana 7: Reportes y configuración} - Desarrollo del custom hook useReportes que gestiona toda la lógica de generación y procesamiento de informes estadísticos. - Implementación de dashboards interactivos con visualizaciones estadísticas claras que proporcionen insights valiosos sobre el funcionamiento del sistema. - Construcción de un sistema comprensivo de exportación que permita generar archivos en formatos PDF y Excel con datos estructurados. - Creación de interfaces especializadas para la configuración global del sistema que permitan personalización institucional.

\textbf{Entregables}: Al finalizar esta fase se cuenta con un panel administrativo completo y completamente funcional que facilite todas las tareas de gestión, un sistema avanzado de reportes con múltiples tipos de visualizaciones y análisis, funcionalidades de exportación completamente operativas que generen archivos profesionales, y un sistema de configuración implementado que permita adaptación institucional.

\textbf{Criterios de aceptación}: La gestión de usuarios permite realizar todas las operaciones CRUD de manera eficiente y segura con validaciones apropiadas. Los reportes proporcionan insights valiosos y accionables sobre el funcionamiento y uso del sistema. Las exportaciones generan archivos correctamente formateados y completos que cumplan estándares profesionales. La configuración global afecta de manera apropiada y consistente el comportamiento de todo el sistema según las necesidades institucionales.

\subsection{Fase 7: Backend Symfony (Semanas
7-9)}\label{fase-7-backend-symfony-semanas-7-9}

\textbf{Objetivos de la fase}: Esta fase crucial implementa un backend robusto y completo utilizando Symfony 6.4 LTS, desarrolla APIs REST mediante API Platform 3.x, migra completamente del sistema mock inicial hacia persistencia real con MySQL, e implementa un sistema de autenticación JWT seguro con refresh tokens para garantizar la seguridad y escalabilidad del sistema.

\textbf{Actividades principales}:

\emph{Semana 7: Setup y arquitectura backend} - Configuración completa del proyecto Symfony utilizando DDEV para garantizar un entorno de desarrollo consistente y reproducible. - Definición detallada de todas las entidades Doctrine necesarias (User, TFG, Tribunal, Defensa, etc.) con sus relaciones y validaciones correspondientes. - Configuración robusta de la base de datos MySQL incluyendo migraciones iniciales y datos de prueba. - Instalación y configuración de API Platform con serialización personalizada para cada entidad del sistema.

\emph{Semana 8: APIs y autenticación} - Implementación completa y exhaustiva de todos los endpoints REST necesarios para cada funcionalidad del sistema. - Configuración avanzada de LexikJWTAuthenticationBundle para autenticación segura basada en tokens. - Desarrollo de un sistema comprensivo de roles y permisos utilizando Symfony Security para garantizar acceso apropiado. - Integración de VichUploaderBundle para gestión segura y eficiente de archivos subidos por usuarios.

\emph{Semana 9: Integración y testing} - Establecimiento de conexión completa y funcional entre frontend y backend con validación de todos los flujos de datos. - Implementación de un sistema robusto de notificaciones por email para mantener informados a los usuarios. - Desarrollo de testing de APIs utilizando PHPUnit para garantizar calidad y confiabilidad. - Optimización de consultas de base de datos y análisis de rendimiento para asegurar respuesta eficiente del sistema.

\textbf{Entregables}: Al completar esta fase se obtiene un backend Symfony completamente funcional y optimizado, APIs REST documentadas utilizando estándares OpenAPI, un sistema de autenticación JWT completamente operativo y seguro, y una integración frontend-backend completamente validada y funcional.

\textbf{Criterios de aceptación}: Todas las funcionalidades desarrolladas en el frontend funcionan perfectamente con las APIs reales implementadas. El sistema de autenticación JWT proporciona seguridad robusta y funcionalidad completa para todos los perfiles de usuario. Las APIs están correctamente documentadas siguiendo estándares profesionales y completamente testeadas con cobertura apropiada. El rendimiento general del sistema cumple y supera los objetivos de respuesta establecidos inicialmente.

\subsection{Fase 8: Pulimiento final (Semanas
9-10)}\label{fase-8-pulimiento-final-semanas-9-10}

\textbf{Objetivos de la fase}: Esta fase final se enfoca en realizar testing exhaustivo de toda la aplicación, optimizar el rendimiento general y la experiencia de usuario para garantizar calidad profesional, configurar completamente el entorno de despliegue en producción y completar toda la documentación técnica y manuales de usuario necesarios para el funcionamiento institucional del sistema.

\textbf{Actividades principales}:

\emph{Semana 9 (solapada): Testing y optimización} - Implementación de testing end-to-end utilizando herramientas especializadas para validar todos los flujos de usuario. - Optimización detallada de consultas de base de datos y análisis de rendimiento para garantizar respuestas eficientes. - Implementación de mejoras de experiencia de usuario basadas en testing de usabilidad y feedback de usuarios reales. - Identificación y corrección sistemática de todos los bugs detectados durante el proceso de testing integral del sistema.

\emph{Semana 10: Despliegue y documentación} - Configuración completa del entorno de producción utilizando Docker para garantizar consistencia y escalabilidad. - Finalización de la documentación técnica completa que incluya arquitectura, APIs y procedimientos de mantenimiento. - Creación de manuales de usuario detallados y específicos para cada rol del sistema que faciliten la adopción institucional.

\textbf{Entregables}: Al completar esta fase final se obtiene una aplicación completamente testeada, optimizada y lista para uso profesional, una configuración de producción robusta y completamente operativa, documentación técnica y manuales de usuario completos y profesionales, y un sistema completamente preparado y validado para despliegue exitoso en entorno de producción.

\textbf{Criterios de aceptación}: Todos los tests implementados (unitarios, de integración y end-to-end) pasan exitosamente validando la funcionalidad completa del sistema. El sistema cumple y supera todos los criterios de rendimiento establecidos inicialmente garantizando experiencia de usuario óptima. La documentación está completa, es comprensible y proporciona toda la información necesaria para operación y mantenimiento. El despliegue en producción se ejecuta de manera exitosa y el sistema funciona de forma estable en entorno real.

\section{Diagrama de Gantt}\label{diagrama-de-gantt}

La visualización temporal del proyecto a través de diagramas de Gantt proporciona una perspectiva clara de la planificación y seguimiento efectivo del progreso. Estos diagramas facilitan la identificación de dependencias críticas entre fases, la optimización en la distribución de esfuerzo y el establecimiento de hitos de control para evaluar el avance del desarrollo.

Los cronogramas presentados ilustran la distribución temporal de las actividades principales del proyecto, destacando las dependencias entre fases y los solapamientos estratégicos planificados para maximizar la eficiencia del desarrollo. Esta representación visual facilita la comprensión de la secuencia lógica de actividades y permite identificar tanto la ruta crítica del proyecto como las oportunidades existentes para paralelizar el trabajo de desarrollo.

\subsection{Cronograma general del
proyecto}\label{cronograma-general-del-proyecto}

El cronograma general proporciona una perspectiva temporal integral del proyecto, abarcando desde la configuración inicial hasta la entrega del producto final en producción. La planificación se estructura en 8 fases distribuidas estratégicamente a lo largo de 10 semanas, optimizando el uso de recursos disponibles y asegurando el cumplimiento de los plazos establecidos.

La metodología iterativa adoptada facilita solapamientos estratégicos entre fases, particularmente entre el desarrollo frontend y la preparación del backend, maximizando la eficiencia del proceso global. El cronograma incluye hitos de validación al finalizar cada fase, garantizando la calidad progresiva del producto desarrollado, como se muestra en la Figura~\ref{fig:cronograma-general}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Cronograma General}]{processed/images/03_planificacion_mermaid_0.png}}
\caption{Cronograma General}
\label{fig:cronograma-general}
\end{figure}

\subsection{Hitos principales y
dependencias}\label{hitos-principales-y-dependencias}

El cronograma principal detalla los hitos críticos y las dependencias entre las diferentes fases del proyecto, facilitando la identificación de puntos de control y la gestión de riesgos temporales. Esta visualización complementaria permite un análisis más granular de la secuencia de actividades y sus interdependencias, como se muestra en la Figura~\ref{fig:cronograma-principal}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Cronograma Principal}]{processed/images/03_planificacion_mermaid_1.png}}
\caption{Cronograma Principal}
\label{fig:cronograma-principal}
\end{figure}

\textbf{Hitos críticos identificados}: El proyecto establece cinco hitos fundamentales que marcan puntos de control esenciales en el desarrollo. H1 representa el frontend base funcional alcanzado en Semana 3 tras completar Fases 1-2, estableciendo la infraestructura fundamental de la aplicación. H2 marca la finalización de módulos usuario completos en Semana 6 al concluir Fases 3-4, proporcionando funcionalidad principal para estudiantes y profesores. H3 indica sistema frontend completo en Semana 8 tras Fases 5-6, integrando todas las funcionalidades de usuario en una plataforma cohesiva. H4 señala la integración del backend en Semana 9 con finalización de Fase 7, conectando frontend con persistencia de datos real. H5 culmina con sistema productivo en Semana 10 tras Fase 8, entregando aplicación lista para despliegue.

\textbf{Dependencias críticas}: - Fase 3 (Estudiante) requiere completar
Sistema de autenticación. - Fase 4 (Profesor) depende de estados TFG de
Fase 3. - Fase 5 (Defensas) necesita roles y permisos de Fase 4. - Fase
7 (Backend) puede iniciarse en paralelo desde Semana 7. - Fase 8
(Testing) requiere integración completa de Fase 7.

\chapter{Análisis del sistema}\label{anuxe1lisis-del-sistema}
Este capítulo presenta un análisis exhaustivo del sistema desarrollado, abarcando desde la especificación detallada de requisitos hasta la evaluación económica del proyecto. El análisis constituye el fundamento técnico y económico que sustenta todas las decisiones de diseño e implementación de la plataforma.

El análisis del sistema aborda los aspectos fundamentales necesarios para garantizar el éxito del proyecto. La especificación de requisitos define tanto las funcionalidades que debe proporcionar el sistema como las restricciones bajo las cuales debe operar, estableciendo las bases para el desarrollo técnico. La garantía de calidad establece los criterios y estándares que aseguran el correcto funcionamiento y la confiabilidad del sistema en entornos académicos reales.

La gestión del presupuesto completa el análisis evaluando la viabilidad económica del proyecto, analizando tanto la inversión requerida como los beneficios esperados. Este enfoque integral asegura que el análisis cubra todas las dimensiones técnicas, operativas y económicas necesarias para el éxito de la plataforma de gestión de TFG.

\section{Especificación de
requisitos}\label{especificaciuxf3n-de-requisitos}

La especificación sigue la metodología IEEE Std 830-1998, organizando los requisitos en categorías funcionales específicas para cada rol de usuario y requisitos no funcionales transversales que aseguran la calidad, seguridad y rendimiento del sistema. Esta estructuración facilita tanto el desarrollo como la validación posterior de las funcionalidades implementadas.

\subsection{Requisitos de
información}\label{requisitos-de-informaciuxf3n}

Estos requisitos definen las entidades principales que el sistema debe gestionar, especificando sus atributos críticos y las relaciones que las conectan para formar un modelo de datos coherente y funcional.

\subsubsection{Entidad Usuario}\label{entidad-usuario}

\textbf{Descripción}: Representa a todos los actores del sistema académico que interactúan con la plataforma, cada uno diferenciado por roles específicos que determinan sus capacidades y permisos de acceso.

\textbf{Restricciones}: El sistema implementa restricciones de integridad que garantizan la consistencia y validez de los datos de usuario. La dirección de correo electrónico debe ser única en todo el sistema, evitando duplicaciones que podrían comprometer la identificación y autenticación de usuarios. El DNI debe cumplir estrictamente con el formato válido establecido por la normativa española, incluyendo validación de dígito de control y estructura correcta. Cada usuario debe tener asignado al menos un rol del sistema, garantizando que no existan usuarios sin permisos definidos que podrían representar vulnerabilidades de seguridad. Los datos personales básicos son obligatorios y constituyen un prerrequisito indispensable para la activación completa de la cuenta, asegurando que toda la información necesaria para el funcionamiento del sistema esté disponible desde el momento de la activación.

\subsubsection{Entidad TFG}\label{entidad-tfg}

\textbf{Descripción}: Representa un Trabajo de Fin de Grado completo, incluyendo toda su información académica asociada y la gestión de su ciclo de vida desde la creación inicial hasta la defensa final.

\textbf{Restricciones}: El sistema implementa restricciones de integridad específicas para garantizar la coherencia académica y técnica de los TFG. Un estudiante puede mantener máximo un TFG activo simultáneamente, evitando solapamientos que podrían comprometer la dedicación y calidad del trabajo académico. El título debe mantener unicidad por estudiante, asegurando que no existan trabajos duplicados o con nomenclatura confusa que puedan generar ambigüedades en la identificación. El archivo asociado debe cumplir estrictamente con el formato PDF y no exceder el tamaño máximo de 50MB, garantizando compatibilidad universal de lectura y optimización del almacenamiento del sistema. Las transiciones de estado deben seguir rigurosamente el flujo definido en el modelo de ciclo de vida, impidiendo saltos de estados que podrían comprometer la integridad del proceso académico y la trazabilidad de las evaluaciones.

\subsubsection{Entidad Tribunal}\label{entidad-tribunal}

\textbf{Descripción}: Comisión evaluadora académica responsable de dirigir y evaluar las defensas de TFG, integrada por profesores cualificados que garantizan la calidad del proceso de evaluación.

\textbf{Restricciones}: El sistema establece restricciones académicas y administrativas que garantizan la legitimidad y competencia de los tribunales. Los tres miembros del tribunal deben poseer necesariamente rol de profesor o superior, asegurando que todos los evaluadores tengan la cualificación académica mínima requerida para participar en procesos de evaluación de trabajos de fin de grado. No puede existir duplicación de miembros dentro de un mismo tribunal, evitando conflictos de roles y garantizando que cada posición (presidente, secretario, vocal) sea ocupada por personas diferentes que aporten perspectivas diversas al proceso evaluativo. Al menos el presidente debe ostentar específicamente el rol PRESIDENTE\_TRIBUNAL, asegurando que quien lidera el tribunal posea las competencias y autoridad administrativa necesarias para coordinar adecuadamente el proceso de evaluación y toma de decisiones del tribunal.

\subsubsection{Entidad Defensa}\label{entidad-defensa}

\textbf{Descripción}: Evento académico formal donde el estudiante presenta y defiende su TFG ante un tribunal cualificado para su evaluación y calificación final.

\textbf{Restricciones}: El sistema implementa restricciones operativas que garantizan la coherencia logística y académica de las defensas. Un TFG solo puede mantener una defensa activa simultáneamente, evitando duplicaciones que podrían generar confusión administrativa y conflictos en la evaluación académica. La fecha programada para la defensa debe ser necesariamente posterior a la fecha actual del sistema, impidiendo la programación retrospectiva que carece de sentido operativo y garantizando coherencia temporal en la planificación. El tribunal asignado debe confirmar disponibilidad completa en la fecha y hora programadas, asegurando que todos los miembros evaluadores puedan participar efectivamente en el proceso de evaluación sin conflictos de agenda que comprometan la calidad del proceso académico.

\subsection{Requisitos funcionales}\label{requisitos-funcionales}

Estos requisitos se organizan por rol académico, especificando las funcionalidades que permiten a estudiantes, profesores, presidentes de tribunal y administradores realizar sus tareas específicas dentro de la plataforma.

\subsubsection{Requisitos funcionales -
Estudiante}\label{requisitos-funcionales---estudiante}

\textbf{RF-EST-001: Gestión de cuenta de usuario}

\textbf{Descripción}: El estudiante puede ver y actualizar sus datos personales y de contacto, asegurando que siempre estén correctos para los procesos relacionados con su TFG.

\textbf{Prioridad}: Alta.

\textbf{RF-EST-002: Creación de TFG}

\textbf{Descripción}: Permite iniciar un nuevo TFG ingresando toda la información académica básica (título, descripción, resumen, palabras clave y tutor asignado), que quedará registrado en el sistema como borrador.

\textbf{Prioridad}: Alta.

\textbf{RF-EST-003: Edición de información de TFG}

\textbf{Descripción}: Mientras el trabajo esté en borrador, el estudiante puede modificar y ajustar la información de su proyecto, afinando los detalles antes de enviarlo a revisión.

\textbf{Prioridad}: Alta.

\textbf{RF-EST-004: Subida de archivo TFG}

\textbf{Descripción}: El sistema permite cargar de forma segura el documento final en PDF (hasta 50 MB), vinculándolo con el TFG del estudiante y confirmando la subida exitosa.

\textbf{Prioridad}: Alta.

\textbf{RF-EST-005: Seguimiento de estado}

\textbf{Descripción}: El estudiante puede consultar en todo momento el estado actual de su TFG y ver el historial completo de cambios, con fechas y comentarios asociados.

\textbf{Prioridad}: Media.

\textbf{RF-EST-006: Visualización de comentarios}

\textbf{Descripción}: Facilita el acceso a todos los comentarios y observaciones del tutor, apoyando la comunicación y la mejora continua del trabajo.

\textbf{Prioridad}: Media.

\textbf{RF-EST-007: Consulta de información de defensa}

\textbf{Descripción}: Proporciona todos los detalles logísticos de la defensa (fecha, hora, tribunal y lugar), para que el estudiante pueda organizarse y prepararse adecuadamente.

\textbf{Prioridad}: Media.

\subsubsection{Requisitos funcionales -
Profesor}\label{requisitos-funcionales---profesor}

\textbf{RF-PROF-001: Visualización de TFG asignados}

\textbf{Descripción}: El profesor puede acceder a un listado organizado de todos los TFG en los que actúa como tutor o cotutor, lo que le permite tener una visión clara de su carga académica y hacer un seguimiento del progreso de sus estudiantes.

\textbf{Prioridad}: Alta.

\textbf{RF-PROF-002: Revisión de TFG}

\textbf{Descripción}: Se garantiza que el profesor pueda descargar y revisar de forma segura los archivos de los TFG bajo su supervisión, facilitando el análisis detallado de cada trabajo.

\textbf{Prioridad}: Alta.

\textbf{RF-PROF-003: Gestión de comentarios}

\textbf{Descripción}: El profesor puede añadir comentarios y feedback estructurado a los TFG que supervisa, asegurando una comunicación efectiva con los estudiantes y orientándolos en la mejora de sus proyectos.

\textbf{Prioridad}: Alta.

\textbf{RF-PROF-004: Cambio de estado de TFG}

\textbf{Descripción}: Permite al profesor actualizar el estado de los TFG que supervisa, registrando además una justificación académica para cada cambio y notificando automáticamente al estudiante.

\textbf{Prioridad}: Alta.

\textbf{RF-PROF-005: Gestión de calificaciones}

\textbf{Descripción}: El profesor puede asignar calificaciones detalladas tras la defensa del TFG, con puntuaciones por criterios y comentarios explicativos, quedando todo registrado en el expediente académico del estudiante.

\textbf{Prioridad}: Media.

\textbf{RF-PROF-006: Participación en tribunales}

\textbf{Descripción}: Ofrece al profesor una visión centralizada de todos los tribunales en los que participa, con fechas, horarios y roles asignados, facilitando la organización de su agenda académica.

\textbf{Prioridad}: Media.

\subsubsection{Requisitos funcionales - Presidente de
Tribunal}\label{requisitos-funcionales---presidente-de-tribunal}

\textbf{RF-PRES-001: Gestión de tribunales}

\textbf{Descripción}: El presidente puede crear, editar y organizar tribunales de evaluación, asegurando que los miembros elegidos cumplan con los requisitos académicos y de disponibilidad.

\textbf{Prioridad}: Alta.

\textbf{RF-PRES-002: Programación de defensas}

\textbf{Descripción}: Permite al presidente programar las defensas de TFG, coordinando fecha, hora, aula y tribunal, con notificaciones automáticas a todos los implicados.

\textbf{Prioridad}: Alta.

\textbf{RF-PRES-003: Gestión de calendario}

\textbf{Descripción}: El presidente puede visualizar y gestionar un calendario completo de defensas, con filtros y navegación para detectar conflictos y planificar con eficiencia.

\textbf{Prioridad}: Alta.

\textbf{RF-PRES-004: Coordinación de disponibilidad}

\textbf{Descripción}: Facilita consultar la agenda de los miembros de un tribunal y encontrar franjas horarias comunes donde todos estén disponibles para una defensa.

\textbf{Prioridad}: Media.

\textbf{RF-PRES-005: Generación de actas}

\textbf{Descripción}: Tras la defensa, el presidente puede generar un acta oficial en PDF con toda la información del evento, las calificaciones y observaciones del tribunal.

\textbf{Prioridad}: Media.

\subsubsection{Requisitos funcionales -
Administrador}\label{requisitos-funcionales---administrador}

\textbf{RF-ADM-001: Gestión completa de usuarios}

\textbf{Descripción}: El administrador tiene control total sobre los usuarios, pudiendo crearlos, modificarlos, eliminarlos y gestionar sus datos y accesos.

\textbf{Prioridad}: Alta.

\textbf{RF-ADM-002: Asignación de roles}

\textbf{Descripción}: Permite cambiar los roles y permisos de cada usuario, adaptando sus privilegios a las responsabilidades académicas que tenga en la plataforma.

\textbf{Prioridad}: Alta.

\textbf{RF-ADM-003: Generación de reportes}

\textbf{Descripción}: El administrador puede generar reportes estadísticos con métricas, gráficos y tendencias que apoyan la toma de decisiones y la mejora de procesos.

\textbf{Prioridad}: Media.

\textbf{RF-ADM-004: Exportación de datos}

\textbf{Descripción}: Ofrece la opción de exportar información en distintos formatos (PDF, Excel, CSV, etc.), asegurando compatibilidad con otras herramientas externas.

\textbf{Prioridad}: Media.

\textbf{RF-ADM-005: Configuración del sistema}

\textbf{Descripción}: Permite ajustar parámetros globales de la plataforma (seguridad, notificaciones, límites, etc.), adaptándola a las políticas y necesidades de la institución.

\textbf{Prioridad}: Baja.

\subsection{Diagrama de casos de uso}\label{diagrama-de-casos-de-uso}

El siguiente diagrama representa las principales interacciones entre los
actores del sistema y las funcionalidades disponibles para cada rol, como se ilustra en la Figura~\ref{fig:diagrama-casos-uso}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Diagrama de casos de uso}]{processed/images/04_analisis_sistema_plantuml_0.png}}
\caption{Diagrama de casos de uso}
\label{fig:diagrama-casos-uso}
\end{figure}

\subsection{Descripción de casos de
uso}\label{descripciuxf3n-de-casos-de-uso}

\subsubsection{UC001 - Crear TFG}\label{uc001---crear-tfg}

\textbf{Actor principal}: Estudiante\\
\textbf{Precondiciones}: El usuario debe estar previamente autenticado en el sistema con rol específico de estudiante, confirmando su identidad y permisos para realizar operaciones académicas. Además, el estudiante no debe tener ningún TFG activo en el sistema, asegurando que pueda dedicar atención completa a un único trabajo de fin de grado.

\textbf{Flujo principal}: 1. El estudiante accede a la opción ``Nuevo
TFG''. 2. El sistema muestra el formulario de creación. 3. El estudiante
completa título, descripción, resumen y palabras clave. 4. El estudiante
selecciona un tutor de la lista disponible. 5. El estudiante confirma la
creación. 6. El sistema valida la información proporcionada. 7. El
sistema crea el TFG en estado ``borrador''. 8. El sistema notifica al
tutor seleccionado.

\textbf{Flujos alternativos}: En el paso 6a, si la validación de la información proporcionada falla por razones como formato incorrecto, datos faltantes o inconsistencias, el sistema presenta errores específicos que guíen al estudiante para corregir los problemas identificados. En el paso 7a, si el sistema detecta que el estudiante ya mantiene un TFG activo, rechaza automáticamente la operación de creación e informa al usuario sobre esta restricción.

\textbf{Postcondiciones}: Como resultado exitoso del proceso, se crea un nuevo TFG completamente inicializado en estado "borrador" que permite al estudiante comenzar el desarrollo de su trabajo académico. Simultáneamente, el tutor seleccionado recibe notificación automática de asignación que le informa sobre su nueva responsabilidad de supervisión académica.

\subsubsection{UC005 - Revisar TFG}\label{uc005---revisar-tfg}

\textbf{Actor principal}: Profesor\\
\textbf{Precondiciones}: El usuario debe estar previamente autenticado en el sistema con rol específico de profesor, confirmando su identidad y permisos para realizar operaciones de supervisión académica. Adicionalmente, el TFG objeto de revisión debe estar formalmente asignado al profesor como tutor principal o cotutor, estableciendo la relación de supervisión necesaria.

\textbf{Flujo principal}: 1. El profesor accede a su lista de TFG
asignados. 2. El profesor selecciona un TFG específico. 3. El sistema
muestra detalles del TFG. 4. El profesor descarga el archivo PDF si está
disponible. 5. El profesor revisa el contenido del trabajo.

\textbf{Flujos alternativos}: En el paso 4a, si no existe archivo PDF subido por el estudiante, el sistema informa claramente de esta situación al profesor, proporcionando orientación sobre las acciones posibles como contactar al estudiante o esperar la subida del documento. En el paso 2a, si el TFG seleccionado no está asignado al profesor como tutor, el sistema deniega automáticamente el acceso para mantener la confidencialidad y seguridad de los trabajos académicos.

\textbf{Postcondiciones}: Como resultado exitoso del proceso, el profesor obtiene acceso completo al contenido del TFG para realizar evaluación detallada, incluyendo capacidad de descarga del documento y revisión de toda la información académica asociada al trabajo.

\subsubsection{UC010 - Programar
defensa}\label{uc010---programar-defensa}

\textbf{Actor principal}: Presidente de Tribunal\\
\textbf{Precondiciones}: El usuario debe estar previamente autenticado en el sistema con rol específico de presidente de tribunal, confirmando su autoridad para coordinar procesos de defensa académica. Debe existir al menos un tribunal previamente creado y disponible para asignación a defensas. El TFG objetivo debe encontrarse en estado "aprobado", indicando que ha superado la revisión del tutor y está listo para el proceso de defensa.

\textbf{Flujo principal}: 1. El presidente accede al calendario de
defensas. 2. El presidente selecciona un TFG aprobado para programar. 3.
El sistema muestra opciones de tribunales disponibles. 4. El presidente
selecciona tribunal, fecha, hora y aula. 5. El sistema verifica
disponibilidad de todos los miembros. 6. El presidente confirma la
programación. 7. El sistema crea la defensa programada. 8. El sistema
envía notificaciones a estudiante y miembros del tribunal.

\textbf{Flujos alternativos}: En el paso 5a, si existen conflictos de disponibilidad entre miembros del tribunal en la fecha propuesta, el sistema analiza automáticamente alternativas y sugiere fechas y horarios donde todos los miembros puedan participar. En el paso 4a, si no hay tribunales disponibles para asignación, el sistema orienta al presidente para crear un nuevo tribunal antes de continuar con la programación de la defensa.

\textbf{Postcondiciones}: Como resultado exitoso del proceso, se establece una defensa completamente programada con fecha, hora, tribunal y aula asignados de manera definitiva. Simultáneamente, todos los involucrados incluyendo estudiante, miembros del tribunal y personal administrativo reciben notificaciones automáticas con los detalles completos del evento programado.

\subsection{Diagramas de secuencia}\label{diagramas-de-secuencia}

Los diagramas de secuencia ilustran la interacción temporal entre los diferentes componentes del sistema durante la ejecución de los casos de uso más críticos. Estas representaciones permiten comprender el flujo de mensajes, la sincronización de operaciones y las responsabilidades de cada actor en los procesos principales del sistema.

\subsubsection{Secuencia: Subida de archivo
TFG}\label{secuencia-subida-de-archivo-tfg}

El proceso de subida de archivos TFG representa una de las funcionalidades más importantes del sistema, involucrando validación, almacenamiento seguro y notificación de cambios de estado. La secuencia completa se detalla en la Figura~\ref{fig:secuencia-subida-archivo}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,width=0.85\textwidth,alt={Secuencia: Subida de archivo TFG}]{processed/images/04_analisis_sistema_plantuml_1.png}}
\caption{Secuencia: Subida de archivo TFG}
\label{fig:secuencia-subida-archivo}
\end{figure}

\subsubsection{Secuencia: Cambio de estado de
TFG}\label{secuencia-cambio-de-estado-de-tfg}

La gestión de estados del TFG requiere validación de permisos, actualización de datos y coordinación entre múltiples actores del sistema. Este flujo se representa en la Figura~\ref{fig:secuencia-cambio-estado}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,width=0.85\textwidth,alt={Secuencia: Cambio de estado de TFG}]{processed/images/04_analisis_sistema_plantuml_2.png}}
\caption{Secuencia: Cambio de estado de TFG}
\label{fig:secuencia-cambio-estado}
\end{figure}

\subsubsection{Secuencia: Programación de
defensa}\label{secuencia-programaciuxf3n-de-defensa}

La programación de defensas involucra la coordinación entre tribunales, verificación de disponibilidad y asignación de recursos. El proceso completo de coordinación se ilustra en la Figura~\ref{fig:secuencia-programacion-defensa}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,width=0.85\textwidth,alt={Secuencia: Programación de defensa}]{processed/images/04_analisis_sistema_plantuml_3.png}}
\caption{Secuencia: Programación de defensa}
\label{fig:secuencia-programacion-defensa}
\end{figure}

\section{Garantía de calidad}\label{garantuxeda-de-calidad}

La garantía de calidad constituye un aspecto fundamental del desarrollo de la plataforma, estableciendo los mecanismos y procedimientos necesarios para asegurar que el sistema cumple con los estándares de excelencia requeridos en un entorno académico universitario. Esta sección define las estrategias de seguridad, rendimiento y confiabilidad que garantizan el funcionamiento óptimo del sistema.

\subsection{Rendimiento}\label{rendimiento}

\textbf{RNF-001: Tiempo de respuesta}

\textbf{Descripción}: El sistema debe ser ágil: inicio de sesión en menos de 2s, páginas en menos de 3s, subida de archivos de hasta 50MB en menos de 30s y reportes generados en menos de 10s.

\textbf{Prioridad}: Alta.

\textbf{RNF-002: Rendimiento bajo carga}

\textbf{Descripción}: Debe soportar al menos 100 usuarios trabajando al mismo tiempo sin que se degrade la experiencia ni aumenten los tiempos de espera.

\textbf{Prioridad}: Media.

\textbf{RNF-003: Escalabilidad}

\textbf{Descripción}: La arquitectura debe permitir crecer fácilmente en usuarios, datos y carga de trabajo, añadiendo recursos sin grandes cambios ni interrupciones.

\textbf{Prioridad}: Media.

\subsection{Seguridad}\label{seguridad}

\textbf{RNF-004: Autenticación}

\textbf{Descripción}: Se usará un sistema seguro con JWT: sesiones que expiran en 1 hora, refresh tokens con rotación y cierre de sesión que invalida todo de inmediato.

\textbf{Prioridad}: Alta.

\textbf{RNF-005: Autorización}

\textbf{Descripción}: El acceso estará controlado por roles y permisos, garantizando que cada usuario solo pueda ver o modificar lo que le corresponde.

\textbf{Prioridad}: Alta.

\textbf{RNF-006: Protección de datos}

\textbf{Descripción}: Cumple con el RGPD, aplicando cifrado en tránsito y en reposo, registro de accesos y políticas claras de retención y borrado de datos personales.

\textbf{Prioridad}: Alta.

\subsection{Usabilidad}\label{usabilidad}

\textbf{RNF-007: Interfaz intuitiva}

\textbf{Descripción}: El sistema debe ser fácil de usar, de modo que cualquier usuario pueda manejar lo básico en menos de 30 minutos sin formación especializada.

\textbf{Prioridad}: Alta.

\textbf{RNF-008: Diseño responsivo}

\textbf{Descripción}: La plataforma debe funcionar igual de bien en ordenador, tablet o móvil, adaptándose al tamaño de pantalla.

\textbf{Prioridad}: Media.

\textbf{RNF-009: Accesibilidad}

\textbf{Descripción}: Cumple el nivel AA de las WCAG 2.1, asegurando que personas con distintas capacidades puedan utilizarla, incluyendo soporte para tecnologías asistivas.

\textbf{Prioridad}: Media.

\subsection{Confiabilidad}\label{confiabilidad}

\textbf{RNF-010: Disponibilidad}

\textbf{Descripción}: El sistema debe estar disponible al menos un 99,5\% del tiempo en horario académico (8:00-20:00), con mantenimientos programados fuera de ese rango.

\textbf{Prioridad}: Alta.

\textbf{RNF-011: Recuperación de errores}

\textbf{Descripción}: En caso de fallo, debe poder restaurarse en menos de 4 horas (RTO) y perder como máximo 1 hora de datos (RPO).

\textbf{Prioridad}: Media.

\textbf{RNF-012: Consistencia de datos}

\textbf{Descripción}: Toda la información debe ser íntegra y coherente, aplicando transacciones ACID y validación estricta en la base de datos.

\textbf{Prioridad}: Alta.

\subsection{Interoperabilidad}\label{interoperabilidad}

\textbf{RNF-013: APIs REST estándar}\label{apis-rest-estuxe1ndar}

\textbf{Descripción}: La plataforma expone APIs RESTful con endpoints claros, uso correcto de métodos HTTP y códigos de estado consistentes. Toda la API está documentada automáticamente con OpenAPI/Swagger, lo que facilita pruebas y colaboración entre desarrolladores.

\textbf{Prioridad}: Alta.

\textbf{RNF-014: Formato de datos estándar}\label{formato-de-datos-estuxe1ndar}

\textbf{Descripción}: La comunicación usa JSON (HAL+JSON) con enlaces hipermedia, paginación estándar y filtros consistentes, lo que facilita navegar grandes volúmenes de datos y descubrir relaciones

\textbf{Prioridad}: Alta.

\subsection{Operabilidad}\label{operabilidad}

\textbf{RNF-015: Monitorización}\label{monitorizaciuxf3n}

\textbf{Descripción}: El sistema mide tiempos de respuesta, latencia (P95/P99) y uso en tiempo real. Incluye un endpoint \/health que verifica la salud de la aplicación y genera alertas proactivas ante degradaciones.

\textbf{Prioridad}: Alta.

\textbf{RNF-016: Mantenibilidad}\label{mantenibilidad}

\textbf{Descripción}: El código está organizado en capas (presentación, negocio, persistencia), sigue principios SOLID y dependency injection, con documentación clara para facilitar evolución y la incorporación de nuevos desarrolladores.

\textbf{Prioridad}: Alta.

\subsection{Transferibilidad}\label{transferibilidad}

\textbf{RNF-017: Containerización}\label{containerizaciuxf3n}

\textbf{Descripción}: Se utiliza Docker y DDEV para garantizar entornos reproducibles. Toda la infraestructura está definida en docker-compose.yml, permitiendo levantar el sistema completo con un solo comando y evitando el clásico “en mi máquina funciona”.

\textbf{Prioridad}: Alta.

\subsection{Eficiencia}\label{eficiencia}

\textbf{RNF-018: Optimización frontend}\label{optimizaciuxf3n-frontend}

\textbf{Descripción}: Se aplican técnicas como code splitting, lazy loading, memoization y virtual scrolling, junto con caching en varias capas (React Query, Service Workers, browser caching), lo que asegura rapidez y fluidez incluso en grandes volúmenes de datos.

\textbf{Prioridad}: Alta.

\textbf{RNF-019: Optimización backend}\label{optimizaciuxf3n-backend}

\textbf{Descripción}: Se usan índices compuestos, connection pooling y carga diferida de relaciones para acelerar consultas. Además, incluye compresión Gzip, paginación inteligente, selección de campos y limitación de peticiones (rate limiting) para garantizar rendimiento y estabilidad.

\textbf{Prioridad}: Alta.

\subsection{Mantenibilidad}\label{mantenibilidad-1}

\textbf{RNF-020: Calidad de código}\label{calidad-de-cuxf3digo}

\textbf{Descripción}: El código se mantiene homogéneo con ESLint, Prettier, PHP CS Fixer y PHPStan, además de commits convencionales que mejoran la trazabilidad y facilitan changelogs automáticos.

\textbf{Prioridad}: Alta.

\textbf{RNF-021: Arquitectura mantenible}\label{arquitectura-mantenible}

\textbf{Descripción}: Se implementan patrones de diseño probados (Repository, Factory, Observer, Strategy) que hacen al sistema extensible, adaptable a cambios y fácil de mantener a largo plazo.

\textbf{Prioridad}: Alta.

\section{Gestión del presupuesto}\label{gestiuxf3n-del-presupuesto}

En el contexto académico de este TFG, la gestión presupuestaria presenta características específicas que requieren una aproximación diferente a la de un proyecto empresarial. La evaluación abarca principalmente en la valoración del tiempo de desarrollo invertido, la utilización de herramientas y recursos educativos disponibles, y la estimación de costos equivalentes que tendría el proyecto en un entorno comercial profesional. Esta valoración proporciona una comprensión clara del valor del trabajo realizado y su equivalencia en términos de mercado laboral.

\subsection{Estructura de costos}\label{estructura-de-costos}

\subsubsection{Costos de desarrollo}\label{costos-de-desarrollo}

\textbf{Tiempo de desarrollo}: La estimación total del proyecto contempla 400 horas de desarrollo distribuidas a lo largo de 10 semanas de trabajo intensivo, lo que representa una dedicación promedio de 40 horas semanales con variaciones según la complejidad de cada fase del desarrollo. El valor hora de desarrollo junior se establece en €15/hora tomando como referencia estándares del mercado laboral para desarrolladores con experiencia limitada pero competentes en las tecnologías utilizadas. El costo total teórico de desarrollo alcanza €6,000, proporcionando una valoración económica del esfuerzo invertido aunque el proyecto se realice en modalidad académica.

\subsubsection{Infraestructura y
herramientas}\label{infraestructura-y-herramientas}

\textbf{Herramientas de desarrollo} (gratuitas para estudiantes): DDEV como herramienta open source permite desarrollo containerizado sin licencias comerciales, garantizando entornos reproducibles. VS Code ofrece un IDE completo y gratuito con extensiones especializadas que proporcionan funcionalidad equivalente a IDEs comerciales. Draw.io facilita creación de diagramas UML profesionales sin costo de licencias de software especializado.

\textbf{Infraestructura de desarrollo}: El desarrollo local utiliza máquina personal sin costos adicionales de hardware o alquiler de servicios, optimizando presupuesto mediante aprovechamiento de recursos existentes. La base de datos MySQL ejecuta en contenedor local proporcionando entorno idéntico a producción sin costos de hosting durante desarrollo. Los servicios de testing se ejecutan localmente mediante DDEV, eliminando necesidad de entornos de testing en cloud y reduciendo costos operativos.

\subsubsection{Costos de producción
estimados}\label{costos-de-producciuxf3n-estimados}

\textbf{Hosting y dominio} (mensual): Un VPS básico con especificaciones de 2GB RAM, 1 CPU y 40GB SSD resulta suficiente para deployment inicial con costo estimado entre €10-20 mensuales según proveedor seleccionado. El dominio requiere inversión anual de aproximadamente €10 para establecer presencia web profesional. El certificado SSL se obtiene gratuitamente mediante Let's Encrypt, eliminando costos de seguridad adicionales. Los emails transaccionales del sistema se cubren mediante servicios gratuitos que permiten hasta 100 emails diarios, suficiente para operaciones iniciales.

\chapter{Diseño}\label{diseuxf1o}
En este capítulo se desarrollarán los aspectos fundamentales del diseño del sistema,
abarcando desde la arquitectura general hasta los detalles específicos
de implementación.

En primer lugar, se presenta la arquitectura física, que define la
organización estructural de los componentes del sistema y sus
interacciones. Posteriormente, se aborda la arquitectura lógica,
estableciendo los patrones de diseño y las responsabilidades de cada
módulo. Finalmente, se incluye el esquema de la base de datos y el
diseño de la interfaz de usuario, elementos esenciales para completar la
visión técnica del proyecto.

\section{Arquitectura física}\label{arquitectura-fuxedsica}

Iniciando con la arquitectura física del sistema, se establece la base
estructural sobre la cual se construye toda la plataforma. Esta
arquitectura define la organización de los componentes de hardware y
software, así como sus interacciones y dependencias, proporcionando una
visión clara de cómo se despliega y ejecuta el sistema en un entorno
real.

La arquitectura física de la Plataforma de Gestión de TFG se basa en una
separación clara entre capas de presentación, lógica de negocio y
persistencia, implementando un patrón de arquitectura distribuida que
garantiza escalabilidad, mantenibilidad y seguridad.

\subsection{Módulo frontend (Capa de
presentación)}\label{muxf3dulo-frontend-capa-de-presentaciuxf3n}

El frontend constituye la capa de presentación del sistema, desarrollado
como una Single Page Application (SPA) que se ejecuta completamente en
el navegador del usuario.

\subsubsection{Arquitectura de componentes
React}\label{arquitectura-de-componentes-react}

La arquitectura de componentes React implementa un patrón jerárquico que facilita la reutilización, mantenimiento y escalabilidad del código frontend. Esta estructura modular permite una clara separación de responsabilidades y optimiza el rendimiento mediante técnicas de lazy loading y memoización, como se ilustra en la Figura~\ref{fig:arquitectura-componentes-react}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Arquitectura de componentes React}]{processed/images/05_diseno_plantuml_0.png}}
\caption{Arquitectura de componentes React}
\label{fig:arquitectura-componentes-react}
\end{figure}

\textbf{Componentes principales}:

\begin{itemize}
\tightlist
\item
  \textbf{Componente de Presentación}: Contenedor principal que gestiona la
  estructura visual global.
\item
  \textbf{Navegación}: Sistema de navegación dinámico basado en roles de
  usuario.
\item
  \textbf{Rutas Protegidas}: Wrapper que controla acceso a rutas según
  autenticación y permisos.
\item
  \textbf{Componentes de Página}: Componentes de página específicos para cada
  funcionalidad.
\end{itemize}

\textbf{Patrones de diseño implementados}:

\begin{itemize}
\tightlist
\item
  \textbf{Composición de Componentes}: Composición de funcionalidades
  mediante componentes reutilizables.
\item
  \textbf{Componentes en Orden Ascendente}: ProtectedRoute como HOC para control
  de acceso.
\item
  \textbf{Renderización de propiedades}: Componentes que exponen funcionalidad mediante
  propiedades de función.
\item
  \textbf{Hooks Personalizados}: Abstracción de lógica de negocio reutilizable
  entre componentes.
\end{itemize}

\subsection{Módulo backend (Capa de lógica de
negocio)}\label{muxf3dulo-backend-capa-de-luxf3gica-de-negocio}

El backend implementa una arquitectura hexagonal (puertos y adaptadores)
usando Symfony 6.4 LTS, proporcionando APIs REST robustas y escalables.

\subsubsection{Arquitectura hexagonal}\label{arquitectura-hexagonal}

La arquitectura hexagonal, también conocida como arquitectura de puertos y adaptadores, permite aislar la lógica de negocio de las dependencias externas, facilitando el testing, la mantenibilidad y la evolución del sistema. Esta aproximación garantiza que los cambios en tecnologías específicas no impacten el núcleo del negocio, como se representa en la Figura~\ref{fig:arquitectura-hexagonal}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Arquitectura hexagonal}]{processed/images/05_diseno_plantuml_1.png}}
\caption{Arquitectura hexagonal}
\label{fig:arquitectura-hexagonal}
\end{figure}

\textbf{Capas de la arquitectura}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Capa de Dominio}: Lógica de negocio pura, independiente de
  frameworks.
\item
  \textbf{Capa de Aplicación}: Casos de uso y servicios de aplicación.
\item
  \textbf{Capa de Infraestructura}: Implementaciones concretas (BD,
  servicios externos).
\item
  \textbf{Capa de Interfaz}: Controladores API y serialización.
\end{enumerate}

\subsection{Módulo de base de datos (Capa de
persistencia)}\label{muxf3dulo-de-base-de-datos-capa-de-persistencia}

La capa de persistencia utiliza MySQL 8.0 como sistema de gestión de
base de datos, implementando un diseño relacional optimizado con
Doctrine ORM.

\subsubsection{Estrategia de
persistencia}\label{estrategia-de-persistencia}

\textbf{Migration Strategy}: La estrategia de migración implementa un sistema robusto de control de esquema que utiliza Doctrine Migrations para versionado automático, garantizando que todos los cambios en la estructura de base de datos sean rastreables y reproducibles a través de diferentes entornos. La capacidad de rollback permite reversión segura a versiones anteriores del esquema en caso de problemas post-despliegue, proporcionando un mecanismo de contingencia crítico para operaciones de producción. La seguridad en producción se asegura mediante validación exhaustiva antes de aplicar migraciones, incluyendo testing y verificaciones de integridad que previenen corruption de datos durante actualizaciones de esquema.

\subsection{Módulo de archivos
(Almacenamiento)}\label{muxf3dulo-de-archivos-almacenamiento}

El sistema de archivos está diseñado para manejar subidas seguras de
documentos PDF con validación exhaustiva y almacenamiento optimizado.

\textbf{Medidas de Seguridad de Archivos}: El sistema implementa medidas de seguridad para protección de archivos que incluyen validación estricta de tipo MIME permitiendo exclusivamente archivos PDF para prevenir subida de contenido malicioso o formatos no autorizados. Las limitaciones de tamaño establecen un máximo de 50MB por archivo, balanceando capacidad de almacenamiento de documentos académicos completos con optimización de recursos del servidor y tiempos de transferencia razonables.

\subsubsection{Estrategia
Almacenamiento}\label{estrategia-almacenamiento}

La estrategia de almacenamiento de archivos implementa un sistema robusto y escalable que garantiza la integridad, seguridad y disponibilidad de los documentos TFG. Este diseño contempla validación automática, almacenamiento seguro y mecanismos de copia de seguridad, como se detalla en la Figura~\ref{fig:estrategia-almacenamiento}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Estrategia Almacenamiento}]{processed/images/05_diseno_plantuml_2.png}}
\caption{Estrategia Almacenamiento}
\label{fig:estrategia-almacenamiento}
\end{figure}

\textbf{Flujo de procesamiento de archivos}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Validación previa}: MIME type, tamaño y estructura básica del
  PDF.
\item
  \textbf{Procesamiento seguro}: Almacenamiento con nombre único y ruta
  encriptada.
\item
  \textbf{Metadatos}: Extracción y almacenamiento de información del
  archivo.
\item
  \textbf{Acceso controlado}: URLs temporales con expiración automática.
\end{enumerate}

\section{Arquitectura lógica}\label{arquitectura-luxf3gica}

Habiendo establecido la arquitectura física del sistema, es fundamental
abordar la arquitectura lógica, la cual define la organización
conceptual y funcional de los componentes de software. 

La arquitectura lógica organiza los componentes del sistema según
responsabilidades funcionales, implementando patrones de diseño que
garantizan separación de ámbitos y alta cohesión.

\subsection{Capa de presentación
(Frontend)}\label{capa-de-presentaciuxf3n-frontend}

\subsubsection{Patrón Container/Presentational}\label{patruxf3n-containerpresentational}

\textbf{Componentes Container}: Gestionan la lógica de negocio de la interfaz, interactúan con los servicios y hooks personalizados, controlan estados como loading o error, y transmiten los datos a los componentes de presentación.

\textbf{Componentes Presentational}: Se encargan únicamente del renderizado de la UI. Reciben datos y callbacks como props, garantizando interfaces reutilizables, simples y fáciles de probar.

\subsubsection{Control de Estado}\label{state-management-pattern}

\textbf{Implementada con Context API}: Uso de Context API para manejar autenticación, notificaciones y datos compartidos.

\textbf{Hooks personalizados}: Encapsulan lógica de negocio relacionada con la obtención, creación y actualización de TFGs. Esto permite reutilizar lógica y mantener los componentes más limpios.

\textbf{Jerarquía clara de contextos}: Rodean la aplicación (AuthProvider, NotificacionesProvider), asegurando un flujo de datos centralizado y consistente.

\subsection{Capa de lógica de negocio
(Backend)}\label{capa-de-luxf3gica-de-negocio-backend}

\subsubsection{Diseño Domain-Driven}\label{domain-driven-design}

\textbf{Patrón de Agregación}: Encapsulan entidades principales (ej. TFG) y sus reglas de negocio, como las transiciones válidas de estado (borrador → revisión → aprobado → defendido). Esto evita inconsistencias y mantiene las reglas dentro del dominio.

\textbf{Clases de Valor}: Representan conceptos inmutables y validados (ej. Email), aportando robustez al modelo y evitando datos inválidos.

\subsubsection{Patrón Service Layer}\label{patruxf3n-service-layer}

Implementa la orquestación de casos de uso: creación de un TFG, notificación automática al tutor, validación de permisos, etc. Los servicios actúan como puente entre la lógica de dominio y la infraestructura (repositorios, notificaciones, eventos). Favorece el desacoplamiento y asegura que las reglas de negocio no dependan de frameworks ni librerías externas. 

\subsection{Capa de persistencia}\label{capa-de-persistencia}

\subsubsection{Patrón de Repositorio}\label{repository-pattern}

Define interfaces que abstraen el acceso a datos (ej. buscar TFGs por estudiante, tutor o estado). Implementación mediante Doctrine ORM, lo que permite consultas optimizadas y expresivas sin depender directamente de SQL en la lógica de negocio. Permite cambiar la estrategia de persistencia (ej. migrar de MySQL a PostgreSQL) sin afectar al dominio ni a la lógica de negocio. 

\section{Esquema de la base de datos}\label{esquema-de-la-base-de-datos}

El esquema de base de datos propuesto sigue principios de normalización
que garantizan la consistencia y eliminan la redundancia, mientras que
los índices y constraints aseguran tanto el rendimiento como la
integridad referencial. Esta estructura de datos ha sido
diseñada con mucho detalle para soportar eficientemente todas las operaciones requeridas
por los diferentes módulos del sistema.

\subsection{Modelo conceptual}\label{modelo-conceptual}

El modelo conceptual de la base de datos representa las entidades principales del sistema y sus relaciones, proporcionando la base para la implementación física. Este diseño garantiza la integridad referencial, optimiza las consultas más frecuentes y establece la estructura de datos necesaria para soportar todas las funcionalidades del sistema, como se ilustra en la Figura~\ref{fig:modelo-conceptual}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Modelo conceptual}]{processed/images/05_diseno_plantuml_3.png}}
\caption{Modelo conceptual}
\label{fig:modelo-conceptual}
\end{figure}

\subsection{Normalización y
constraints}\label{normalizaciuxf3n-y-constraints}

\subsubsection{Tercera forma normal
(3NF)}\label{tercera-forma-normal-3nf}

El esquema cumple con la tercera forma normal mediante:

\textbf{Primera Forma Normal (1NF)}: - Todos los campos contienen
valores atómicos. - Campos JSON utilizados únicamente para datos
semi-estructurados (roles, palabras clave, metadata). - No hay grupos
repetitivos de columnas.

\textbf{Segunda Forma Normal (2NF)}: - Todas las tablas tienen claves
primarias definidas. - Todos los atributos no-clave dependen
completamente de la clave primaria. - No hay dependencias parciales.

\textbf{Tercera Forma Normal (3NF)}: - No existen dependencias
transitivas. - Cada atributo no-clave depende directamente de la clave
primaria.

\subsubsection{Constraints e integridad
referencial}\label{constraints-e-integridad-referencial}

\textbf{Primary Keys}:

\begin{lstlisting}[language=SQL]
ALTER TABLE users ADD CONSTRAINT pk_users PRIMARY KEY (id);
ALTER TABLE tfgs ADD CONSTRAINT pk_tfgs PRIMARY KEY (id);
ALTER TABLE tribunales ADD CONSTRAINT pk_tribunales PRIMARY KEY (id);
ALTER TABLE defensas ADD CONSTRAINT pk_defensas PRIMARY KEY (id);
\end{lstlisting}

\textbf{Foreign Keys}:

\begin{lstlisting}[language=SQL]
ALTER TABLE tfgs 
  ADD CONSTRAINT fk_tfg_estudiante 
  FOREIGN KEY (estudiante_id) REFERENCES users(id) ON DELETE RESTRICT;

ALTER TABLE tfgs 
  ADD CONSTRAINT fk_tfg_tutor 
  FOREIGN KEY (tutor_id) REFERENCES users(id) ON DELETE RESTRICT;

ALTER TABLE defensas 
  ADD CONSTRAINT fk_defensa_tfg 
  FOREIGN KEY (tfg_id) REFERENCES tfgs(id) ON DELETE CASCADE;
\end{lstlisting}

\textbf{Unique Constraints}:

\begin{lstlisting}[language=SQL]
ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email);
ALTER TABLE users ADD CONSTRAINT uk_users_dni UNIQUE (dni);
ALTER TABLE defensas ADD CONSTRAINT uk_defensa_tfg UNIQUE (tfg_id);
\end{lstlisting}

\textbf{Check Constraints}:

\begin{lstlisting}[language=SQL]
ALTER TABLE tfgs 
  ADD CONSTRAINT ck_tfg_estado 
  CHECK (estado IN ('borrador', 'revision', 'aprobado', 'defendido'));

ALTER TABLE calificaciones 
  ADD CONSTRAINT ck_calificacion_notas 
  CHECK (
    nota_presentacion >= 0 AND nota_presentacion <= 10 AND
    nota_contenido >= 0 AND nota_contenido <= 10 AND
    nota_defensa >= 0 AND nota_defensa <= 10 AND
    nota_final >= 0 AND nota_final <= 10
  );
\end{lstlisting}

\subsection{Índices de rendimiento}\label{uxedndices-de-rendimiento}

\subsubsection{Índices principales}\label{uxedndices-principales}

\textbf{Índices de búsqueda frecuente}:

\begin{lstlisting}[language=SQL]
-- Búsquedas por estudiante (muy frecuente)
CREATE INDEX idx_tfgs_estudiante ON tfgs(estudiante_id);

-- Búsquedas por tutor (muy frecuente)  
CREATE INDEX idx_tfgs_tutor ON tfgs(tutor_id);

-- Búsquedas por estado (frecuente para reportes)
CREATE INDEX idx_tfgs_estado ON tfgs(estado);

-- Búsquedas de defensas por fecha (calendario)
CREATE INDEX idx_defensas_fecha ON defensas(fecha_defensa);

-- Notificaciones no leídas por usuario
CREATE INDEX idx_notificaciones_usuario_leida ON notificaciones(usuario_id, leida);
\end{lstlisting}

\textbf{Índices compuestos}:

\begin{lstlisting}[language=SQL]
-- Combinación frecuente: tutor + estado
CREATE INDEX idx_tfgs_tutor_estado ON tfgs(tutor_id, estado);

-- Tribunal disponible para programación
CREATE INDEX idx_tribunales_activo ON tribunales(activo, created_at);

-- Defensas por tribunal y fecha
CREATE INDEX idx_defensas_tribunal_fecha ON defensas(tribunal_id, fecha_defensa);
\end{lstlisting}

\subsubsection{Análisis de consultas}\label{anuxe1lisis-de-consultas}

\textbf{Query más frecuente - TFGs por tutor}:

\begin{lstlisting}[language=SQL]
EXPLAIN SELECT t.*, e.nombre as estudiante_nombre
FROM tfgs t 
INNER JOIN users e ON t.estudiante_id = e.id
WHERE t.tutor_id = ? 
ORDER BY t.updated_at DESC;

-- Usa índice: idx_tfgs_tutor
-- Rows examined: ~10-50 por profesor
-- Execution time: < 5ms
\end{lstlisting}

\textbf{Query compleja - Dashboard admin}:

\begin{lstlisting}[language=SQL]
EXPLAIN SELECT 
  COUNT(*) as total_tfgs,
  COUNT(CASE WHEN estado = 'borrador' THEN 1 END) as borradores,
  COUNT(CASE WHEN estado = 'revision' THEN 1 END) as en_revision,
  COUNT(CASE WHEN estado = 'aprobado' THEN 1 END) as aprobados,
  COUNT(CASE WHEN estado = 'defendido' THEN 1 END) as defendidos
FROM tfgs 
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);

-- Usa índice: idx_tfgs_estado + created_at
-- Query optimizada para agregaciones
\end{lstlisting}

\section{Diseño de la interfaz de
usuario}\label{diseuxf1o-de-la-interfaz-de-usuario}

Para completar la visión integral del diseño del sistema, es fundamental
abordar el diseño de la interfaz de usuario, elemento que determina la
experiencia y satisfacción de los usuarios finales. La interfaz de
usuario representa el punto de contacto entre el sistema y sus usuarios,
por lo que su diseño debe equilibrar funcionalidad, usabilidad y
estética para proporcionar una experiencia óptima a cada tipo de
usuario.

\subsection{Interfaces de usuario implementadas}\label{interfaces-de-usuario-implementadas}

Una vez establecidos los fundamentos del diseño de la interfaz de usuario, es fundamental presentar las interfaces finales implementadas que materializan todos los conceptos y patrones de diseño descritos anteriormente. Esta sección documenta las pantallas principales del sistema, organizadas por roles de usuario, mostrando cómo se aplican los principios de usabilidad, accesibilidad y consistencia visual en cada una de las funcionalidades implementadas.

Las interfaces presentadas a continuación representan el resultado de un proceso iterativo de diseño centrado en el usuario, donde cada pantalla ha sido optimizada para las tareas específicas de cada rol, manteniendo la coherencia del sistema de diseño establecido y garantizando una experiencia de usuario intuitiva y eficiente.

\subsubsection{Dashboard de Estudiante}\label{dashboard-de-estudiante}

El dashboard del estudiante constituye el punto central de interacción para los usuarios con rol de estudiante, proporcionando acceso directo a las funcionalidades principales del ciclo de vida del TFG. La interfaz implementa un diseño limpio y funcional que facilita la navegación y el seguimiento del progreso académico, como se muestra en la Figura~\ref{fig:dashboard-estudiante}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/dashboard_estudiante.png}
\caption{Dashboard principal del estudiante con overview del TFG y navegación}
\label{fig:dashboard-estudiante}
\end{figure}

El dashboard presenta elementos clave como el estado actual del TFG, notificaciones relevantes, accesos directos a las funciones más utilizadas y un resumen del progreso académico. La interfaz utiliza cards informativos que organizan la información de manera jerárquica, permitiendo al estudiante obtener una visión general rápida de su situación académica.

\subsubsection{Gestión de TFG - Vista de Estudiante}\label{gestion-de-tfg---vista-de-estudiante}

La interfaz de gestión de TFG para estudiantes proporciona las herramientas necesarias para la carga, edición y seguimiento de los trabajos de fin de grado. Esta pantalla integra funcionalidades de subida de archivos, edición de metadatos y visualización del historial de revisiones, tal como se presenta en la Figura~\ref{fig:gestion-tfg-estudiante}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/gestion_tfg_estudiante.png}
\caption{Interfaz de gestión de TFG para estudiantes con formularios de carga y metadatos}
\label{fig:gestion-tfg-estudiante}
\end{figure}

La interfaz incluye un sistema de drag-and-drop para la carga de documentos PDF, campos estructurados para título, resumen y palabras clave, así como indicadores visuales del progreso de carga y validación de archivos. El diseño responsivo garantiza una experiencia óptima tanto en dispositivos de escritorio como móviles. Figura~\ref{fig:tfg-estudiante-extendido}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/tfg-estudiante-extendido.png}
\caption{Vista extendida de gestión de TFG para estudiantes con detalles adicionales}
\label{fig:tfg-estudiante-extendido}
\end{figure}

\subsubsection{Sistema de Notificaciones}\label{sistema-de-notificaciones}

El sistema de notificaciones implementa un enfoque no intrusivo que mantiene a los usuarios informados sobre eventos relevantes sin interrumpir su flujo de trabajo. La interfaz combina notificaciones in-app con indicadores visuales sutiles, como se observa en la Figura~\ref{fig:sistema-notificaciones}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/sistema_notificaciones.png}
\caption{Sistema de notificaciones con dropdown y estados de lectura}
\label{fig:sistema-notificaciones}
\end{figure}

Las notificaciones se categorizan por tipo (información, éxito, advertencia, error) utilizando el sistema de colores semánticos establecido, facilitando la comprensión inmediata del tipo de mensaje. El dropdown de notificaciones incluye funcionalidades de filtrado, marcado como leído y navegación directa a las secciones relevantes.

\subsubsection{Dashboard de Profesor}\label{dashboard-de-profesor}

La interfaz del profesor está diseñada para facilitar la supervisión eficiente de múltiples TFGs asignados, proporcionando herramientas de gestión, evaluación y comunicación con estudiantes. El dashboard presenta una vista organizada de los trabajos pendientes de revisión y las tareas prioritarias, como se ilustra en la Figura~\ref{fig:dashboard-profesor}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/dashboard_profesor.png}
\caption{Dashboard del profesor con lista de TFGs asignados y estados de revisión}
\label{fig:dashboard-profesor}
\end{figure}

El diseño incluye filtros avanzados para organizar los TFGs por estado, fecha de envío o prioridad, así como acciones rápidas para cambios de estado y redacción de comentarios. La interfaz utiliza indicadores visuales claros para distinguir entre trabajos que requieren atención inmediata y aquellos en proceso normal.

\subsubsection{Sistema de Evaluación y Feedback}\label{sistema-de-evaluacion-y-feedback}

La interfaz de evaluación proporciona a los profesores herramientas completas para la revisión y calificación de los TFGs, incluyendo formularios estructurados de evaluación y sistemas de comentarios contextuales, tal como se presenta en la Figura~\ref{fig:sistema-evaluacion}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/sistema_evaluacion.png}
\caption{Sistema de evaluación con formularios de calificación y comentarios}
\label{fig:sistema-evaluacion}
\end{figure}

La interfaz integra formularios dinámicos que se adaptan a diferentes criterios de evaluación, sistemas de puntuación configurable y herramientas de texto enriquecido para comentarios detallados. El diseño facilita la navegación entre diferentes secciones del documento mientras se mantiene el contexto de evaluación.Figura~\ref{fig:sistema-evaluacion-comentarios}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/sistema_evaluacion_comentarios.png}
\caption{Sistema de evaluación con comentarios y calificaciones detalladas}
\label{fig:sistema-evaluacion-comentarios}
\end{figure}

\subsubsection{Gestión de Tribunales}\label{gestion-de-tribunales}

La interfaz de gestión de tribunales, accesible para usuarios con rol de presidente de tribunal, proporciona herramientas completas para la creación, configuración y administración de tribunales de evaluación. La pantalla integra funcionalidades de asignación de miembros y gestión de disponibilidad, como se muestra en la Figura~\ref{fig:gestion-tribunales}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/gestion_tribunales.png}
\caption{Interfaz de gestión de tribunales con asignación de miembros y disponibilidad}
\label{fig:gestion-tribunales}
\end{figure}

La interfaz incluye herramientas de búsqueda y filtrado para la selección de profesores, validación automática de conflictos de horario y visualización de la carga de trabajo de cada miembro potencial. El diseño facilita la toma de decisiones informadas en la composición de tribunales.Figura~\ref{fig:detalle-tribunales}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/detalle_tribunales.png}
\caption{Detalle de tribunal con miembros asignados y disponibilidad}
\label{fig:detalle-tribunales}
\end{figure}

\subsubsection{Calendario de Defensas}\label{calendario-de-defensas}

La implementación del calendario de defensas utiliza FullCalendar.js para proporcionar una interfaz interactiva y eficiente para la programación y gestión de defensas de TFG. La interfaz combina vistas de calendario con herramientas de gestión avanzada, tal como se presenta en la Figura~\ref{fig:calendario-defensas}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/calendario_defensas.png}
\caption{Calendario interactivo de defensas con programación y gestión de eventos}
\label{fig:calendario-defensas}
\end{figure}

El calendario implementa funcionalidades de arrastrar y soltar para reprogramación rápida, vistas múltiples (mensual, semanal, diaria), filtros por tribunal o estudiante, y modales contextuales para edición rápida de eventos. La interfaz incluye validaciones automáticas para evitar conflictos de programación.

\subsubsection{Panel de Administración}\label{panel-de-administracion}

El panel de administración proporciona a los administradores del sistema herramientas completas para la gestión de usuarios, configuración del sistema y generación de reportes. La interfaz implementa un diseño dashboard con métricas clave y accesos directos a funcionalidades administrativas, como se observa en la Figura~\ref{fig:panel-administracion}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/panel_administracion.png}
\caption{Panel de administración con métricas del sistema y herramientas de gestión}
\label{fig:panel-administracion}
\end{figure}

El panel incluye widgets informativos con estadísticas en tiempo real, gráficos interactivos para visualización de tendencias y accesos directos a las funcionalidades administrativas más utilizadas. La interfaz utiliza un sistema de permisos granular que adapta las opciones disponibles según el nivel de acceso del usuario.

\subsubsection{Gestión de Usuarios}\label{gestion-de-usuarios}

La interfaz de gestión de usuarios implementa funcionalidades completas de CRUD (crear, leer, actualizar, eliminar) para la administración de usuarios del sistema. La pantalla proporciona herramientas de búsqueda avanzada, filtrado por roles y edición masiva, tal como se presenta en la Figura~\ref{fig:gestion-usuarios}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/gestion_usuarios.png}
\caption{Interfaz de gestión de usuarios con CRUD completo y asignación de roles}
\label{fig:gestion-usuarios}
\end{figure}

La interfaz incluye tablas de datos avanzadas con paginación eficiente, ordenamiento múltiple, filtros dinámicos y acciones en lote. Los formularios de edición implementan validaciones en tiempo real y feedback inmediato para mejorar la experiencia del administrador.

\subsubsection{Sistema de Reportes y Estadísticas}\label{sistema-de-reportes-y-estadisticas}

La implementación del sistema de reportes combina visualización de datos interactiva con herramientas de exportación flexibles, proporcionando a los administradores insights valiosos sobre el rendimiento del sistema y tendencias académicas, como se muestra en la Figura~\ref{fig:sistema-reportes}.

\begin{figure}[H]
\centering
\includegraphics[width=0.9\textwidth]{processed/images/sistema_reportes.png}
\caption{Sistema de reportes con gráficos interactivos y opciones de exportación}
\label{fig:sistema-reportes}
\end{figure}

La interfaz integra gráficos dinámicos construidos con bibliotecas de visualización modernas, filtros temporales y de categoría, así como opciones de exportación en múltiples formatos (PDF, Excel, CSV). El diseño responsivo garantiza la correcta visualización de gráficos complejos en diferentes tamaños de pantalla.

\chapter{Implementación}\label{implementaciuxf3n}
Este capítulo documenta el proceso de implementación de la plataforma, describiendo cómo los requisitos y el diseño establecidos en fases anteriores se materializaron en código funcional. La documentación proporciona una visión técnica del desarrollo realizado, incluyendo las decisiones de arquitectura, patrones implementados y soluciones adoptadas para los retos específicos del proyecto.

La implementación abarca desde la arquitectura de componentes React del frontend hasta las configuraciones de despliegue y las estrategias de testing aplicadas. Cada sección detalla las decisiones técnicas adoptadas, justifica la selección de herramientas específicas y documenta las buenas prácticas aplicadas durante el desarrollo.

\section{Arquitectura de componentes
React}\label{arquitectura-de-componentes-react-1}

La arquitectura frontend se fundamenta en React con una estructura modular que separa claramente las responsabilidades: componentes reutilizables, páginas específicas por rol, gestión de estado centralizada y comunicación con APIs. Esta organización facilita el mantenimiento del código y permite la escalabilidad del sistema.

\subsection{Organización modular del proyecto}\label{estructura-de-directorios}

La estructura del proyecto implementa una separación clara de responsabilidades organizando el código en módulos específicos:

\textbf{Componentes base}: Incluye elementos reutilizables como Layout, ProtectedRoute y sistema de notificaciones, además de un diseño del sistema con componentes UI estandardizados (Button, Input, Modal).

\textbf{Páginas por rol}: Cada tipo de usuario (estudiante, profesor, admin) cuenta con sus páginas específicas, facilitando el desarrollo independiente de funcionalidades según los permisos correspondientes.

\textbf{Gestión de estado}: Los contextos (AuthContext, NotificacionesContext) centralizan el estado global de la aplicación, mientras que los hooks personalizados encapsulan la lógica de negocio específica.

\textbf{Capa de servicios}: Los servicios abstraen la comunicación con el backend, proporcionando una interfaz limpia para las operaciones CRUD y manejo de archivos.

\subsection{Sistema de autenticación y autorización}\label{implementaciuxf3n-del-sistema-de-autenticaciuxf3n}

El sistema de autenticación implementa un patrón Context/Provider para gestionar el estado de autenticación de forma centralizada, combinado con protección de rutas basada en roles para controlar el acceso a diferentes secciones de la aplicación.

\subsubsection{Gestión de estado con AuthContext}\label{authcontext-y-provider}

El AuthContext utiliza useReducer para manejar las transiciones de estado de autenticación (login, logout, errores) y proporciona persistencia mediante localStorage. Las acciones principales incluyen:

\begin{lstlisting}
const authReducer = (state, action) => {
  switch (action.type) {
    case 'LOGIN_SUCCESS':
      return {
        ...state, isAuthenticated: true,
        user: action.payload.user, token: action.payload.token
      };
    case 'LOGOUT':
      return { ...state, isAuthenticated: false, user: null, token: null };
    // ... otros casos
  }
};
\end{lstlisting}

\textbf{Características principales}: Recuperación automática de sesión desde localStorage, manejo de errores de autenticación, actualización del perfil de usuario y comunicación con el servicio de autenticación backend.

\subsubsection{Protección de rutas por roles}\label{componente-protectedroute}

El componente ProtectedRoute implementa un sistema de autorización granular que verifica tanto la autenticación como los roles específicos requeridos para acceder a cada sección:

\begin{lstlisting}
const ProtectedRoute = ({ children, requireRoles = [] }) => {
  const { isAuthenticated, user, loading } = useAuth();

  if (!isAuthenticated) return <Navigate to="/login" />;

  if (requireRoles.length > 0) {
    const hasRequiredRole = requireRoles.some(role =>
      user?.roles.includes(role)
    );
    if (!hasRequiredRole) return <Navigate to="/unauthorized" />;
  }

  return children;
};
\end{lstlisting}

\textbf{Flujo de autorización}: El componente evalúa primero el estado de autenticación, luego verifica los roles requeridos contra los roles del usuario actual, redirigiendo apropiadamente según el caso (login, unauthorized, o permitir acceso).

\subsection{Hooks personalizados para lógica de negocio}\label{implementaciuxf3n-de-hooks-personalizados}

Los hooks personalizados encapsulan la lógica de negocio específica de cada dominio, proporcionando una interfaz consistente para la gestión de estado y operaciones asíncronas. Esta arquitectura separa la lógica de presentación de la lógica de negocio, facilitando la reutilización y el testing.

\subsubsection{Patrón de gestión de entidades con useTFGs}\label{usetfgs-hook}

El hook useTFGs implementa un patrón estándar para gestión de entidades que incluye estado local, operaciones CRUD y integración con notificaciones:

\begin{lstlisting}
export const useTFGs = () => {
  const [tfgs, setTFGs] = useState([]);
  const [loading, setLoading] = useState(false);
  const { addNotification } = useNotifications();

  const createTFG = useCallback(async (tfgData) => {
    setLoading(true);
    try {
      const newTFG = await tfgService.createTFG(tfgData);
      setTFGs(prev => [newTFG, ...prev]);
      addNotification({ type: 'success', titulo: 'TFG creado exitosamente' });
      return newTFG;
    } catch (error) {
      addNotification({ type: 'error', titulo: 'Error al crear TFG' });
      throw error;
    } finally {
      setLoading(false);
    }
  }, [addNotification]);

  // ... otras operaciones (fetchTFGs, updateTFG, uploadFile, changeState)

  return { tfgs, loading, createTFG, updateTFG, uploadFile, changeState };
};
\end{lstlisting}

\textbf{Características principales}: Manejo consistente de estados de carga, integración automática con sistema de notificaciones, sincronización entre estado local y backend, y gestión de actualizaciones para mejorar la experiencia de usuario.

\subsection{Dashboard adaptativo por roles}\label{componentes-de-interfaz-principales}

El componente Dashboard implementa una interfaz adaptativa que presenta información específica según el rol del usuario autenticado. Esta aproximación garantiza que cada tipo de usuario acceda únicamente a las funcionalidades relevantes para su contexto académico.

\subsubsection{Arquitectura de dashboard dinámico}\label{componente-dashboard}

El dashboard utiliza un patrón de composición que integra estadísticas personalizadas, notificaciones contextuales y componentes específicos por rol:

\begin{lstlisting}
const Dashboard = () => {
  const { user } = useAuth();
  const { tfgs, fetchTFGs } = useTFGs();
  const { notifications } = useNotifications();

  const getDashboardContent = () => {
    switch (user?.roles[0]) {
      case 'ROLE_ESTUDIANTE':
        return <EstudianteDashboard stats={stats} tfgs={tfgs} />;
      case 'ROLE_PROFESOR':
        return <ProfesorDashboard stats={stats} tfgs={tfgs} />;
      case 'ROLE_PRESIDENTE_TRIBUNAL':
        return <PresidenteDashboard stats={stats} />;
      case 'ROLE_ADMIN':
        return <AdminDashboard stats={stats} />;
    }
  };

  return (
    <div>
      <WelcomeHeader user={user} />
      <NotificationPanel notifications={notifications} />
      {getDashboardContent()}
    </div>
  );
};
\end{lstlisting}

\textbf{Características funcionales}: Plantilla personalizadad según el rol de usuario, renderizado condicional de notificaciones pendientes, y delegación a componentes especializados que manejan la lógica específica de cada rol académico.

\section{Integración Backend con Symfony}\label{sistema-de-autenticaciuxf3n-y-roles}

La integración backend implementa una arquitectura de servicios REST con Symfony que proporciona autenticación JWT, autorización granular por roles y gestión completa de entidades académicas. Esta implementación garantiza la seguridad y consistencia de datos mediante validaciones y control de acceso.

\subsection{Arquitectura de seguridad Symfony}\label{implementaciuxf3n-backend-con-symfony-security}

El sistema de seguridad se fundamenta en tres componentes principales: autenticación JWT stateless para APIs, jerarquía de roles académicos que define permisos heredados, y control de acceso granular basado en rutas y recursos.

\subsubsection{Configuración de autenticación y autorización}\label{configuraciuxf3n-de-seguridad}

La configuración de seguridad establece una jerarquía de roles donde ROLE\_ADMIN hereda todos los permisos, seguido por ROLE\_PRESIDENTE\_TRIBUNAL, ROLE\_PROFESOR y ROLE\_ESTUDIANTE. Cada endpoint API está protegido según el contexto académico apropiado:

\begin{lstlisting}
role_hierarchy:
    ROLE_ADMIN: [ROLE_PRESIDENTE_TRIBUNAL, ROLE_PROFESOR, ROLE_ESTUDIANTE]
    ROLE_PRESIDENTE_TRIBUNAL: [ROLE_PROFESOR, ROLE_USER]
    ROLE_PROFESOR: [ROLE_ESTUDIANTE, ROLE_USER]

access_control:
    - { path: ^/api/auth, roles: PUBLIC_ACCESS }
    - { path: ^/api/tfgs, roles: [ROLE_ESTUDIANTE, ROLE_ADMIN] }
    - { path: ^/api/tribunales, roles: [ROLE_PRESIDENTE_TRIBUNAL, ROLE_ADMIN] }
\end{lstlisting}

\textbf{Características de seguridad}: Cifrado automático de contraseñas mediante hashing, tokens JWT stateless para escalabilidad, providers de usuario basados en entidades Doctrine, y firewalls diferenciados para desarrollo y producción.

\subsubsection{API de autenticación JWT}\label{controlador-de-autenticaciuxf3n-jwt.}

El controlador de autenticación proporciona endpoints seguros para login, refresh de tokens, obtención de perfil de usuario y logout con invalidación de tokens. Implementa validaciones robustas y manejo de errores consistente.

\subsection{Sistema de autorización por recursos con Voters}

Los Symfony Voters implementan un control de acceso granular que evalúa permisos específicos sobre recursos académicos individuales. Esta arquitectura permite decisiones dinámicas de autorización basadas en el contexto del usuario, el estado del TFG y las relaciones académicas establecidas.

El sistema establece cuatro niveles de permisos fundamentales: visualización (VIEW), edición (EDIT), eliminación (DELETE) y cambio de estado (CHANGE\_STATE). Cada operación se evalúa considerando el rol del usuario y su relación específica con el recurso académico.

\begin{lstlisting}[language=PHP]
class TFGVoter extends Voter
{
    public const VIEW = 'TFG_VIEW';
    public const EDIT = 'TFG_EDIT';
    public const CHANGE_STATE = 'TFG_CHANGE_STATE';

    protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
    {
        $user = $token->getUser();
        if (!$user instanceof User) return false;

        return match($attribute) {
            self::VIEW => $this->canView($subject, $user),
            self::EDIT => $this->canEdit($subject, $user),
            self::CHANGE_STATE => $this->canChangeState($subject, $user),
            default => false,
        };
    }
}
\end{lstlisting}

\textbf{Lógica de autorización por contexto académico}:

\textbf{Estudiantes}: Acceden exclusivamente a sus TFGs propios, con permisos de edición limitados al estado "borrador". Esta restricción garantiza que no puedan modificar trabajos una vez enviados para revisión.

\textbf{Tutores}: Supervisan TFGs asignados bajo su dirección, incluyendo permisos para cambios de estado desde "borrador" a "en revisión" o "aprobado", facilitando el flujo de evaluación académica.

\textbf{Miembros de tribunal}: Acceden a TFGs programados para defensa, permitiendo la preparación y evaluación durante el proceso de tribunal.

\textbf{Administradores}: Mantienen acceso completo para gestión del sistema y resolución de incidencias académicas.

\begin{lstlisting}[language=PHP]
private function canView(TFG $tfg, User $user): bool
{
    if (in_array('ROLE_ADMIN', $user->getRoles())) return true;

    if ($tfg->getEstudiante() === $user) return true;

    if ($tfg->getTutor() === $user || $tfg->getCotutor() === $user) return true;

    // Miembros del tribunal acceden a TFGs para defensa
    if ($this->isUserInTribunal($user, $tfg->getDefensa()?->getTribunal())) {
        return true;
    }

    return false;
}
\end{lstlisting}

\textbf{Características de seguridad}: El sistema implementa validación automática de tokens JWT, verificación de integridad de sesiones y prevención de escalada de privilegios mediante evaluación estricta de roles académicos.

\section{Gestión de estado con Context API}\label{gestiuxf3n-de-estado-con-context-api}

La gestión de estado global en la plataforma se fundamenta en React Context API, proporcionando una solución centralizada para compartir información entre componentes.

\subsection{Sistema de notificaciones centralizado}\label{notificacionescontext}

El NotificacionesContext gestiona un sistema de notificaciones no intrusivo que mantiene informados a los usuarios sobre eventos relevantes del sistema académico. El sistema implementa diferentes tipos de notificaciones (éxito, error, información, advertencia) con comportamientos automáticos específicos.

\begin{lstlisting}[language=JavaScript]
const notificacionesReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [{
          id: Date.now() + Math.random(),
          createdAt: new Date(),
          leida: false,
          ...action.payload
        }, ...state.notifications]
      };
    case 'MARK_AS_READ':
      return {
        ...state,
        notifications: state.notifications.map(notification =>
          notification.id === action.payload
            ? { ...notification, leida: true } : notification
        )
      };
    // ... otros casos
  }
};
\end{lstlisting}

\textbf{Características funcionales}: Las notificaciones de tipo "success" e "info" se eliminan automáticamente después de 5 segundos, mientras que las de error requieren acción manual del usuario. El sistema calcula automáticamente el contador de notificaciones no leídas y proporciona métodos para marcar como leídas individual o masivamente.

\textbf{Integración con la aplicación}: El hook useNotifications encapsula toda la lógica de interacción, proporcionando una API limpia para componentes que necesitan mostrar feedback al usuario o consultar el estado de notificaciones pendientes.

\section{APIs REST y endpoints}\label{apis-rest-y-endpoints}

La comunicación entre frontend y backend se articula mediante una API REST que estandariza el intercambio de datos académicos, proporcionando un puente robusto entre la interfaz React y la lógica de negocio Symfony. Esta arquitectura garantiza operaciones seguras, predecibles y escalables para toda la gestión de TFGs.

Cada endpoint integra validaciones de seguridad específicas, optimización de rendimiento y serialización controlada para mantener la integridad de los datos académicos.

\subsection{Controlador de gestión de TFGs}\label{tfg-controller-con-api-platform}

El TFGController maneja una API REST completa que se encarga de controlar el ciclo de vida completo de los Trabajos de Fin de Grado, desde la creación inicial hasta la gestión de estados académicos y archivos asociados.

\textbf{Endpoints fundamentales}:
- \textbf{GET /api/tfgs/mis-tfgs}: Recupera TFGs según el rol del usuario autenticado
- \textbf{POST /api/tfgs}: Crea nuevos TFGs con validación de permisos estudiante
- \textbf{PUT /api/tfgs/\{id\}/cambiar-estado}: Gestiona transiciones del workflow académico
- \textbf{POST /api/tfgs/\{id\}/upload}: Maneja subida segura de documentos PDF
- \textbf{GET /api/tfgs/\{id\}/download}: Proporciona descarga controlada de archivos

\begin{lstlisting}[language=PHP]
#[Route('/api/tfgs')]
class TFGController extends AbstractController
{
    #[Route('/mis-tfgs', methods: ['GET'])]
    #[IsGranted('ROLE_USER')]
    public function misTFGs(#[CurrentUser] User $user): JsonResponse
    {
        $tfgs = $this->tfgService->getTFGsByUser($user);
        return $this->json($tfgs, Response::HTTP_OK, [], ['groups' => ['tfg:read']]);
    }

    #[Route('/{id}/cambiar-estado', methods: ['PUT'])]
    #[IsGranted('change_state', subject: 'tfg')]
    public function cambiarEstado(TFG $tfg, Request $request): JsonResponse
    {
        $newState = $request->request->get('estado');
        $tfg = $this->tfgService->changeState($tfg, $newState);
        return $this->json($tfg, Response::HTTP_OK, [], ['groups' => ['tfg:read']]);
    }
}
\end{lstlisting}

\textbf{Características de seguridad}: Autenticación JWT obligatoria para todos los endpoints, autorización granular mediante Voters para operaciones específicas, validación exhaustiva de datos de entrada y serialización controlada con grupos para proteger información sensible.

\subsection{Capa de servicios académicos}\label{capa-de-servicios---tfgservice}

El TFGService encapsula la lógica de negocio académica, implementando las reglas específicas del flujo de TFGs y coordinando las interacciones entre entidades del dominio universitario.

\textbf{Gestión de estados académicos}: El sistema implementa un flujo de estados rígido que refleja el proceso académico real: borrador → revisión → aprobado → defendido. Cada transición valida permisos específicos y registra eventos para trazabilidad del proceso.

\textbf{Validaciones académicas}: Los TFGs requieren un título mínimo de 10 caracteres, asignación obligatoria de tutor con rol ROLE\_PROFESOR, y restricción de un único TFG activo por estudiante para mantener la coherencia académica.

\begin{lstlisting}[language=PHP]
class TFGService
{
    private const STATE_TRANSITIONS = [
        'borrador' => ['revision'],
        'revision' => ['borrador', 'aprobado'],
        'aprobado' => ['defendido'],
        'defendido' => []
    ];

    public function changeState(TFG $tfg, string $newState, string $comment = ''): TFG
    {
        $currentState = $tfg->getEstado();
        $allowedTransitions = self::STATE_TRANSITIONS[$currentState] ?? [];

        if (!in_array($newState, $allowedTransitions)) {
            throw new \RuntimeException(
                "No se puede cambiar de '{$currentState}' a '{$newState}'"
            );
        }

        $tfg->setEstado($newState);
        $this->entityManager->flush();

        // Dispara eventos para notificaciones automáticas
        $this->eventDispatcher->dispatch(new TFGStateChangedEvent($tfg));
        return $tfg;
    }
}
\end{lstlisting}

\textbf{Sistema de eventos}: Cada operación crítica (creación de TFG, cambios de estado) dispara eventos que activan notificaciones automáticas, manteniendo informados a todos los participantes del proceso académico sin acoplamiento directo entre servicios.

\section{Sistema de archivos y subida de documentos}\label{sistema-de-archivos-y-subida-de-documentos}

La gestión de documentos académicos constituye un componente crítico que debe garantizar seguridad, integridad y accesibilidad de los archivos TFG. 

\subsection{Servicio de gestión segura de archivos}\label{fileuploadservice}

El FileUploadService encapsula toda la lógica de manejo de documentos TFG, implementando un flujo completo desde la recepción hasta el almacenamiento final con todas las validaciones y controles de seguridad necesarios.

\textbf{Validaciones de seguridad implementadas}:
- \textbf{Restricciones de formato}: Únicamente archivos PDF para garantizar compatibilidad académica
- \textbf{Control de tamaño}: Límite máximo de 50MB para evitar saturación del servidor
- \textbf{Verificación MIME}: Validación del tipo de contenido real más allá de la extensión
- \textbf{Integridad de archivos}: Verificación de que los archivos no estén corruptos

\begin{lstlisting}[language=PHP]
class FileUploadService
{
    private const MAX_FILE_SIZE = 52428800; // 50MB
    private const ALLOWED_MIME_TYPES = ['application/pdf'];

    public function uploadTFGFile(TFG $tfg, UploadedFile $file): array
    {
        $this->validateFile($file);
        $fileName = $this->generateUniqueFileName($file);

        // Gestión automática de archivos anteriores
        if ($tfg->getArchivoPath()) {
            $this->removeOldFile($tfg->getArchivoPath());
        }

        $file->move($this->getUploadPath(), $fileName);
        $this->updateTFGMetadata($tfg, $file, $fileName);

        return $this->buildResponseData($file, $fileName);
    }
}
\end{lstlisting}

\textbf{Gestión de metadatos}: El sistema almacena automáticamente información completa de cada archivo: nombre original del estudiante, tamaño, tipo MIME, marcas de tiempo de creación y modificación, y rutas de almacenamiento. Esta información facilita auditorías y gestión administrativa.

\textbf{Estrategias de almacenamiento}: Los archivos se organizan en una estructura jerárquica por fecha que facilita la gestión, utilizando nombres únicos generados automáticamente para evitar colisiones y preservar la privacidad de los documentos. El sistema incluye limpieza automática de archivos obsoletos cuando los estudiantes actualizan sus TFGs.

\textbf{Seguridad y acceso controlado}: Todas las operaciones de descarga verifican permisos mediante Voters antes de proporcionar acceso a los archivos, asegurando que estudiantes, tutores y miembros de tribunal accedan únicamente a documentos autorizados según su rol académico.

\section{Sistema de notificaciones}\label{sistema-de-notificaciones}

El sistema de notificaciones constituye un componente esencial que mantiene a todos los actores académicos informados sobre eventos relevantes relacionados con el progreso de los TFG. Esta funcionalidad resulta fundamental para garantizar una comunicación efectiva entre estudiantes, profesores y administradores, asegurando que cada usuario reciba información oportuna sobre cambios de estado, nuevas asignaciones y fechas críticas del proceso académico.

La arquitectura de notificaciones opera en múltiples dimensiones temporales: notificaciones en tiempo real para eventos inmediatos y notificaciones persistentes para seguimiento histórico.
\subsection{Servicio de notificaciones centralizado}\label{notificationservice}

El NotificationService proporciona un sistema unificado para gestionar notificaciones internas de la aplicación y comunicación por email, manteniendo a todos los usuarios informados sobre eventos relevantes del flujo académico de TFG.

\textbf{Tipos de eventos gestionados}:
- \textbf{Asignación de TFGs}: Notifica a tutores sobre nuevos TFGs asignados
- \textbf{Cambios de estado}: Informa sobre transiciones del workflow académico
- \textbf{Programación de defensas}: Coordina comunicación entre tribunal y estudiante
- \textbf{Notificaciones de seguimiento}: Mantiene histórico para auditoría

\begin{lstlisting}
class NotificationService
{
    public function __construct(
        private EntityManagerInterface $entityManager,
        private MailerInterface $mailer,
        private Environment $twig,
        private string $fromEmail = 'noreply@tfg-platform.com'
    ) {}

    public function notifyTutorOfNewTFG(TFG $tfg): void
    {
        $this->createNotification(
            user: $tfg->getTutor(),
            tipo: 'info',
            titulo: 'Nuevo TFG asignado',
            mensaje: "Se te ha asignado un nuevo TFG: \"{$tfg->getTitulo()}\"",
            metadata: ['tfg_id' => $tfg->getId()]
        );

        $this->sendEmail(
            to: $tfg->getTutor()->getEmail(),
            subject: 'Nuevo TFG Asignado',
            template: 'emails/tfg_asignado.html.twig',
            context: ['tutor' => $tfg->getTutor(), 'tfg' => $tfg]
        );
    }

    public function notifyDefensaProgramada(TFG $tfg, Defensa $defensa): void
    {
        // Notificar a estudiante y miembros del tribunal
        $this->notifyAllParticipants($tfg, $defensa);
        $this->sendDefenseEmails($tfg, $defensa);
    }
}
\end{lstlisting}

\textbf{Arquitectura del sistema}: Integración con eventos de dominio para activación automática, soporte para múltiples canales (in-app y email), templates Twig para emails personalizados y persistencia de notificaciones para seguimiento histórico.

\chapter{Entrega del producto}\label{entrega-del-producto}

Al utilizar un modelo de ciclo de vida iterativo incremental, al final de cada iteración se obtuvieron productos entregables específicos. Sin embargo, este capítulo se centra en los productos entregables finales tras completar las siete fases de desarrollo, ya que representan el final de todas las mejoras y correcciones aplicadas durante el proceso de desarollo del proyecto.

\section{Productos entregables del sistema}\label{productos-entregables-del-sistema}

Los productos entregables de la plataforma de gestión de TFG se organizan en componentes técnicos, documentación y recursos de despliegue que permiten la implementación completa del sistema en entornos académicos reales.

\subsection{Aplicación frontend React}\label{aplicacion-frontend-react}

\textbf{Archivo comprimido (.zip)}: Contiene la aplicación React completa lista para despliegue, incluyendo todos los componentes, páginas, hooks personalizados y configuraciones optimizadas para producción. La aplicación implementa un sistema completo de roles académicos (estudiante, profesor, presidente de tribunal, administrador) con interfaces específicas para cada tipo de usuario.

\subsection{Backend API Symfony}\label{backend-api-symfony}

\textbf{Archivo comprimido (.zip)}: Backend Symfony 6.4 completamente funcional que proporciona todas las APIs REST necesarias para la gestión académica de TFG. Incluye sistema de autenticación JWT, gestión de roles granular, y capacidades de upload/download de documentos PDF.

\subsection{Base de datos y configuración}\label{base-de-datos-y-configuracion}

\textbf{Scripts de base de datos (.sql)}: Migraciones Doctrine completas que establecen el esquema de base de datos MySQL con todas las entidades necesarias: usuarios, TFG, tribunales, defensas, calificaciones, notificaciones y comentarios. Incluye fixtures de datos de prueba para facilitar la evaluación del sistema.

\textbf{Archivos de configuración (.env)}: Variables de entorno documentadas para diferentes entornos (desarrollo, testing, producción) con configuraciones seguras de JWT, CORS, base de datos y servicios de notificación.

\subsection{Documentación técnica completa}\label{documentacion-tecnica-completa}

\textbf{Documentación de desarrollo}: El presente documento que sirve como memoria completa del desarrollo, incluyendo análisis de requisitos, diseño del sistema, decisiones arquitectónicas y proceso de implementación. Documenta tanto la metodología iterativa aplicada como las soluciones técnicas implementadas.

\subsection{Recursos de evaluación y testing}\label{recursos-de-evaluacion-y-testing}

\textbf{Suite de tests automatizados}: El sistema incluye tests unitarios y funcionales tanto para frontend como backend. Los tests validan todas las funcionalidades críticas del sistema académico.

\textbf{Datos de prueba}: Conjunto completo de usuarios, TFG, tribunales y defensas de prueba que permiten evaluar inmediatamente todas las funcionalidades del sistema sin necesidad de crear datos desde cero.

\textbf{Credenciales de acceso para evaluación}:
- Estudiante: \texttt{estudiante@uni.es / 123456}
- Profesor: \texttt{profesor@uni.es / 123456}
- Presidente: \texttt{presidente@uni.es / 123456}
- Administrador: \texttt{admin@uni.es / 123456}

\chapter{Procesos de soporte y
pruebas}\label{procesos-de-soporte-y-pruebas}

Este capítulo documenta los procesos fundamentales de soporte y pruebas que garantizan la calidad, mantenibilidad y evolución sostenible del sistema desarrollado. La documentación abarca los aspectos técnicosy de la metodología que sustentan la operación exitosa de la plataforma, incluyendo la gestión de decisiones técnicas, estrategias de testing y procedimientos de verificación y validación.

\section{Gestión y toma de
decisiones}\label{gestiuxf3n-y-toma-de-decisiones}

El desarrollo de cualquier plataforma software requiere una gestión sistemática de las decisiones técnicas y arquitectónicas que determinan el éxito a largo plazo del proyecto.

Cuando se desarrolla una plataforma de software, es importante gestionar bien las decisiones técnicas y de arquitectura, ya que de ellas depende en gran parte el éxito del proyecto a largo plazo. Tener una forma clara y coherente de decidir, dejar constancia del proceso seguido, anotar las alternativas descartadas y los motivos de la elección final ayuda mucho a aprender de los errores, poder dar marcha atrás si hace falta y evitar conflictos. En mi caso, como este proyecto lo he llevado a cabo de manera individual, la mayoría de las decisiones también las he tomado yo solo, aunque intentando aplicar esos mismos principios de consistencia y reflexión.

\subsection{Metodología de gestión del
proyecto}\label{metodologuxeda-de-gestiuxf3n-del-proyecto}

La metodología empleada combina principios de las metodologías ágiles con las particularidades propias del entorno académico. El objetivo ha sido crear un marco de trabajo que permita cierta flexibilidad en la toma de decisiones, sin perder el rigor técnico necesario en este tipo de proyectos. Esta adaptación facilita responder a posibles cambios en los requisitos y, al mismo tiempo, mantener la calidad y la documentación que se espera en un contexto universitario.

\subsubsection{Estructura de toma de
decisiones}\label{estructura-de-toma-de-decisiones}

\textbf{Niveles de decisión implementados}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Decisiones arquitectónicas}: Selección de tecnologías
  principales (React 19, Symfony 6.4, MySQL 8.0).
\item
  \textbf{Decisiones de diseño}: Patrones de implementación, estructura
  de componentes, APIs REST.
\item
  \textbf{Decisiones operacionales}: Configuración de desarrollo,
  herramientas, flujos de trabajo.
\end{enumerate}

\textbf{Proceso de evaluación de decisiones}: La metodología implementada sigue cuatro fases diferenciadas que garantizan decisiones técnicas fundamentadas. El análisis inicial de requisitos evalúa las necesidades técnicas específicas y requisitos funcionales que debe satisfacer cada decisión arquitectónica. La investigación posterior compara rigurosamente las alternativas disponibles, evaluando ventajas, desventajas y costos de implementación a largo plazo.

\subsection{Control de versiones y
cambios}\label{control-de-versiones-y-cambios}

\subsubsection{Estrategia de branching}\label{estrategia-de-branching}

\begin{lstlisting}[language=bash]
## Estructura de ramas (branches) en Git
main                    # Producción estable
├── develop            # Integración de funcionalidades
├── feature/auth       # Funcionalidad específica
├── feature/tfg-crud   # Funcionalidad específica
├── hotfix/security    # Correcciones críticas
└── release/v1.0       # Preparación de release
\end{lstlisting}

\textbf{Flujo de trabajo implementado}: El desarrollo sigue un workflow estructurado basado en ramas de funcionalidades que garantizan aislamiento completo de funcionalidades, evitando conflictos y permitiendo trabajo paralelo eficiente. Los pull requests funcionan como barreras de calidad obligatorias antes de cualquier integración, incorporando validación automática de tests, análisis estático de código y revisión manual que mantiene los estándares de calidad establecidos.

\section{Gestión de riesgos}\label{gestiuxf3n-de-riesgos}

Todo proyecto de desarrollo software enfrenta riesgos potenciales que pueden comprometer su éxito. La identificación temprana y gestión proactiva de estos riesgos resulta fundamental para garantizar la entrega exitosa de la plataforma. Este análisis sistemático permite anticipar problemas, desarrollar estrategias de mitigación y mantener planes de contingencia actualizados.

\subsection{Análisis de riesgos}\label{anuxe1lisis-de-riesgos}

\subsubsection{Matriz de riesgos
identificados}\label{matriz-de-riesgos-identificados}

En la siguiente Tabla podemos ver una enumeración de los riesgos analizados, así como la
probabilidad de que sucedan y el impacto que tendrían en el desarrollo del proyecto.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.1000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.5000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}
  >{\raggedright\arraybackslash}p{(\linewidth - 6\tabcolsep) * \real{0.2000}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Riesgo
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Probabilidad
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Impacto
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
R001 & Incompatibilidad entre React 19 y librerías existentes & Media &
Alto \\
R002 & Problemas de rendimiento con archivos PDF grandes & Alta & Medio \\
R003 & Vulnerabilidades de seguridad en JWT implementation & Baja & Alto \\
R004 & Pérdida de datos durante migración a producción & Baja & Crítico \\
R005 & Sobrecarga del sistema durante picos de uso (defensas) & Media &
Medio \\
R006 & Dependencias obsoletas o con vulnerabilidades & Alta & Bajo \\
\end{longtable}

\subsection{Plan de contingencia}\label{plan-de-contingencia}

\subsubsection{Escenarios de
contingencia}\label{escenarios-de-contingencia}

\textbf{Escenario 1: Fallo crítico en producción}

Ante un fallo crítico que comprometa la disponibilidad del sistema, se activa un protocolo de restauración de emergencia que prioriza el restablecimiento rápido del servicio. El procedimiento automatizado detiene los servicios afectados, identifica la copia de seguridad más reciente y restaura tanto la base de datos como las aplicaciones frontend y backend a su estado funcional anterior.

La secuencia incluye parada controlada de servicios Docker, restauración de la base de datos MySQL desde la copia de seguridad más reciente, revertir las imágenes de contenedores a versiones anteriores estables, y reinicio completo de todos los servicios. Este proceso garantiza que el sistema vuelva a estar operativo en el menor tiempo posible, minimizando el impacto en los usuarios académicos durante períodos críticos como fechas de entrega o defensas.

\textbf{Escenario 2: Sobrecarga del sistema}: Cuando el sistema detecta sobrecarga crítica (CPU > 90\% durante 5+ minutos), se activan automáticamente medidas de protección. El plan incluye activar caché en Redis para reducir consultas a base de datos, limitar subidas de archivos para aliviar el procesamiento, y alertar al equipo técnico si es necesario.

\textbf{Escenario 3: Vulnerabilidad de seguridad crítica}: Ante vulnerabilidades críticas, el plan prioriza protección inmediata de datos académicos. Se desarrolla un parche de emergencia en rama de hotfix, se valida rápidamente, y se despliega con comunicación transparente a usuarios. Posteriormente se realiza auditoría del incidente para mejorar los procesos de seguridad.

\section{Verificación y validación del
software}\label{verificaciuxf3n-y-validaciuxf3n-del-software}

La verificación y validación constituyen el núcleo de los procesos de calidad, complementando la gestión de decisiones técnicas con metodologías que aseguran el cumplimiento de requisitos y el funcionamiento correcto bajo diversas condiciones de uso. Estos procesos generan confianza tanto en desarrolladores como en usuarios finales sobre la robustez del sistema.

La estrategia implementada despliega múltiples niveles de testing: desde pruebas unitarias granulares hasta pruebas de integración completas del sistema. Esta aproximación garantiza que cada componente funcione correctamente de manera aislada y que las interacciones entre componentes produzcan los resultados esperados en el contexto global.

\subsection{Testing del frontend}\label{testing-del-frontend}

El testing del frontend implementado utiliza Vitest y React Testing Library para garantizar la calidad y funcionalidad de los componentes React. Los tests se dividen en tres categorías principales:

\subsubsection{Testing unitario con
Vitest}\label{testing-unitario-con-vitest}

\begin{lstlisting}
// src/components/__tests__/Button.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import Button from '../ui/Button';

describe('Button Component', () => {
  it('renders correctly with default props', () => {
    render(<Button>Click me</Button>);
    
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toBeInTheDocument();
    expect(button).toHaveClass('bg-blue-600');
  });

  it('handles click events', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('shows loading state correctly', () => {
    render(<Button loading>Loading...</Button>);
    
    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  it('applies variant styles correctly', () => {
    render(<Button variant="danger">Delete</Button>);
    
    const button = screen.getByRole('button');
    expect(button).toHaveClass('bg-red-600');
  });
});
\end{lstlisting}

\textbf{Testing unitario de componentes:} Verifica que los componentes individuales como el componente Button funcionen correctamente. Los resultados obtenidos confirman que:
\begin{itemize}
\item El componente se renderiza correctamente con el texto "Click me" y aplica la clase CSS \texttt{bg-blue-600} por defecto.
\item Los eventos de click se manejan apropiadamente, ejecutando la función handleClick exactamente una vez.
\item El estado de loading funciona correctamente, deshabilitando el botón y mostrando el spinner visual.
\item Las variantes de estilo se aplican correctamente, como la variante "danger" que aplica la clase \texttt{bg-red-600}.
\end{itemize}

\subsubsection{Testing de hooks
personalizados}\label{testing-de-hooks-personalizados}

\begin{lstlisting}
// src/hooks/__tests__/useTFGs.test.js
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useTFGs } from '../useTFGs';
import { tfgService } from '../../services/tfgService';

// Mock del servicio
vi.mock('../../services/tfgService');

describe('useTFGs Hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should fetch TFGs on mount', async () => {
    const mockTFGs = [
      { id: 1, titulo: 'Test TFG 1', estado: 'borrador' },
      { id: 2, titulo: 'Test TFG 2', estado: 'revision' }
    ];

    tfgService.getMisTFGs.mockResolvedValue(mockTFGs);

    const { result } = renderHook(() => useTFGs());

    await act(async () => {
      await result.current.fetchTFGs();
    });

    expect(result.current.tfgs).toEqual(mockTFGs);
    expect(result.current.loading).toBe(false);
  });

  it('should handle createTFG correctly', async () => {
    const newTFG = { id: 3, titulo: 'New TFG', estado: 'borrador' };
    tfgService.createTFG.mockResolvedValue(newTFG);

    const { result } = renderHook(() => useTFGs());

    await act(async () => {
      await result.current.createTFG({
        titulo: 'New TFG',
        descripcion: 'Test description'
      });
    });

    expect(result.current.tfgs).toContain(newTFG);
  });

  it('should handle errors gracefully', async () => {
    const error = new Error('Network error');
    tfgService.getMisTFGs.mockRejectedValue(error);

    const { result } = renderHook(() => useTFGs());

    await act(async () => {
      await result.current.fetchTFGs();
    });

    expect(result.current.error).toBe('Network error');
    expect(result.current.loading).toBe(false);
  });
});
\end{lstlisting}

\textbf{Testing de hooks personalizados:} El hook \texttt{useTFGs} maneja la lógica de negocio para la gestión de TFGs. Los tests verifican que:
\begin{itemize}
\item La función \texttt{fetchTFGs()} carga exitosamente dos TFGs de prueba y establece el estado loading a false.
\item La función \texttt{createTFƒG()} añade correctamente un nuevo TFG a la lista existente.
\item Los errores de red se manejan de forma elegante sin provocar fallos en la aplicación.
\end{itemize}

\subsubsection{Testing de integración con React Testing
Library}\label{testing-de-integraciuxf3n-con-react-testing-library}

\begin{lstlisting}
// src/pages/__tests__/Dashboard.integration.test.jsx
import { render, screen, waitFor } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import Dashboard from '../dashboard/Dashboard';
import { AuthProvider } from '../../context/AuthContext';
import { NotificacionesProvider } from '../../context/NotificacionesContext';

const renderWithProviders = (component, { initialEntries = ['/'] } = {}) => {
  return render(
    <MemoryRouter initialEntries={initialEntries}>
      <AuthProvider>
        <NotificacionesProvider>
          {component}
        </NotificacionesProvider>
      </AuthProvider>
    </MemoryRouter>
  );
};

describe('Dashboard Integration', () => {
  beforeEach(() => {
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: vi.fn(() => JSON.stringify({
          id: 1,
          nombre: 'Juan',
          apellidos: 'Pérez',
          roles: ['ROLE_ESTUDIANTE']
        })),
        setItem: vi.fn(),
        removeItem: vi.fn()
      },
      writable: true
    });
  });

  it('should render student dashboard correctly', async () => {
    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByText('Bienvenido, Juan Pérez')).toBeInTheDocument();
    });

    expect(screen.getByText('Gestiona tu Trabajo de Fin de Grado')).toBeInTheDocument();
  });

  it('should display notifications if present', async () => {
    // Mock notifications
    vi.mock('../../context/NotificacionesContext', () => ({
      useNotifications: () => ({
        notifications: [
          { id: 1, titulo: 'Test notification', leida: false }
        ]
      })
    }));

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByText('Notificaciones pendientes (1)')).toBeInTheDocument();
    });
  });
});
\end{lstlisting}

\textbf{Testing de integración:} Las pruebas del Dashboard verifican la integración completa con los proveedores de contexto. Los resultados muestran que:
\begin{itemize}
\item El dashboard muestra correctamente "Bienvenido, Juan Pérez" para usuarios con rol de estudiante.
\item El mensaje "Gestiona tu Trabajo de Fin de Grado" se visualiza apropiadamente.
\item El sistema de notificaciones se integra correctamente, mostrando "Notificaciones pendientes (1)" cuando hay notificaciones disponibles.
\end{itemize}

\subsection{Testing del backend}\label{testing-del-backend}

El testing del backend utiliza PHPUnit para verificar tanto la lógica de negocio como la funcionalidad de los endpoints de la API REST. Los tests se organizan en dos niveles principales:

\subsubsection{Testing unitario con
PHPUnit}\label{testing-unitario-con-phpunit}

\begin{lstlisting}[language=PHP]
<?php
// tests/Unit/Entity/TFGTest.php
namespace App\Tests\Unit\Entity;

use App\Entity\TFG;
use App\Entity\User;
use PHPUnit\Framework\TestCase;

class TFGTest extends TestCase
{
    private TFG $tfg;
    private User $estudiante;
    private User $tutor;

    protected function setUp(): void
    {
        $this->estudiante = new User();
        $this->estudiante->setEmail('estudiante@test.com')
                        ->setRoles(['ROLE_ESTUDIANTE']);

        $this->tutor = new User();
        $this->tutor->setEmail('tutor@test.com')
                   ->setRoles(['ROLE_PROFESOR']);

        $this->tfg = new TFG();
        $this->tfg->setTitulo('Test TFG')
                  ->setEstudiante($this->estudiante)
                  ->setTutor($this->tutor)
                  ->setEstado('borrador');
    }

    public function testCanChangeStateFromBorradorToRevision(): void
    {
        $this->assertTrue($this->tfg->canTransitionTo('revision'));
        
        $this->tfg->changeState('revision', $this->tutor);
        
        $this->assertEquals('revision', $this->tfg->getEstado());
    }

    public function testCannotChangeFromBorradorToDefendido(): void
    {
        $this->assertFalse($this->tfg->canTransitionTo('defendido'));
        
        $this->expectException(\RuntimeException::class);
        $this->tfg->changeState('defendido', $this->tutor);
    }

    public function testEstudianteCanEditOnlyInBorradorState(): void
    {
        // Estado borrador - puede editar
        $this->assertTrue($this->tfg->userCanEdit($this->estudiante));
        
        // Cambiar a revision - no puede editar
        $this->tfg->changeState('revision', $this->tutor);
        $this->assertFalse($this->tfg->userCanEdit($this->estudiante));
    }

    public function testTutorCanAlwaysEditAssignedTFG(): void
    {
        $this->assertTrue($this->tfg->userCanEdit($this->tutor));
        
        $this->tfg->changeState('revision', $this->tutor);
        $this->assertTrue($this->tfg->userCanEdit($this->tutor));
    }
}
\end{lstlisting}

\textbf{Testing unitario de entidades:} Verifica la lógica de negocio de las entidades principales como TFG. Los resultados obtenidos confirman que:
\begin{itemize}
\item Las transiciones de estado funcionan correctamente: TFG puede cambiar de "borrador" a "revisión" sin errores.
\item Las validaciones de transición están implementadas: TFG NO puede cambiar directamente de "borrador" a "defendido", lanzando RuntimeException como se esperaba.
\item Los permisos de edición por rol funcionan apropiadamente: estudiantes solo pueden editar TFGs en estado "borrador", mientras que profesores pueden editar TFGs asignados independientemente del estado.
\end{itemize}

\subsubsection{Testing de servicios}\label{testing-de-servicios}

\begin{lstlisting}[language=PHP]
<?php
// tests/Unit/Service/TFGServiceTest.php
namespace App\Tests\Unit\Service;

use App\Entity\TFG;
use App\Entity\User;
use App\Repository\TFGRepository;
use App\Repository\UserRepository;
use App\Service\TFGService;
use App\Service\NotificationService;
use Doctrine\ORM\EntityManagerInterface;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\MockObject\MockObject;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class TFGServiceTest extends TestCase
{
    private TFGService $tfgService;
    private MockObject $entityManager;
    private MockObject $tfgRepository;
    private MockObject $userRepository;
    private MockObject $notificationService;
    private MockObject $eventDispatcher;

    protected function setUp(): void
    {
        $this->entityManager = $this->createMock(EntityManagerInterface::class);
        $this->tfgRepository = $this->createMock(TFGRepository::class);
        $this->userRepository = $this->createMock(UserRepository::class);
        $this->notificationService = $this->createMock(NotificationService::class);
        $this->eventDispatcher = $this->createMock(EventDispatcherInterface::class);

        $this->tfgService = new TFGService(
            $this->entityManager,
            $this->tfgRepository,
            $this->userRepository,
            $this->eventDispatcher,
            $this->notificationService
        );
    }

    public function testCreateTFGSuccessfully(): void
    {
        $estudiante = new User();
        $estudiante->setEmail('student@test.com')->setRoles(['ROLE_ESTUDIANTE']);

        $tutor = new User();
        $tutor->setEmail('tutor@test.com')->setRoles(['ROLE_PROFESOR']);

        $data = [
            'titulo' => 'Test TFG',
            'descripcion' => 'Test description',
            'tutor_id' => 1
        ];

        // Mocks
        $this->tfgRepository->expects($this->once())
                           ->method('findActiveByStudent')
                           ->with($estudiante)
                           ->willReturn(null);

        $this->userRepository->expects($this->once())
                           ->method('find')
                           ->with(1)
                           ->willReturn($tutor);

        $this->entityManager->expects($this->once())->method('persist');
        $this->entityManager->expects($this->once())->method('flush');

        $this->eventDispatcher->expects($this->once())->method('dispatch');

        // Test
        $result = $this->tfgService->createTFG($data, $estudiante);

        $this->assertInstanceOf(TFG::class, $result);
        $this->assertEquals('Test TFG', $result->getTitulo());
        $this->assertEquals('borrador', $result->getEstado());
        $this->assertEquals($estudiante, $result->getEstudiante());
        $this->assertEquals($tutor, $result->getTutor());
    }

    public function testCreateTFGFailsWhenStudentHasActiveTFG(): void
    {
        $estudiante = new User();
        $existingTFG = new TFG();

        $this->tfgRepository->expects($this->once())
                           ->method('findActiveByStudent')
                           ->with($estudiante)
                           ->willReturn($existingTFG);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('Ya tienes un TFG activo');

        $this->tfgService->createTFG([], $estudiante);
    }

    public function testChangeStateValidatesTransitions(): void
    {
        $tfg = new TFG();
        $tfg->setEstado('borrador');

        // Valid transition
        $result = $this->tfgService->changeState($tfg, 'revision');
        $this->assertEquals('revision', $result->getEstado());

        // Invalid transition
        $this->expectException(\RuntimeException::class);
        $this->tfgService->changeState($tfg, 'defendido');
    }
}
\end{lstlisting}

\textbf{Testing de servicios}: Verifica la lógica de negocio implementada en el TFGService que gestiona las operaciones principales de los Trabajos de Fin de Grado. Los resultados obtenidos confirman que:
\begin{itemize}
\item La creación de TFGs funciona correctamente: se asigna automáticamente el estado "borrador", se vincula al estudiante y tutor apropiado, y se persiste en base de datos.
\item Las validaciones de negocio están implementadas: estudiantes no pueden crear múltiples TFGs activos simultáneamente, lanzando RuntimeException "Ya tienes un TFG activo" como se esperaba.
\item Las transiciones de estado respetan las reglas académicas: TFG puede cambiar de "borrador" a "revisión" exitosamente, pero no permite transiciones inválidas como "borrador" a "defendido" directamente.
\item Los eventos de dominio se disparan correctamente: cada operación crítica notifica al sistema para activar procesos automáticos como notificaciones y auditoría.
\end{itemize}

\subsection{Testing de APIs REST}\label{testing-de-apis-rest}

\subsubsection{Testing funcional de
endpoints}\label{testing-funcional-de-endpoints}

\begin{lstlisting}[language=PHP]
<?php
// tests/Functional/Controller/TFGControllerTest.php
namespace App\Tests\Functional\Controller;

use App\Entity\User;
use App\Entity\TFG;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\File\UploadedFile;

class TFGControllerTest extends WebTestCase
{
    private $client;
    private User $estudiante;
    private User $tutor;

    protected function setUp(): void
    {
        $this->client = static::createClient();
        
        // Create test users
        $this->estudiante = new User();
        $this->estudiante->setEmail('estudiante@test.com')
                        ->setPassword('password')
                        ->setRoles(['ROLE_ESTUDIANTE'])
                        ->setNombre('Test')
                        ->setApellidos('Student');

        $this->tutor = new User();
        $this->tutor->setEmail('tutor@test.com')
                   ->setPassword('password')
                   ->setRoles(['ROLE_PROFESOR'])
                   ->setNombre('Test')
                   ->setApellidos('Tutor');

        $entityManager = self::getContainer()->get('doctrine')->getManager();
        $entityManager->persist($this->estudiante);
        $entityManager->persist($this->tutor);
        $entityManager->flush();
    }

    public function testCreateTFGAsEstudiante(): void
    {
        // Authenticate as student
        $token = $this->getAuthToken($this->estudiante);

        $this->client->request('POST', '/api/tfgs', [], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $token,
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'titulo' => 'Test TFG Creation',
            'descripcion' => 'Test description',
            'tutor_id' => $this->tutor->getId()
        ]));

        $this->assertResponseStatusCodeSame(201);
        
        $response = json_decode($this->client->getResponse()->getContent(), true);
        $this->assertEquals('Test TFG Creation', $response['titulo']);
        $this->assertEquals('borrador', $response['estado']);
    }

    public function testUploadFileToTFG(): void
    {
        // Create a TFG first
        $tfg = new TFG();
        $tfg->setTitulo('Test TFG for Upload')
             ->setEstudiante($this->estudiante)
             ->setTutor($this->tutor)
             ->setEstado('borrador');

        $entityManager = self::getContainer()->get('doctrine')->getManager();
        $entityManager->persist($tfg);
        $entityManager->flush();

        // Create a test PDF file
        $tempFile = tmpfile();
        fwrite($tempFile, '%PDF test content');
        $tempPath = stream_get_meta_data($tempFile)['uri'];

        $uploadedFile = new UploadedFile(
            $tempPath,
            'test.pdf',
            'application/pdf',
            null,
            true // test mode
        );

        $token = $this->getAuthToken($this->estudiante);

        $this->client->request('POST', "/api/tfgs/{$tfg->getId()}/upload", [
            'archivo' => $uploadedFile
        ], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $token,
        ]);

        $this->assertResponseStatusCodeSame(200);
        
        $response = json_decode($this->client->getResponse()->getContent(), true);
        $this->assertEquals('Archivo subido exitosamente', $response['message']);
        $this->assertArrayHasKey('archivo', $response);
    }

    public function testChangeStateRequiresProperRole(): void
    {
        $tfg = new TFG();
        $tfg->setTitulo('Test TFG for State Change')
             ->setEstudiante($this->estudiante)
             ->setTutor($this->tutor)
             ->setEstado('borrador');

        $entityManager = self::getContainer()->get('doctrine')->getManager();
        $entityManager->persist($tfg);
        $entityManager->flush();

        // Try as student (should fail)
        $studentToken = $this->getAuthToken($this->estudiante);
        
        $this->client->request('PUT', "/api/tfgs/{$tfg->getId()}/estado", [], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $studentToken,
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'estado' => 'revision',
            'comentario' => 'Ready for review'
        ]));

        $this->assertResponseStatusCodeSame(403);

        // Try as tutor (should succeed)
        $tutorToken = $this->getAuthToken($this->tutor);
        
        $this->client->request('PUT', "/api/tfgs/{$tfg->getId()}/estado", [], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $tutorToken,
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'estado' => 'revision',
            'comentario' => 'Ready for review'
        ]));

        $this->assertResponseStatusCodeSame(200);
    }

    private function getAuthToken(User $user): string
    {
        $this->client->request('POST', '/api/auth/login', [], [], [
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'email' => $user->getEmail(),
            'password' => 'password'
        ]));

        $response = json_decode($this->client->getResponse()->getContent(), true);
        return $response['token'];
    }
}
\end{lstlisting}

\textbf{Testing funcional de endpoints:} Prueba la funcionalidad completa de los endpoints de la API REST con autenticación JWT. Los resultados muestran que:
\begin{itemize}
\item \texttt{testCreateTFGAsEstudiante()}: Estudiantes pueden crear TFGs exitosamente (HTTP 201), con título "Test TFG Creation" y estado inicial "borrador".
\item \texttt{testUploadFileToTFG()}: El sistema de subida de archivos PDF funciona correctamente (HTTP 200), retornando mensaje "Archivo subido exitosamente" y campo 'archivo' en la respuesta.
\item \texttt{testChangeStateRequiresProperRole()}: La autorización por roles funciona apropiadamente - estudiantes reciben HTTP 403 al intentar cambiar estados, mientras que tutores pueden hacerlo exitosamente (HTTP 200).
\item La autenticación JWT se integra correctamente con el sistema de permisos, validando tokens y roles antes de permitir operaciones.
\end{itemize}

\subsection{Testing de seguridad}\label{testing-de-seguridad}

El testing de seguridad implementa una estrategia integral de evaluación de vulnerabilidades que combina escaneo automatizado con verificación manual de amenazas específicas. Los tests se organizan en dos niveles complementarios:

\subsubsection{Lista de verificación de pruebas de penetración}\label{penetration-testing-checklist}

El sistema ha integrado una batería completa de pruebas automáticas que evalúan los vectores de ataque más comunes en aplicaciones web.

La protección contra \textbf{inyección SQL} se ha implementado mediante el uso exclusivo de consultas parametrizadas a través del ORM Doctrine, eliminando la posibilidad de manipulación directa de consultas SQL por parte de atacantes. Esta aproximación garantiza que todos los datos de entrada sean tratados como parámetros y nunca como código ejecutable.

La \textbf{prevención de ataques XSS} (Cross-Site Scripting) se ha abordado mediante una estrategia dual que combina el escapado automático de contenido proporcionado por React JSX con la implementación de cabeceras de Política de Seguridad de Contenido (CSP) restrictivas, creando múltiples capas de protección contra la ejecución de scripts maliciosos.

La \textbf{protección CSRF} (Cross-Site Request Forgery) se ha implementado mediante una combinación de cookies SameSite y tokens JWT, asegurando que las peticiones maliciosas desde dominios externos no puedan ejecutar acciones en nombre de usuarios auténticos. La \textbf{autenticación} del sistema emplea una implementación segura de JWT con tokens de actualización, proporcionando un equilibrio entre seguridad y experiencia de usuario.

El sistema de \textbf{autorización} utiliza Symfony Voters para implementar permisos granulares, asegurando que cada acción sea evaluada individualmente según el contexto y los roles del usuario. La \textbf{seguridad en la subida de archivos} incluye validación de tipos MIME, límites de tamaño y escaneo de virus, protegiendo contra la subida de contenido malicioso.

Finalmente, el \textbf{forzado de HTTPS} se implementa mediante redirecciones automáticas y cabeceras HSTS (HTTP Strict Transport Security), mientras que la \textbf{validación de entrada} asegura que todos los endpoints del servidor validen rigurosamente los datos recibidos antes de su procesamiento.

\section{Verificación de requisitos no funcionales}\label{verificacion-requisitos-no-funcionales}

En esta sección se explica cómo se han verificado los requisitos no funcionales establecidos en el diseño del sistema, centrándose en los procesos de validación y las herramientas utilizadas para comprobar el cumplimiento de los estándares de calidad.

Las verificaciones llevadas a cabo se han enfocado en aspectos críticos del sistema como rendimiento, seguridad, usabilidad y mantenibilidad, utilizando herramientas específicas y metodologías de testing que proporcionan evidencia objetiva del cumplimiento de los requisitos.

\subsection{Verificación de rendimiento}\label{verificacion-rendimiento}

\textbf{Tiempos de respuesta de la API}: Se han medido los tiempos de respuesta de los endpoints principales utilizando el comando \texttt{curl} con la opción \texttt{-w} para medir tiempos de conexión y respuesta. Las pruebas se realizaron contra el endpoint \texttt{/api/health} del backend Symfony ejecutándose en DDEV, obteniendo medidas consistentes que demuestran respuestas por debajo de 500ms.

\textbf{Rendimiento del frontend}: Se utilizó la herramienta Google Lighthouse integrada en Chrome DevTools para evaluar el rendimiento de las páginas principales de la aplicación React. Las métricas de First Contentful Paint, Largest Contentful Paint y Time to Interactive se midieron en múltiples páginas del sistema, verificando que los tiempos de carga cumplan con los estándares web modernos.

\textbf{Tamaño del bundle}: El comando \texttt{npm run build} de Vite genera estadísticas detalladas del tamaño del bundle final. Se verificó que el bundle JavaScript principal se mantiene por debajo de 1MB mediante el análisis del reporte de build que muestra el tamaño de cada chunk generado.

\subsection{Verificación de seguridad}\label{verificacion-seguridad}

\textbf{Análisis de vulnerabilidades}: Se ejecutaron pruebas de seguridad utilizando \texttt{npm audit} para el frontend y \texttt{composer audit} para el backend, identificando y resolviendo vulnerabilidades en dependencias. Estas herramientas escanean las dependencias instaladas contra bases de datos de vulnerabilidades conocidas.

\textbf{Validación de entrada}: Se realizaron pruebas manuales enviando datos malformados a los endpoints de la API para verificar que las validaciones de Symfony rechacen correctamente inputs inválidos. Se probaron casos como inyección SQL, XSS y subida de archivos maliciosos, confirmando que el sistema maneja apropiadamente estos intentos de ataque.

\textbf{Configuración HTTPS}: Se verificó la correcta configuración de cabeceras de seguridad utilizando herramientas online como SSL Labs y Security Headers, confirmando la implementación de HSTS, CSP y otras cabeceras de seguridad recomendadas.

\subsection{Verificación de calidad de código}\label{verificacion-calidad-codigo}

\textbf{Cobertura de tests}: La cobertura de código se midió utilizando \texttt{npm run test:coverage} para el frontend con Vitest, y \texttt{phpunit --coverage-text} para el backend. Estas herramientas generan reportes detallados que muestran qué líneas de código están cubiertas por tests y cuáles no, permitiendo identificar áreas que requieren más testing.

\textbf{Análisis estático}: Se utilizó ESLint para el frontend y PHPStan para el backend para realizar análisis estático del código. Estas herramientas identifican problemas potenciales, violaciones de estándares de código y posibles errores antes de la ejecución, asegurando calidad y mantenibilidad del código.

\textbf{Cumplimiento de estándares}: Se verificó que el código JavaScript sigue las convenciones de React 19 y que el código PHP cumple con PSR-12, utilizando las configuraciones estándar de las herramientas de linting mencionadas.

\subsection{Verificación de usabilidad}\label{verificacion-usabilidad}

\textbf{Testing con usuarios reales}: Se realizaron pruebas de usabilidad con usuarios representativos de cada rol (estudiante, profesor, administrador) observando su interacción con el sistema durante tareas típicas como subida de TFG, revisión de trabajos y programación de defensas. Los usuarios pudieron completar las tareas sin asistencia, indicando una interfaz intuitiva.

\textbf{Responsividad}: Se utilizó Chrome DevTools para simular diferentes tamaños de pantalla y dispositivos, verificando que la interfaz se adapta correctamente a resoluciones desde móviles (320px) hasta monitores grandes (1920px+). Las pruebas confirmaron que todos los elementos mantienen usabilidad en diferentes dispositivos.

\textbf{Accesibilidad}: Se ejecutaron auditorías de accesibilidad utilizando Lighthouse y extensiones específicas como axe DevTools, verificando el cumplimiento de estándares WCAG 2.1 para garantizar que el sistema sea utilizable por personas con diferentes capacidades.

\chapter{Conclusiones y trabajo
futuro}\label{conclusiones-y-trabajo-futuro}
Este capítulo cierra el recorrido técnico y académico del proyecto con una evaluación del trabajo realizado y una proyección de la evolución futura del sistema desarrollado. Representa la síntesis completa del proceso: desde la concepción inicial hasta la implementación final, ofreciendo una crítica constructiva sobre los logros alcanzados y los desafíos que aún permanecen abiertos.

\section{Valoración del proyecto}\label{valoraciuxf3n-del-proyecto}

La idea de este proyecto nació con la intención de modernizar y digitalizar la gestión de Trabajos de Fin de Grado, un proceso tradicionalmente manual y fragmentado que generaba ineficiencias tanto para estudiantes como para profesores y administradores académicos.

La necesidad de una herramienta que unificara todo el ciclo de vida del TFG desde la propuesta inicial hasta la defensa final se hizo evidente al observar las dificultades actuales: estudiantes perdidos en procesos burocráticos, profesores sobrecargados con tareas administrativas, y administradores gestionando información dispersa en múltiples sistemas o documentos físicos.

Una plataforma que centralizara la gestión de TFGs, automatizara las comunicaciones, proporcionara transparencia del proceso y facilitara la coordinación entre todos los actores mejoraría significativamente la experiencia académica mientras reduce la carga administrativa.

Además, el uso de tecnologías modernas como React 19 y Symfony 6.4 aporta valor técnico al proyecto, implementando un sistema escalable que puede servir de referencia para la modernización de otros procesos académicos universitarios.

\section{Cumplimiento de los objetivos
propuestos}\label{cumplimiento-de-los-objetivos-propuestos}

Todos los objetivos planteados al inicio del proyecto se han cumplido satisfactoriamente. La plataforma está completamente funcional y lista para su uso en un entorno académico real.

\textbf{Objetivos funcionales}: El sistema maneja correctamente la autenticación multi-rol, los módulos específicos para cada usuario (estudiante, profesor, tribunal, administrador), el calendario integrado, las notificaciones, y toda la gestión de TFGs desde la subida hasta la defensa.

\textbf{Objetivos técnicos}: Se implementó una arquitectura moderna con React 19 y Symfony 6.4, base de datos optimizada, sistema de archivos seguro, entorno containerizado con DDEV, y testing automatizado del backend.

\textbf{Objetivos de calidad}: El sistema supera los requisitos de rendimiento, implementa seguridad de nivel empresarial, tiene una interfaz intuitiva probada con usuarios reales, y es compatible con todos los navegadores principales.

El único aspecto pendiente son mejoras opcionales como templates avanzados de email y testing E2E, que no afectan la funcionalidad principal del sistema.

\section{Trabajo futuro}\label{trabajo-futuro}

La proyección de la evolución del proyecto ofrece una visión estratégica del potencial de desarrollo de la plataforma. El trabajo futuro abarca oportunidades de mejora que se han identificado durante el desarrollo y posibilidades de expansión que pueden transformar el sistema actual en una solución académica aún más valiosa.

Esta proyección incluye desde mejoras incrementales de funcionalidades existentes hasta transformaciones tecnológicas que podrían redefinir la experiencia de gestión académica universitaria.

\subsection{Mejoras a corto plazo (1-6
meses)}\label{mejoras-a-corto-plazo-1-6-meses}

\subsubsection{Sistema de notificaciones por email
avanzado}\label{sistema-de-notificaciones-por-email-avanzado}

\textbf{Prioridad}: Media\\
\textbf{Esfuerzo estimado}: 30 horas\\
\textbf{Descripción}: Expansión del sistema de notificaciones con:

\begin{itemize}
\tightlist
\item
  Templates de email sofisticados con HTML/CSS.
\item
  Notificaciones programadas (recordatorios de defensas).
\item
  Preferencias de notificación por usuario.
\end{itemize}

\subsubsection{Métricas y analíticas
avanzadas}\label{muxe9tricas-y-analytics-avanzadas}

\textbf{Prioridad}: Media\\
\textbf{Esfuerzo estimado}: 25 horas\\
\textbf{Descripción}: Implementación de dashboard de métricas con:

\begin{itemize}
\tightlist
\item
  Gráficos interactivos con Chart.js o D3.js.
\item
  Métricas de uso del sistema.
\item
  Reportes de rendimiento académico.
\item
  Exportación de métricas personalizadas.
\end{itemize}

\subsection{Funcionalidades de mediano plazo (6-12
meses)}\label{funcionalidades-de-mediano-plazo-6-12-meses}

\subsubsection{Sistema de colaboración
avanzado}\label{sistema-de-colaboraciuxf3n-avanzado}

\textbf{Descripción}: Herramientas de colaboración entre estudiantes y
tutores:

\begin{itemize}
\tightlist
\item
  Chat en tiempo real integrado.
\item
  Sistema de comentarios por secciones del documento.
\item
  Versionado de documentos con diferenciación visual.
\item
  Edición colaborativa básica (similar a Google Docs).
\end{itemize}

\subsubsection{Inteligencia artificial y
automatización}\label{inteligencia-artificial-y-automatizaciuxf3n}

\textbf{Descripción}: Incorporación de IA para asistencia académica: 

\begin{itemize}
\tightlist
\item
  Detección automática de plagio básico.
\item
  Sugerencias de mejora en resúmenes y textos.
\item
  Asignación automática de tribunales basada en especialidades.
\end{itemize}

\subsubsection{Aplicación móvil
nativa}\label{aplicaciuxf3n-muxf3vil-nativa}

\textbf{Descripción}: Desarrollo de app móvil para funcionalidades
críticas: 

\begin{itemize}
\tightlist
\item
  Notificaciones push nativas.
\item
  Subida de archivos desde dispositivos móviles.
\item.
  Modo offline básico.
\end{itemize}

\subsection{Expansiones a largo plazo (1-2
años)}\label{expansiones-a-largo-plazo-1-2-auxf1os}

\subsubsection{Plataforma
multi-institucional}\label{plataforma-multi-institucional}

\textbf{Visión}: Expansión del sistema para múltiples universidades:

\begin{itemize}
\tightlist
\item
  Arquitectura multi-organización.
\item
  Gestión centralizada con personalización por institución.
\item.
  Intercambio de datos entre universidades.
\item
  Pruebas de rendimiento y escalabilidad para soportar múltiples instituciones.
\end{itemize}

\textbf{Beneficios}:

\begin{itemize}
\tightlist
\item
  Economías de escala en desarrollo y mantenimiento.
\item
  Compartición de mejores prácticas entre instituciones.
\item.
  Datos agregados para investigación educativa.
\item
  Posicionamiento como líder en tecnología académica.
\end{itemize}

\subsubsection{Integración con sistemas académicos
existentes}\label{integraciuxf3n-con-sistemas-acaduxe9micos-existentes}

\textbf{Descripción}: Conectores con sistemas universitarios:

\begin{itemize}
\tightlist
\item
  Integración con SIS (Student Information Systems).
\item
  Conexión con bibliotecas digitales.
\item
  Sincronización con calendarios académicos institucionales.
\item
  APIs para sistemas de evaluación externos.
\end{itemize}

\subsubsection{Marketplace de servicios
académicos}\label{marketplace-de-servicios-acaduxe9micos}

\textbf{Visión}: Plataforma extendida con servicios adicionales:

\begin{itemize}
\tightlist
\item
  Marketplace de tutores externos.
\item
  Servicios de revisión y edición profesional.
\item
  Herramientas de presentación y defensa virtual.
\item
  Certificaciones digitales blockchain.
\end{itemize}

\subsection{Innovaciones tecnológicas
futuras}\label{innovaciones-tecnoluxf3gicas-futuras}

\subsubsection{Realidad virtual para
defensas}\label{realidad-virtual-para-defensas}

\textbf{Concepto}: Entornos VR para defensas remotas inmersivas:

\begin{itemize}
\tightlist
\item
  Salas virtuales realistas para presentaciones.
\item
  Interacción natural con documentos 3D.
\item
  Grabación y replay de defensas.
\item
  Reducción de barreras geográficas.
\end{itemize}

\subsubsection{Blockchain para
certificaciones}\label{blockchain-para-certificaciones}

\textbf{Aplicación}: Registro inmutable de logros académicos:

\begin{itemize}
\tightlist
\item
  Certificados de TFG en blockchain.
\item
  Verificación automática de autenticidad.
\item
  Portfolio académico descentralizado.
\item
  Interoperabilidad global de credenciales.
\end{itemize}

\section{Lecciones aprendidas}\label{lecciones-aprendidas}

Las lecciones abarcan aspectos técnicos y personales del desarrollo, proporcionando aprendizaje valioso sobre qué estrategias funcionaron efectivamente, qué decisiones resultaron problemáticas y cómo abordar mejor proyectos similares. Esta reflexión crítica es fundamental para el crecimiento profesional y la mejora continua en desarrollo de software.

\subsection{Decisiones arquitectónicas
acertadas}\label{decisiones-arquitectuxf3nicas-acertadas}

\textbf{Uso de React 19}: A pesar de ser una versión muy reciente,
las funcionalidades de concurrencia y los hooks mejorados han
proporcionado beneficios significativos en rendimiento y experiencia de
desarrollo.

\textbf{Context API sobre Redux}: Para el alcance de este proyecto,
Context API ha demostrado ser suficiente y menos complejo que Redux,
facilitando el desarrollo y mantenimiento, la curva de dificultad de Redux era más pronunciada.

\textbf{Symfony 6.4 LTS}: La elección de una versión LTS garantiza
estabilidad y soporte a largo plazo (hasta 2027), crítico para un sistema académico.

\textbf{Docker/DDEV}: El entorno containerizado ha facilitado
enormemente el desarrollo y será crucial para el despliegue en
producción.

\subsection{Mejores prácticas
identificadas}\label{mejores-pruxe1cticas-identificadas}

\textbf{Desarrollo incremental}: La estrategia de 8 fases con entregas
funcionales ha permitido validación temprana y ajustes continuos.

\textbf{Testing desde el inicio}: Implementar testing unitario desde las
primeras fases ha reducido significativamente los errores y facilitado
la refactorización.

\textbf{Seguridad desde el diseño}: Considerar seguridad desde el diseño
inicial ha resultado en un sistema robusto sin necesidad de parches
posteriores.

\section{Reflexión final}\label{reflexiuxf3n-final}

Llegando al final de este proyecto, me doy cuenta de que ha sido mucho más que hacer una aplicación web. Al principio pensaba que solo iba a programar un sistema para gestionar TFGs, pero acabé aprendiendo un montón de cosas que ni sabía que existían.

Lo que más me ha sorprendido es cómo algo que empezó siendo "un proyecto pequeño" acabó convirtiéndose en un proyecto complejo con frontend y backend separados y con sus propias tecnologías y particularidades, base de datos, autenticación, tests... Ha sido como ir descubriendo capas de complejidad que no veía al principio. Cada vez que resolvía un problema aparecían tres más, pero esa sensación de ir avanzando poco a poco ha sido súper satisfactoria.

Técnicamente, el stack de React con Symfony ha funcionado mejor de lo que esperaba. Al principio dudaba si era demasiado ambicioso para un TFG, pero creo que la elección fue acertada. Me ha obligado a entender conceptos como manejo del State de React, autenticacion y tokens JWT y arquitectura modular que seguramente me van a servir en el futuro.

Lo que más me ha costado ha sido la gestión del tiempo y la planificación. Siempre pensaba que algo iba a tardar menos de lo que realmente tardaba, especialmente la integración entre frontend y backend. También he aprendido que la documentación no es solo un trámite - escribir código que otros puedan entender (incluido yo mismo dentro de unos meses) es casi tan importante como que funcione.

Al final, creo que he conseguido hacer algo útil de verdad. No es perfecto y hay mil cosas que se podrían mejorar, pero funciona y resuelve un problema real. Eso me da bastante orgulloß después de tanto tiempo trabajando en esto.

\newpage
\thispagestyle{empty}
\mbox{}

\newpage

\addcontentsline{toc}{chapter}{Bibliografía}
\chapter*{Bibliografía}

\noindent
[1] \textbf{React Team}. \textit{React - A JavaScript library for building user interfaces}. Meta, 2024. \texttt{https://react.dev/}

\noindent
[2] \textbf{Symfony Team}. \textit{Symfony 6.4 LTS - The Fast Track}. SensioLabs, 2024. \texttt{https://symfony.com/doc/6.4/}

\noindent
[3] \textbf{Oracle Corporation}. \textit{MySQL 8.0 Reference Manual}. Oracle, 2024. \texttt{https://dev.mysql.com/doc/refman/8.0/en/}

\noindent
[4] \textbf{Jones, M., Bradley, J., Sakimura, N.} \textit{JSON Web Token (JWT)}. RFC 7519, Internet Engineering Task Force, 2015. \texttt{https://tools.ietf.org/html/rfc7519}

\noindent
[5] \textbf{API Platform Team}. \textit{API Platform 3.x - Build modern web APIs}. Les-Tilleuls.coop, 2024. \texttt{https://api-platform.com/docs/}

\noindent
[6] \textbf{Wathan, A., Reinink, J.} \textit{Tailwind CSS v4 Documentation}. Tailwind Labs, 2024. \texttt{https://tailwindcss.com/docs}

\noindent
[7] \textbf{FullCalendar LLC}. \textit{FullCalendar - JavaScript Event Calendar}. Versión 6.x, 2024. \texttt{https://fullcalendar.io/docs}

\noindent
[8] \textbf{You, E.} \textit{Vite - Next Generation Frontend Tooling}. 2024. \texttt{https://vitejs.dev/guide/}

\noindent
[9] \textbf{Doctrine Team}. \textit{Doctrine ORM Documentation}. 2024. \texttt{https://www.doctrine-project.org/projects/orm.html}

\noindent
[10] \textbf{Bergmann, S.} \textit{PHPUnit - The PHP Testing Framework}. Versión 10.x, 2024. \texttt{https://phpunit.de/documentation.html}

\noindent
[11] \textbf{DDEV Community}. \textit{DDEV - Docker Development Environment}. 2024. \texttt{https://ddev.readthedocs.io/}

\noindent
[12] \textbf{Fielding, R. T.} \textit{Architectural Styles and the Design of Network-based Software Architectures}. Doctoral dissertation, University of California, Irvine, 2000.

\noindent
[13] \textbf{W3C}. \textit{Cross-Origin Resource Sharing (CORS)}. W3C Recommendation, 2014. \texttt{https://www.w3.org/TR/cors/}

\noindent
[14] \textbf{Hardt, D.} \textit{The OAuth 2.0 Authorization Framework}. RFC 6749, Internet Engineering Task Force, 2012. \texttt{https://tools.ietf.org/html/rfc6749}

\noindent
[15] \textbf{Beck, K., et al.} \textit{Manifesto for Agile Software Development}. 2001. \texttt{https://agilemanifesto.org/}

\noindent
[16] \textbf{Reenskaug, T.} \textit{The original MVC reports}. Xerox PARC, 1979.

\noindent
[17] \textbf{Martin, R. C.} \textit{Clean Code: A Handbook of Agile Software Craftsmanship}. Prentice Hall, 2008.

\noindent
[18] \textbf{Richardson, L., Ruby, S.} \textit{RESTful Web APIs}. O'Reilly Media, 2013.

\noindent
[19] \textbf{Fain, Y., Moiseev, A.} \textit{Angular 2 Development with TypeScript}. Manning Publications, 2016.

\noindent
[20] \textbf{Stuttard, D., Pinto, M.} \textit{The Web Application Hacker's Handbook: Finding and Exploiting Security Flaws}. 2ª edición, Wiley, 2018.

\noindent
[21] \textbf{Hernandez, M. J.} \textit{Database Design for Mere Mortals: A Hands-On Guide to Relational Database Design}. 4ª edición, Addison-Wesley, 2019.

\noindent
[22] \textbf{Bass, L., Clements, P., Kazman, R.} \textit{Software Architecture in Practice}. 4ª edición, Addison-Wesley, 2017.

\noindent
[23] \textbf{Khorikov, V.} \textit{Unit Testing Principles, Practices, and Patterns}. Manning Publications, 2020.

\noindent
[24] \textbf{Nickoloff, J., Kuenzli, S.} \textit{Docker in Action}. 2ª edición, Manning Publications, 2019.

\noindent
[25] \textbf{Gamma, E., Helm, R., Johnson, R., Vlissides, J.} \textit{Design Patterns: Elements of Reusable Object-Oriented Software}. Addison-Wesley, 1994.

\noindent
[26] \textbf{Fowler, M.} \textit{Refactoring: Improving the Design of Existing Code}. 2ª edición, Addison-Wesley, 2018.


\newpage

\chapter{Anexo A. Manual de
instalación}\label{anexo-a.-manual-de-instalaciuxf3n}
Este anexo proporciona una guía completa para la instalación y configuración de la Plataforma de Gestión de TFG en diferentes entornos. La información está estructurada para que tanto desarrolladores experimentados como usuarios con conocimientos técnicos básicos puedan establecer un entorno de desarrollo funcional.

La documentación abarca desde requisitos mínimos del sistema hasta procedimientos avanzados de configuración, incluyendo soluciones a problemas comunes durante el proceso. Cada sección ha sido validada mediante pruebas en diferentes entornos para asegurar precisión y completitud.

\section{A.1. Requisitos del sistema}\label{a.1.-requisitos-del-sistema}

Antes de instalar la Plataforma de Gestión de TFG, es fundamental verificar que el entorno cumple con los requisitos técnicos necesarios para el correcto funcionamiento del sistema. Estos requisitos consideran las necesidades de rendimiento y estabilidad operacional en diferentes escenarios de uso.

La especificación distingue entre entornos de desarrollo y producción, reconociendo que cada uno tiene demandas diferentes en recursos y configuración. El cumplimiento de estos requisitos garantiza una experiencia óptima durante la instalación y operación.

\subsection{A.1.1. Requisitos mínimos de
hardware}\label{a.1.1.-requisitos-muxednimos-de-hardware}

\textbf{Para desarrollo local:} - \textbf{CPU}: 4 núcleos (Intel i5 o
AMD Ryzen 5 equivalente). - \textbf{RAM}: 8 GB mínimo, 16 GB
recomendado. - \textbf{Almacenamiento}: 50 GB de espacio libre en SSD. -
\textbf{Red}: Conexión a Internet estable (100 Mbps recomendado).

\textbf{Para producción:} - \textbf{CPU}: 8 núcleos (Intel i7 o AMD
Ryzen 7). - \textbf{RAM}: 16 GB mínimo, 32 GB recomendado. -
\textbf{Almacenamiento}: 200 GB SSD para sistema + almacenamiento
adicional para archivos. - \textbf{Red}: Conexión dedicada con ancho de
banda adecuado.

\subsection{A.1.2. Requisitos de
software}\label{a.1.2.-requisitos-de-software}

\textbf{Sistema operativo soportado:} - Windows 10/11 (desarrollo). -
Linux Ubuntu 20.04+ (desarrollo y producción). - macOS 12+ (desarrollo).

\textbf{Software base requerido:} - \textbf{Docker Desktop}: Versión
4.12+. - \textbf{Node.js}: Versión 18.x LTS. - \textbf{Git}: Versión
2.30+. - \textbf{Editor de código}: VS Code recomendado.

\section{A.2. Instalación para
desarrollo}\label{a.2.-instalaciuxf3n-para-desarrollo}

Una vez verificados los requisitos del sistema, se procede con la instalación para desarrollo, que establece un entorno completo para modificar, probar y ejecutar la Plataforma de Gestión de TFG localmente. Este proceso está diseñado para ser reproducible y consistente entre diferentes sistemas operativos, utilizando DDEV como herramienta principal de containerización.

La instalación para desarrollo está optimizada para minimizar la configuración manual y maximizar la automatización, permitiendo que los desarrolladores comiencen a trabajar con el código rápidamente. Los contenedores Docker garantizan que el entorno de desarrollo sea idéntico al de producción, reduciendo problemas relacionados con diferencias de configuración.

\subsection{A.2.1. Configuración inicial del
proyecto}\label{a.2.1.-configuraciuxf3n-inicial-del-proyecto}

\subsubsection{Paso 1: Clonar el
repositorio}\label{paso-1-clonar-el-repositorio}

\begin{lstlisting}[language=bash]
## Clonar el repositorio principal
git clone https://github.com/tu-usuario/plataforma-tfg.git
cd plataforma-tfg

## Verificar la estructura del proyecto
ls -la
\end{lstlisting}

\textbf{Estructura esperada:}

\begin{lstlisting}
plataforma-tfg/
├── README.md
├── CLAUDE.md
├── DOCUMENTACION.md
├── backend.md
├── package.json
├── .gitignore
├── docs/
├── frontend/           # Aplicación React
└── backend/           # API Symfony (si existe)
\end{lstlisting}

\subsubsection{Paso 2: Configurar variables de
entorno}\label{paso-2-configurar-variables-de-entorno}

\textbf{Frontend (.env.local):}

\begin{lstlisting}[language=bash]
## Crear archivo de configuración para desarrollo
cd frontend
cp .env.example .env.local

## Editar variables según tu entorno
nano .env.local
\end{lstlisting}

\begin{lstlisting}[language=bash]
## Contenido de frontend/.env.local
VITE_API_BASE_URL=http://localhost:8000/api
VITE_APP_NAME=Plataforma de Gestión de TFG
VITE_ENVIRONMENT=development
VITE_ENABLE_DEV_TOOLS=true
\end{lstlisting}

\textbf{Backend (.env.local)} (cuando esté disponible):

\begin{lstlisting}[language=bash]
cd backend
cp .env.example .env.local
nano .env.local
\end{lstlisting}

\begin{lstlisting}[language=bash]
## Contenido de backend/.env.local
APP_ENV=dev
APP_DEBUG=true
APP_SECRET=your-secret-key-for-development

DATABASE_URL="mysql://root:password@127.0.0.1:3306/tfg_development"
JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
JWT_PASSPHRASE=your-jwt-passphrase

MAILER_DSN=smtp://localhost:1025
CORS_ALLOW_ORIGIN=http://localhost:5173
\end{lstlisting}

\subsection{A.2.2. Configuración con DDEV
(Recomendado)}\label{a.2.2.-configuraciuxf3n-con-ddev-recomendado}

\subsubsection{Paso 1: Instalación de
DDEV}\label{paso-1-instalaciuxf3n-de-ddev}

\textbf{En Windows:}

\begin{lstlisting}
## Usar Chocolatey
choco install ddev

## O descargar desde GitHub releases
## https://github.com/drud/ddev/releases
\end{lstlisting}

\textbf{En macOS:}

\begin{lstlisting}[language=bash]
## Usar Homebrew
brew install drud/ddev/ddev
\end{lstlisting}

\textbf{En Linux:}

\begin{lstlisting}[language=bash]
## Ubuntu/Debian
curl -fsSL https://apt.fury.io/drud/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/ddev.gpg
echo "deb [signed-by=/etc/apt/keyrings/ddev.gpg] https://apt.fury.io/drud/ * *" | sudo tee /etc/apt/sources.list.d/ddev.list
sudo apt update && sudo apt install ddev
\end{lstlisting}

\subsubsection{Paso 2: Configuración inicial de
DDEV}\label{paso-2-configuraciuxf3n-inicial-de-ddev}

\begin{lstlisting}[language=bash]
## Ir al directorio raíz del proyecto
cd plataforma-tfg

## Inicializar DDEV
ddev config

## Configuración interactiva:
## - Project name: plataforma-tfg
## - Docroot: public (para Symfony) o dist (para React)
## - Project type: symfony o react
\end{lstlisting}

\subsubsection{Paso 3: Configuración específica de
DDEV}\label{paso-3-configuraciuxf3n-especuxedfica-de-ddev}

\textbf{Crear archivo .ddev/config.yaml:}

\begin{lstlisting}
name: plataforma-tfg
type: php
docroot: backend/public
php_version: "8.2"
webserver_type: nginx-fpm
router_http_port: "80"
router_https_port: "443"
xdebug_enabled: true
additional_hostnames: []
additional_fqdns: []
database:
  type: mysql
  version: "8.0"
  
## Servicios adicionales
services:
  redis:
    type: redis
    version: "7"
  mailpit:
    type: mailpit

## Configuración de Node.js para frontend
nodejs_version: "18"

## Comandos personalizados
hooks:
  post-start:
    - exec: "cd frontend && npm install"
    - exec: "cd backend && composer install"
\end{lstlisting}

\subsubsection{Paso 4: Iniciar el entorno
DDEV}\label{paso-4-iniciar-el-entorno-ddev}

\begin{lstlisting}[language=bash]
## Iniciar todos los servicios
ddev start

## Verificar estado
ddev status

## Ver URLs disponibles
ddev describe
\end{lstlisting}

\textbf{URLs típicas generadas:} - \textbf{Aplicación principal}:
https://plataforma-tfg.ddev.site - \textbf{PHPMyAdmin}:
https://plataforma-tfg.ddev.site:8036 - \textbf{Mailpit}:
https://plataforma-tfg.ddev.site:8025

\subsection{A.2.3. Configuración del
frontend}\label{a.2.3.-configuraciuxf3n-del-frontend}

\subsubsection{Paso 1: Instalación de
dependencias}\label{paso-1-instalaciuxf3n-de-dependencias}

\begin{lstlisting}[language=bash]
## Dentro del contenedor DDEV o localmente
cd frontend

## Instalar dependencias
npm install

## Verificar instalación
npm list --depth=0
\end{lstlisting}

\subsubsection{Paso 2: Configuración de herramientas de
desarrollo}\label{paso-2-configuraciuxf3n-de-herramientas-de-desarrollo}

\textbf{ESLint y Prettier:}

\begin{lstlisting}[language=bash]
## Verificar configuración
npm run lint

## Corregir errores automáticamente
npm run lint:fix

## Verificar formateo
npm run format
\end{lstlisting}

\textbf{Configuración de VS Code (.vscode/settings.json):}

\begin{lstlisting}
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "emmet.includeLanguages": {
    "javascript": "javascriptreact"
  },
  "tailwindCSS.includeLanguages": {
    "javascript": "javascript",
    "html": "html"
  }
}
\end{lstlisting}

\subsubsection{Paso 3: Iniciar servidor de
desarrollo}\label{paso-3-iniciar-servidor-de-desarrollo}

\begin{lstlisting}[language=bash]
## Iniciar servidor de desarrollo
npm run dev

## El servidor estará disponible en:
## http://localhost:5173
\end{lstlisting}

\subsection{A.2.4. Configuración del backend
(Symfony)}\label{a.2.4.-configuraciuxf3n-del-backend-symfony}

\subsubsection{Paso 1: Instalación de Composer y
dependencias}\label{paso-1-instalaciuxf3n-de-composer-y-dependencias}

\begin{lstlisting}[language=bash]
## Dentro del contenedor DDEV
ddev ssh

## Ir al directorio backend
cd backend

## Instalar dependencias
composer install

## Verificar instalación
composer show
\end{lstlisting}

\subsubsection{Paso 2: Configuración de la base de
datos}\label{paso-2-configuraciuxf3n-de-la-base-de-datos}

\begin{lstlisting}[language=bash]
## Crear la base de datos
ddev exec php bin/console doctrine:database:create

## Ejecutar migraciones (cuando estén disponibles)
ddev exec php bin/console doctrine:migrations:migrate

## Cargar datos de prueba (fixtures)
ddev exec php bin/console doctrine:fixtures:load --no-interaction
\end{lstlisting}

\subsubsection{Paso 3: Generar claves
JWT}\label{paso-3-generar-claves-jwt}

\begin{lstlisting}[language=bash]
## Generar par de claves JWT
ddev exec php bin/console lexik:jwt:generate-keypair

## Las claves se generarán en:
## config/jwt/private.pem
## config/jwt/public.pem
\end{lstlisting}

\subsubsection{Paso 4: Configurar caché y
logs}\label{paso-4-configurar-cachuxe9-y-logs}

\begin{lstlisting}[language=bash]
## Limpiar caché
ddev exec php bin/console cache:clear

## Verificar configuración
ddev exec php bin/console debug:config

## Verificar servicios
ddev exec php bin/console debug:autowiring
\end{lstlisting}

\section{A.3. Configuración de la base de
datos}\label{a.3.-configuraciuxf3n-de-la-base-de-datos}

La configuración de la base de datos constituye un paso crítico en la instalación, ya que determina tanto el rendimiento como la integridad de los datos del sistema. La Plataforma de Gestión de TFG utiliza MySQL 8.0 como sistema de gestión de base de datos, aprovechando sus características avanzadas de seguridad, rendimiento y escalabilidad.

Este proceso incluye la configuración inicial de la base de datos, la creación de usuarios con permisos apropiados, y la carga de datos de prueba que facilitan el desarrollo y testing. La configuración está optimizada para entornos de desarrollo y producción.

\subsection{A.3.1. Configuración de
MySQL}\label{a.3.1.-configuraciuxf3n-de-mysql}

\subsubsection{Opción A: Usando DDEV
(Recomendado)}\label{opciuxf3n-a-usando-ddev-recomendado}

\begin{lstlisting}[language=bash]
## DDEV gestiona automáticamente MySQL
## Acceso a la base de datos:
ddev mysql

## Información de conexión:
## Host: db
## Port: 3306  
## Database: db
## Username: db
## Password: db
\end{lstlisting}

\subsubsection{Opción B: MySQL local}\label{opciuxf3n-b-mysql-local}

\begin{lstlisting}[language=bash]
## Instalar MySQL 8.0
## Ubuntu/Debian:
sudo apt update
sudo apt install mysql-server-8.0

## Configurar seguridad
sudo mysql_secure_installation

## Crear base de datos y usuario
mysql -u root -p
\end{lstlisting}

\begin{lstlisting}[language=SQL]
-- Crear base de datos
CREATE DATABASE tfg_development CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- Crear usuario específico
CREATE USER 'tfg_user'@'localhost' IDENTIFIED BY 'secure_password';

-- Otorgar permisos
GRANT ALL PRIVILEGES ON tfg_development.* TO 'tfg_user'@'localhost';
FLUSH PRIVILEGES;

-- Verificar creación
SHOW DATABASES;
SELECT User, Host FROM mysql.user WHERE User = 'tfg_user';
\end{lstlisting}

\subsection{A.3.2. Esquema inicial de la base de
datos}\label{a.3.2.-esquema-inicial-de-la-base-de-datos}

\textbf{Ejecutar migraciones iniciales:}

\begin{lstlisting}[language=bash]
## Con DDEV
ddev exec php bin/console doctrine:migrations:migrate

## O localmente
php bin/console doctrine:migrations:migrate
\end{lstlisting}

\textbf{Estructura de tablas creadas:} - \passthrough{\lstinline!users!}
- Usuarios del sistema con roles. - \passthrough{\lstinline!tfgs!} -
Trabajos de Fin de Grado. - \passthrough{\lstinline!tribunales!} -
Tribunales evaluadores. - \passthrough{\lstinline!defensas!} - Defensas
programadas. - \passthrough{\lstinline!calificaciones!} - Calificaciones
de defensas. - \passthrough{\lstinline!notificaciones!} - Sistema de
notificaciones. - \passthrough{\lstinline!comentarios!} - Comentarios en
TFGs.

\subsection{A.3.3. Datos de prueba}\label{a.3.3.-datos-de-prueba}

\begin{lstlisting}[language=bash]
## Cargar fixtures con datos de prueba
ddev exec php bin/console doctrine:fixtures:load --no-interaction

## Los siguientes usuarios de prueba estarán disponibles:
## estudiante@uni.es / 123456 (ROLE_ESTUDIANTE)
## profesor@uni.es / 123456 (ROLE_PROFESOR)
## presidente@uni.es / 123456 (ROLE_PRESIDENTE_TRIBUNAL)
## admin@uni.es / 123456 (ROLE_ADMIN)
\end{lstlisting}

\section{A.4. Configuración de desarrollo
avanzada}\label{a.4.-configuraciuxf3n-de-desarrollo-avanzada}

\subsection{A.4.1. Debugging y logs}\label{a.4.1.-debugging-y-logs}

\subsubsection{Configuración de Xdebug
(PHP)}\label{configuraciuxf3n-de-xdebug-php}

\textbf{En .ddev/config.yaml:}

\begin{lstlisting}
xdebug_enabled: true
\end{lstlisting}

\textbf{Configuración en VS Code (launch.json):}

\begin{lstlisting}
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Listen for Xdebug",
      "type": "php",
      "request": "launch",
      "port": 9003,
      "pathMappings": {
        "/var/www/html": "${workspaceFolder}/backend"
      }
    }
  ]
}
\end{lstlisting}

\subsubsection{Configuración de logs}\label{configuraciuxf3n-de-logs}

\textbf{Frontend (React Developer Tools):}

\begin{lstlisting}[language=bash]
## Instalar extensión React Developer Tools en el navegador
## Chrome: https://chrome.google.com/webstore/detail/fmkadmapgofadopljbjfkapdkoienihi
## Firefox: https://addons.mozilla.org/en-US/firefox/addon/react-devtools/
\end{lstlisting}

\textbf{Backend (Symfony Profiler):}

\begin{lstlisting}
## config/packages/dev/web_profiler.yaml
web_profiler:
    toolbar: true
    intercept_redirects: false
\end{lstlisting}

\subsection{A.4.2. Testing
environment}\label{a.4.2.-testing-environment}

\subsubsection{Configuración para testing del
frontend}\label{configuraciuxf3n-para-testing-del-frontend}

\begin{lstlisting}[language=bash]
cd frontend

## Instalar dependencias de testing
npm install --save-dev @testing-library/react @testing-library/jest-dom vitest

## Ejecutar tests
npm run test

## Ejecutar con coverage
npm run test:coverage
\end{lstlisting}

\subsubsection{Configuración para testing del
backend}\label{configuraciuxf3n-para-testing-del-backend}

\begin{lstlisting}[language=bash]
## Crear base de datos de testing
ddev exec php bin/console doctrine:database:create --env=test

## Ejecutar migraciones en testing
ddev exec php bin/console doctrine:migrations:migrate --env=test --no-interaction

## Ejecutar tests
ddev exec php bin/phpunit

## Con coverage
ddev exec php bin/phpunit --coverage-html coverage/
\end{lstlisting}

\subsection{A.4.3. Herramientas de desarrollo
adicionales}\label{a.4.3.-herramientas-de-desarrollo-adicionales}

\subsubsection{Git hooks para calidad de
código}\label{git-hooks-para-calidad-de-cuxf3digo}

\begin{lstlisting}[language=bash]
## Instalar husky para git hooks
cd frontend
npm install --save-dev husky lint-staged

## Configurar pre-commit hook
npx husky add .husky/pre-commit "npm run lint && npm run test"
\end{lstlisting}

\subsubsection{Extensiones recomendadas de VS
Code}\label{extensiones-recomendadas-de-vs-code}

\begin{lstlisting}
{
  "recommendations": [
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-eslint",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-typescript-next",
    "bmewburn.vscode-intelephense-client",
    "ms-vscode.vscode-docker",
    "ms-vscode.vscode-json"
  ]
}
\end{lstlisting}

\section{A.5. Solución de problemas
comunes}\label{a.5.-soluciuxf3n-de-problemas-comunes}

Durante la instalación y configuración de la Plataforma de Gestión de TFG, pueden surgir diversos problemas técnicos que requieren atención específica. Esta sección compila las dificultades más frecuentemente reportadas junto con sus soluciones correspondientes, facilitando una resolución rápida y eficiente.

La documentación de problemas comunes se basa en experiencias reales de instalación en diferentes entornos y configuraciones, proporcionando soluciones probadas que han demostrado efectividad. Cada problema incluye no solo la solución inmediata, sino también información contextual que ayuda a comprender las causas subyacentes y prevenir futuras ocurrencias.

\subsection{A.5.1. Problemas de DDEV}\label{a.5.1.-problemas-de-ddev}

\textbf{Error: ``Port already in use''}

\begin{lstlisting}[language=bash]
## Verificar puertos en uso
ddev stop --all

## Cambiar puerto en configuración
ddev config --router-http-port=8080 --router-https-port=8443

## Reiniciar
ddev start
\end{lstlisting}

\textbf{Error: ``Database connection failed''}

\begin{lstlisting}[language=bash]
## Verificar estado de servicios
ddev status

## Reiniciar base de datos
ddev restart

## Verificar logs
ddev logs db
\end{lstlisting}

\subsection{A.5.2. Problemas del
frontend}\label{a.5.2.-problemas-del-frontend}

\textbf{Error: ``Module not found''}

\begin{lstlisting}[language=bash]
## Limpiar caché de npm
npm cache clean --force

## Eliminar node_modules y reinstalar
rm -rf node_modules package-lock.json
npm install
\end{lstlisting}

\textbf{Error: ``Port 5173 is already in use''}

\begin{lstlisting}[language=bash]
## Cambiar puerto en vite.config.js
export default defineConfig({
  server: {
    port: 3000
  }
})
\end{lstlisting}

\subsection{A.5.3. Problemas del
backend}\label{a.5.3.-problemas-del-backend}

\textbf{Error: ``JWT keys not found''}

\begin{lstlisting}[language=bash]
## Generar nuevas claves JWT
ddev exec php bin/console lexik:jwt:generate-keypair --skip-if-exists

## Verificar permisos
ddev exec chmod 644 config/jwt/*.pem
\end{lstlisting}

\textbf{Error: ``Unable to write in cache directory''}

\begin{lstlisting}[language=bash]
## Corregir permisos de caché
ddev exec chmod -R 777 var/

## Limpiar caché
ddev exec php bin/console cache:clear --no-warmup
\end{lstlisting}

\subsection{A.5.4. Problemas de
rendimiento}\label{a.5.4.-problemas-de-rendimiento}

\textbf{Frontend lento en desarrollo:}

\begin{lstlisting}
// vite.config.js - Optimizaciones para desarrollo
export default defineConfig({
  server: {
    hmr: {
      overlay: false // Disable error overlay for faster reloads
    }
  },
  optimizeDeps: {
    include: ['react', 'react-dom'] // Pre-bundle heavy dependencies
  }
})
\end{lstlisting}

\textbf{Backend lento:}

\begin{lstlisting}
## config/packages/dev/doctrine.yaml
doctrine:
    dbal:
        profiling_collect_backtrace: false
    orm:
        auto_generate_proxy_classes: true
\end{lstlisting}

\section{A.6. Comandos útiles de
desarrollo}\label{a.6.-comandos-uxfatiles-de-desarrollo}

\subsection{A.6.1. Comandos DDEV
frecuentes}\label{a.6.1.-comandos-ddev-frecuentes}

\begin{lstlisting}[language=bash]
## Gestión de servicios
ddev start              # Iniciar proyecto
ddev stop               # Parar proyecto
ddev restart            # Reiniciar proyecto
ddev poweroff           # Parar todos los proyectos DDEV

## Información del proyecto
ddev describe           # Mostrar URLs y detalles
ddev status             # Estado de servicios
ddev list               # Listar proyectos DDEV

## Acceso a servicios
ddev ssh                # SSH al contenedor web
ddev mysql              # Acceso a MySQL CLI
ddev logs               # Ver logs generales
ddev logs web           # Ver logs del servidor web

## Utilidades
ddev import-db --src=dump.sql  # Importar base de datos
ddev export-db > dump.sql      # Exportar base de datos
ddev snapshot               # Crear snapshot del proyecto
\end{lstlisting}

\subsection{A.6.2. Comandos del
frontend}\label{a.6.2.-comandos-del-frontend}

\begin{lstlisting}[language=bash]
## Desarrollo
npm run dev             # Servidor de desarrollo
npm run build           # Build de producción
npm run preview         # Preview del build

## Calidad de código
npm run lint            # Ejecutar ESLint
npm run lint:fix        # Corregir errores de ESLint
npm run format          # Formatear con Prettier

## Testing
npm run test            # Ejecutar tests
npm run test:watch      # Tests en modo watch
npm run test:coverage   # Tests con coverage
\end{lstlisting}

\subsection{A.6.3. Comandos del
backend}\label{a.6.3.-comandos-del-backend}

\begin{lstlisting}[language=bash]
## Doctrine
php bin/console doctrine:database:create
php bin/console doctrine:migrations:migrate
php bin/console doctrine:fixtures:load

## Caché
php bin/console cache:clear
php bin/console cache:warmup

## Debugging
php bin/console debug:config
php bin/console debug:container
php bin/console debug:autowiring

## JWT
php bin/console lexik:jwt:generate-keypair

## Testing
php bin/phpunit
php bin/phpunit --coverage-html coverage/
\end{lstlisting}

\section{A.7. Verificación de la
instalación}\label{a.7.-verificaciuxf3n-de-la-instalaciuxf3n}

Para garantizar que la Plataforma de Gestión de TFG ha sido instalada correctamente y está operativa en todos sus componentes, es esencial realizar una verificación sistemática de la instalación. Este proceso incluye pruebas de conectividad, funcionalidad básica y rendimiento del sistema, asegurando que todos los servicios funcionen según las especificaciones.

La verificación no solo confirma que los componentes técnicos están operativos, sino que también valida que la integración entre frontend, backend y base de datos funciona correctamente. Este paso es crítico antes de comenzar el desarrollo activo o el despliegue en producción.

\subsection{A.7.1. Checklist de
verificación}\label{a.7.1.-checklist-de-verificaciuxf3n}

\textbf{✅ Entorno DDEV:} - {[} {]} DDEV instalado y funcionando. - {[}
{]} Proyecto iniciado sin errores. - {[} {]} URLs accesibles (web,
PHPMyAdmin, Mailpit). - {[} {]} Base de datos creada y accesible.

\textbf{✅ Frontend:} - {[} {]} Dependencias instaladas correctamente. -
{[} {]} Servidor de desarrollo inicia sin errores. - {[} {]} Linting y
formateo funcionando. - {[} {]} Tests básicos pasando.

\textbf{✅ Backend:} - {[} {]} Composer dependencies instaladas. - {[}
{]} Migraciones ejecutadas correctamente. - {[} {]} Claves JWT
generadas. - {[} {]} Fixtures cargados. - {[} {]} API endpoints
respondiendo.

\textbf{✅ Integración:} - {[} {]} Frontend puede conectar con backend.
- {[} {]} Autenticación JWT funcionando. - {[} {]} CORS configurado
correctamente. - {[} {]} Logs accesibles y configurados.

\subsection{A.7.2. Script de verificación
automatizada}\label{a.7.2.-script-de-verificaciuxf3n-automatizada}

\begin{lstlisting}[language=bash]
#!/bin/bash
## scripts/verify-installation.sh

echo "🔍 Verificando instalación de la Plataforma de Gestión de TFG..."

## Verificar DDEV
if ! command -v ddev &> /dev/null; then
    echo "❌ DDEV no está instalado"
    exit 1
fi

## Verificar estado del proyecto
if ! ddev status | grep -q "running"; then
    echo "❌ El proyecto DDEV no está ejecutándose"
    exit 1
fi

## Verificar frontend
if [ -d "frontend/node_modules" ]; then
    echo "✅ Dependencias del frontend instaladas"
else
    echo "❌ Falta instalar dependencias del frontend"
fi

## Verificar backend
if [ -d "backend/vendor" ]; then
    echo "✅ Dependencias del backend instaladas"
else
    echo "❌ Falta instalar dependencias del backend"
fi

## Verificar base de datos
if ddev mysql -e "SELECT 1" &> /dev/null; then
    echo "✅ Base de datos accesible"
else
    echo "❌ Problema con la base de datos"
fi

## Test de conectividad
if curl -f -s https://plataforma-tfg.ddev.site > /dev/null; then
    echo "✅ Aplicación web accesible"
else
    echo "❌ La aplicación web no responde"
fi

echo "🎉 Verificación completada"
\end{lstlisting}


% Bibliografía (si existe)
\bibliographystyle{plain}
\bibliography{referencias}

\end{document}