\documentclass[12pt,a4paper,oneside]{report}
\usepackage[utf8]{inputenc}
\usepackage[spanish,english]{babel}
\renewcommand{\chaptername}{Capítulo}
\usepackage[margin=2.5cm,top=3cm,bottom=3cm]{geometry}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tocloft}
\usepackage{titlesec}
\usepackage{longtable}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{calc}
\usepackage{float}
\usepackage{setspace}
\usepackage{parskip}

% Definir tightlist si no existe
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

% Definir pandocbounded si no existe
\providecommand{\pandocbounded}[1]{#1}

% Definir passthrough si no existe
\providecommand{\passthrough}[1]{\texttt{#1}}

% Configuración de spacing
\onehalfspacing
\setlength{\parskip}{6pt}

% Configuración de imágenes para ajuste automático
\usepackage{adjustbox}
\graphicspath{{processed/images/}}
\setkeys{Gin}{width=\linewidth,height=\textheight,keepaspectratio}

% Configuración de colores para código
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

% Configuración de listings
\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}
\lstset{style=mystyle}

% Headers y footers
\pagestyle{fancy}
\fancyhf{}
\fancyhead[R]{\small\leftmark}
\fancyfoot[C]{\thepage}

% Configurar marks para mostrar nombres de capítulos correctamente
\renewcommand{\chaptermark}[1]{\markboth{#1}{}}

% Configuración de títulos
\titleformat{\chapter}[hang]
{\normalfont\huge\bfseries}{\thechapter.}{1em}{}
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

% Configuración de hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    citecolor=red,
    pdftitle={Plataforma de Gestión de TFG - Documentación Técnica},
    pdfauthor={Tu Nombre},
    pdfsubject={Trabajo de Fin de Grado - Ingeniería Informática},
    pdfcreator={Pandoc with LaTeX},
    pdfkeywords={TFG, React, Symfony, Plataforma Web}
}

% Configuración de tabla de contenidos
\setcounter{tocdepth}{3}
\setcounter{secnumdepth}{3}

% Redefinir el comando de inclusión de imágenes de Pandoc
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>0.8\textheight 0.8\textheight\else\Gin@nat@height\fi}
\makeatother
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}

\begin{document}

% Incluir portada
\input{template/portada.tex}

% Tabla de contenidos
\renewcommand{\contentsname}{Índice}
\markboth{Índice}{Índice}
\tableofcontents
\newpage

% Lista de figuras
\renewcommand{\listfigurename}{Lista de Figuras}
\markboth{Lista de Figuras}{Lista de Figuras}
\listoffigures
\newpage

% Limpiar marks antes del contenido principal
\markboth{}{}

% Configurar numeración de capítulos
\setcounter{chapter}{0}

% Contenido principal
\chapter{Visión general del
proyecto}\label{visiuxf3n-general-del-proyecto}
En este capítulo se ofrecerá una visión general del proyecto
desarrollado, abarcando desde la motivación que llevó a su concepción
hasta los objetivos que pretende cumplir y el alcance del mismo. Se
presenta también una visión general de la estructura y los contenidos
del presente documento, los estándares que sigue y las convenciones
utilizadas en su redacción. Por último, se incluye la definición de los
conceptos más relevantes del proyecto.

El desarrollo de esta plataforma de gestión de TFG surge como respuesta
a las necesidades identificadas en el ámbito universitario actual, donde
la digitalización de procesos académicos se ha convertido en una
prioridad estratégica. A través de este capítulo, se establecerán las
bases conceptuales que justifican la necesidad del sistema y se
definirán los parámetros que guiarán su desarrollo e implementación.

\section{Motivación}\label{motivaciuxf3n}

En el ámbito académico universitario, la gestión de Trabajos de Fin de
Grado (TFG) representa un proceso complejo que involucra múltiples
actores: estudiantes, profesores tutores, tribunales de evaluación y
personal administrativo. Tradicionalmente, este proceso se ha gestionado
de manera fragmentada, utilizando herramientas dispersas como correo
electrónico, documentos físicos y hojas de cálculo, lo que genera
ineficiencias, pérdida de información y dificultades en el seguimiento
del progreso académico.

La digitalización de los procesos educativos se ha acelerado
significativamente, especialmente tras la pandemia de COVID-19,
evidenciando la necesidad de sistemas integrados que faciliten la
gestión académica remota y presencial. Las universidades requieren
plataformas que no solo digitalicen los procesos existentes, sino que
los optimicen mediante la automatización, el seguimiento en tiempo real
y la generación de reportes analíticos.

Además, el cumplimiento de normativas académicas específicas, la gestión
de plazos estrictos y la coordinación entre diferentes departamentos
universitarios demandan una solución tecnológica robusta que centralice
toda la información relacionada con los TFG en un único sistema
accesible y seguro.

\section{Objetivos}\label{objetivos}

La definición clara de objetivos constituye un elemento fundamental para
el éxito de cualquier proyecto de desarrollo software. En esta sección
se establecen tanto el objetivo general como los objetivos específicos
que guían la implementación de la plataforma de gestión de TFG,
categorizados según su naturaleza funcional, técnica y de calidad.

Estos objetivos han sido formulados siguiendo la metodología SMART
(Específicos, Medibles, Alcanzables, Relevantes y Temporales),
asegurando que cada uno contribuya directamente al propósito general del
proyecto y pueda ser evaluado objetivamente al finalizar el desarrollo.

\subsection{Objetivo General}\label{objetivo-general}

Desarrollar una plataforma web integral para la gestión completa del
ciclo de vida de los Trabajos de Fin de Grado, desde la propuesta
inicial hasta la defensa final, proporcionando un sistema unificado que
mejore la eficiencia, transparencia y seguimiento del proceso académico.

\subsection{Objetivos Específicos}\label{objetivos-especuxedficos}

\textbf{Objetivos Funcionales:}

\begin{itemize}
\tightlist
\item
  \textbf{OF1}: Implementar un sistema de autenticación seguro basado en
  JWT que soporte múltiples roles de usuario (estudiante, profesor,
  presidente de tribunal, administrador).
\item
  \textbf{OF2}: Desarrollar un módulo completo para estudiantes que
  permita la subida, edición y seguimiento del estado de sus TFG.
\item
  \textbf{OF3}: Crear un sistema de gestión para profesores tutores que
  facilite la supervisión, evaluación y retroalimentación de los TFG
  asignados.
\item
  \textbf{OF4}: Implementar un módulo de gestión de tribunales que
  permita la creación, asignación y coordinación de defensas.
\item
  \textbf{OF5}: Desarrollar un sistema de calendario integrado para la
  programación y gestión de defensas presenciales.
\item
  \textbf{OF6}: Crear un panel administrativo completo para la gestión
  de usuarios, reportes y configuración del sistema.
\item
  \textbf{OF7}: Implementar un sistema de notificaciones en tiempo real
  para mantener informados a todos los actores del proceso.
\end{itemize}

\textbf{Objetivos Técnicos:}

\begin{itemize}
\tightlist
\item
  \textbf{OT1}: Diseñar una arquitectura frontend moderna basada en
  React 19 con componentes reutilizables y responsive design.
\item
  \textbf{OT2}: Implementar un backend robusto con Symfony 6.4 LTS que
  proporcione APIs REST seguras y escalables.
\item
  \textbf{OT3}: Establecer un sistema de base de datos optimizado con
  MySQL 8.0 que garantice la integridad y consistencia de los datos.
\item
  \textbf{OT4}: Desarrollar un sistema de gestión de archivos seguro
  para el almacenamiento y descarga de documentos TFG.
\item
  \textbf{OT5}: Implementar un sistema de testing automatizado que cubra
  tanto frontend como backend.
\item
  \textbf{OT6}: Configurar un entorno de desarrollo containerizado con
  DDEV para facilitar la colaboración y despliegue.
\end{itemize}

\textbf{Objetivos de Calidad:}

\begin{itemize}
\tightlist
\item
  \textbf{OC1}: Garantizar un tiempo de respuesta menor a 2 segundos
  para todas las operaciones críticas del sistema.
\item
  \textbf{OC2}: Implementar medidas de seguridad que cumplan con
  estándares académicos de protección de datos.
\item
  \textbf{OC3}: Diseñar una interfaz de usuario intuitiva con una curva
  de aprendizaje mínima para todos los roles.
\item
  \textbf{OC4}: Asegurar compatibilidad cross-browser y responsive
  design para dispositivos móviles y tablets.
\item
  \textbf{OC5}: Establecer un sistema de backup y recuperación de datos
  que garantice la disponibilidad del servicio.
\end{itemize}

\section{Alcance}\label{alcance}

La definición del alcance del proyecto es crucial para establecer
límites claros sobre qué incluye y qué excluye el desarrollo de la
plataforma. Esta delimitación permite gestionar expectativas, recursos y
tiempos de manera efectiva, asegurando que el proyecto se mantenga
enfocado en sus objetivos principales.

El alcance se estructura en tres dimensiones complementarias: funcional,
técnica y temporal. Cada una de estas dimensiones aborda aspectos
específicos del proyecto, desde las funcionalidades que se implementarán
hasta las tecnologías que se utilizarán y los plazos de desarrollo
establecidos.

\subsection{Alcance Funcional}\label{alcance-funcional}

\textbf{Incluido en el proyecto:}

\begin{itemize}
\tightlist
\item
  \textbf{Gestión completa del ciclo de vida del TFG}: Desde la creación
  inicial hasta la calificación final.
\item
  \textbf{Sistema multi-rol}: Soporte para cuatro tipos de usuario con
  permisos diferenciados.
\item
  \textbf{Gestión de archivos}: Upload, almacenamiento y descarga segura
  de documentos PDF.
\item
  \textbf{Sistema de calendario}: Programación y gestión de defensas con
  disponibilidad de tribunales.
\item
  \textbf{Panel de reportes}: Generación de estadísticas y exportación
  de datos en múltiples formatos.
\item
  \textbf{Sistema de notificaciones}: Alertas en tiempo real y
  notificaciones por email.
\item
  \textbf{API REST completa}: Endpoints documentados para todas las
  funcionalidades del sistema.
\end{itemize}

\textbf{No incluido en el proyecto:}

\begin{itemize}
\tightlist
\item
  Sistema de videoconferencia integrado para defensas remotas.
\item
  Integración con sistemas de información universitarios existentes (ERP
  académico).
\item
  Módulo de plagio o análisis de contenido automático.
\item
  Sistema de facturación o pagos.
\item
  Funcionalidades de red social o colaboración entre estudiantes.
\item
  Soporte multiidioma (solo español en esta versión).
\end{itemize}

\subsection{Alcance Técnico}\label{alcance-tuxe9cnico}

\textbf{Tecnologías implementadas:}

\begin{itemize}
\tightlist
\item
  \textbf{Frontend}: React 19, Vite, Tailwind CSS v4, React Router DOM
  v7.
\item
  \textbf{Backend}: Symfony 6.4 LTS, PHP 8.2+, API Platform 3.x.
\item
  \textbf{Base de datos}: MySQL 8.0 con Doctrine ORM.
\item
  \textbf{Autenticación}: JWT con refresh tokens.
\item
  \textbf{Gestión de archivos}: VichUploaderBundle con validaciones de
  seguridad.
\item
  \textbf{Testing}: PHPUnit (backend), Vitest (frontend).
\item
  \textbf{Desarrollo}: DDEV con Docker, Composer, npm.
\end{itemize}

\textbf{Limitaciones técnicas:}

\begin{itemize}
\tightlist
\item
  Soporte únicamente para archivos PDF (no otros formatos de documento).
\item
  Base de datos relacional (no NoSQL para este alcance).
\item
  Despliegue en servidor único (no arquitectura de microservicios).
\item
  Almacenamiento local de archivos (no integración con servicios cloud
  en esta versión).
\end{itemize}

\subsection{Alcance Temporal}\label{alcance-temporal}

El proyecto se desarrolla en 8 fases distribuidas a lo largo de 10
semanas académicas:

\begin{itemize}
\tightlist
\item
  \textbf{Fases 1-6}: Completadas (desarrollo frontend completo).
\item
  \textbf{Fase 7}: En desarrollo (implementación backend Symfony).
\item
  \textbf{Fase 8}: Planificada (testing, optimización y despliegue).
\end{itemize}

\section{Visión general del
documento}\label{visiuxf3n-general-del-documento}

La estructura y organización de este documento ha sido cuidadosamente
diseñada para proporcionar una comprensión completa y progresiva del
proyecto desarrollado. Siguiendo las mejores prácticas de documentación
técnica, cada capítulo aborda aspectos específicos del desarrollo, desde
la conceptualización inicial hasta la implementación final.

Este documento técnico sigue el estándar ISO/IEEE 16326 para
documentación de sistemas software, adaptado al contexto académico de un
Trabajo de Fin de Grado. La estructura del documento está organizada de
la siguiente manera:

\textbf{Capítulo 1 - Visión general del proyecto}: Establece la
motivación, objetivos y alcance del proyecto, proporcionando el contexto
necesario para comprender la necesidad y los beneficios de la plataforma
desarrollada.

\textbf{Capítulo 2 - Contexto del proyecto}: Describe detalladamente el
entorno tecnológico, las características de los usuarios objetivo y el
modelo de ciclo de vida adoptado para el desarrollo del sistema.

\textbf{Capítulo 3 - Planificación}: Presenta la metodología de
desarrollo por fases, cronogramas de implementación y la distribución
temporal de las actividades del proyecto.

\textbf{Capítulo 4 - Análisis del sistema}: Contiene la especificación
completa de requisitos funcionales y no funcionales, casos de uso,
diagramas UML y criterios de garantía de calidad.

\textbf{Capítulo 5 - Diseño}: Documenta la arquitectura del sistema
tanto a nivel físico como lógico, incluyendo el diseño de la base de
datos y la interfaz de usuario.

\textbf{Capítulo 6 - Implementación}: Detalla los aspectos técnicos de
la implementación, incluyendo la estructura del código, patrones de
diseño utilizados y decisiones de arquitectura.

\textbf{Capítulo 7 - Entrega del producto}: Describe los procesos de
configuración, despliegue y entrega del sistema en entorno de
producción.

\textbf{Capítulo 8 - Procesos de soporte y pruebas}: Documenta las
estrategias de testing, gestión de riesgos y procesos de validación
implementados.

\textbf{Capítulo 9 - Conclusiones y trabajo futuro}: Presenta una
evaluación crítica del proyecto, cumplimiento de objetivos y propuestas
de mejoras futuras.

Los anexos incluyen manuales técnicos de instalación y usuario, así como
documentación adicional de referencia.

\section{Estandarización del
documento}\label{estandarizaciuxf3n-del-documento}

La adopción de estándares reconocidos internacionalmente garantiza la
calidad, consistencia y profesionalidad de la documentación técnica. La
estandarización no solo facilita la comprensión del documento por parte
de diferentes audiencias, sino que también asegura que el proyecto siga
metodologías probadas y reconocidas en el ámbito de la ingeniería de
software.

Este documento ha sido desarrollado siguiendo las directrices del
estándar \textbf{ISO/IEEE 16326:2009} - ``Systems and software
engineering - Life cycle processes - Project management'', adaptado para
proyectos académicos de desarrollo software.

\subsection{Normas aplicadas}\label{normas-aplicadas}

\begin{itemize}
\tightlist
\item
  \textbf{ISO/IEEE 16326:2009}: Estructura principal del documento y
  gestión de proyectos.
\item
  \textbf{IEEE Std 830-1998}: Especificación de requisitos software
  (Capítulo 4).
\item
  \textbf{IEEE Std 1016-2009}: Descripciones de diseño software
  (Capítulo 5).
\item
  \textbf{ISO/IEC 25010:2011}: Modelo de calidad del producto software
  (Capítulo 4.2).
\end{itemize}

\subsection{Convenciones del
documento}\label{convenciones-del-documento}

\textbf{Formato de texto:} - Títulos principales: Numeración decimal
(1., 1.1., 1.1.1.). - Código fuente: Bloques de código con syntax
highlighting. - Términos técnicos: Primera aparición en
\textbf{negrita}. - Acrónimos: MAYÚSCULAS con definición en primera
aparición.

\textbf{Diagramas y figuras:} - Numeración correlativa: Figura 1.1,
Figura 1.2, etc. - Pie de figura descriptivo con fuente cuando
corresponda. - Formato vectorial preferible para diagramas técnicos.

\textbf{Tablas:} - Numeración correlativa: Tabla 1.1, Tabla 1.2, etc. -
Encabezados en negrita. - Alineación consistente según el tipo de
contenido.

\textbf{Referencias:} - Bibliografía al final del documento. - Formato
APA para referencias académicas. - Enlaces web con fecha de acceso.

\section{Acrónimos}\label{acruxf3nimos}

A lo largo de este documento se utilizan diversos acrónimos y
abreviaciones técnicas que son comunes en el ámbito de la ingeniería de
software y el desarrollo web. Esta sección proporciona una referencia
completa de todos los términos abreviados utilizados, facilitando la
comprensión del contenido técnico para lectores con diferentes niveles
de especialización.

Los acrónimos se presentan en orden alfabético, incluyendo tanto
términos en inglés como sus equivalentes en español cuando resulta
apropiado. Esta lista sirve como referencia rápida durante la lectura
del documento.

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.4348}}
  >{\raggedright\arraybackslash}p{(\linewidth - 2\tabcolsep) * \real{0.5652}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
Acrónimo
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Significado
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{API} & Application Programming Interface (Interfaz de
Programación de Aplicaciones) \\
\textbf{CORS} & Cross-Origin Resource Sharing (Intercambio de Recursos
de Origen Cruzado) \\
\textbf{CRUD} & Create, Read, Update, Delete (Crear, Leer, Actualizar,
Eliminar) \\
\textbf{CSS} & Cascading Style Sheets (Hojas de Estilo en Cascada) \\
\textbf{DDEV} & Docker Development Environment \\
\textbf{DOM} & Document Object Model (Modelo de Objetos del
Documento) \\
\textbf{EPL} & Event Processing Language (Lenguaje de Procesamiento de
Eventos) \\
\textbf{HMR} & Hot Module Replacement (Reemplazo de Módulos en
Caliente) \\
\textbf{HTML} & HyperText Markup Language (Lenguaje de Marcado de
Hipertexto) \\
\textbf{HTTP} & HyperText Transfer Protocol (Protocolo de Transferencia
de Hipertexto) \\
\textbf{IEEE} & Institute of Electrical and Electronics Engineers \\
\textbf{ISO} & International Organization for Standardization \\
\textbf{JSON} & JavaScript Object Notation (Notación de Objetos
JavaScript) \\
\textbf{JWT} & JSON Web Token (Token Web JSON) \\
\textbf{LTS} & Long Term Support (Soporte a Largo Plazo) \\
\textbf{MVC} & Model-View-Controller (Modelo-Vista-Controlador) \\
\textbf{ORM} & Object-Relational Mapping (Mapeo Objeto-Relacional) \\
\textbf{PDF} & Portable Document Format (Formato de Documento
Portable) \\
\textbf{PHP} & PHP: Hypertext Preprocessor \\
\textbf{REST} & Representational State Transfer (Transferencia de Estado
Representacional) \\
\textbf{RTL} & React Testing Library \\
\textbf{SPA} & Single Page Application (Aplicación de Página Única) \\
\textbf{SQL} & Structured Query Language (Lenguaje de Consulta
Estructurado) \\
\textbf{TFG} & Trabajo de Fin de Grado \\
\textbf{UI} & User Interface (Interfaz de Usuario) \\
\textbf{UML} & Unified Modeling Language (Lenguaje de Modelado
Unificado) \\
\textbf{URL} & Uniform Resource Locator (Localizador Uniforme de
Recursos) \\
\textbf{UX} & User Experience (Experiencia de Usuario) \\
\end{longtable}

\section{Definiciones}\label{definiciones}

Esta sección presenta las definiciones de los conceptos técnicos y
términos especializados más relevantes utilizados a lo largo del
proyecto.. Estas definiciones han sido elaboradas específicamente en el
contexto de la plataforma de gestión de TFG desarrollada, proporcionando
claridad sobre el significado y uso de cada término.

La comprensión de estos conceptos es fundamental para entender tanto la
arquitectura técnica como las funcionalidades del sistema implementado.
Cada definición incluye el contexto específico de aplicación dentro del
proyecto.

\textbf{Backend}: Conjunto de tecnologías y servicios del lado del
servidor que procesan la lógica de negocio, gestionan la base de datos y
proporcionan APIs para el frontend.

\textbf{Bundle}: En el contexto de Symfony, un bundle es un plugin que
agrupa código relacionado (controladores, servicios, configuración) en
una unidad reutilizable.

\textbf{Componente React}: Función o clase de JavaScript que retorna
elementos JSX y encapsula lógica de interfaz de usuario reutilizable.

\textbf{Context API}: Sistema de gestión de estado global de React que
permite compartir datos entre componentes sin necesidad de pasar props
manualmente a través del árbol de componentes.

\textbf{Custom Hook}: Función JavaScript que comienza con ``use'' y
permite extraer y reutilizar lógica de estado entre múltiples
componentes React.

\textbf{Defensa de TFG}: Acto académico en el cual el estudiante
presenta oralmente su Trabajo de Fin de Grado ante un tribunal evaluador
para su calificación final.

\textbf{Doctrine ORM}: Herramienta de mapeo objeto-relacional para PHP
que proporciona una capa de abstracción para interactuar con bases de
datos relacionales.

\textbf{Endpoint}: URL específica de una API REST que acepta peticiones
HTTP y devuelve respuestas estructuradas, representando un recurso o
acción del sistema.

\textbf{Frontend}: Parte de la aplicación web que se ejecuta en el
navegador del usuario, responsable de la interfaz de usuario y la
interacción directa con el usuario final.

\textbf{Hot Module Replacement (HMR)}: Tecnología de desarrollo que
permite actualizar módulos de código en tiempo real sin perder el estado
de la aplicación.

\textbf{Middleware}: Función que se ejecuta durante el ciclo de vida de
una petición HTTP, permitiendo modificar la petición o respuesta antes
de llegar al destino final.

\textbf{Migración de Base de Datos}: Script que modifica la estructura
de la base de datos de manera versionada, permitiendo evolucionar el
esquema de datos de forma controlada.

\textbf{Monorepo}: Estrategia de organización de código donde múltiples
proyectos relacionados (frontend, backend) se almacenan en un único
repositorio Git.

\textbf{Props}: Abreviación de ``properties'', son argumentos que se
pasan a los componentes React para configurar su comportamiento y
apariencia.

\textbf{Protected Route}: Ruta de la aplicación que requiere
autenticación y/o autorización específica para ser accedida,
implementando control de acceso basado en roles.

\textbf{Responsive Design}: Enfoque de diseño web que permite que las
interfaces se adapten automáticamente a diferentes tamaños de pantalla y
dispositivos.

\textbf{Serialización}: Proceso de convertir objetos de programación en
formatos de intercambio de datos como JSON o XML para transmisión o
almacenamiento.

\textbf{State Management}: Gestión del estado de la aplicación,
refiriéndose a cómo se almacenan, actualizan y comparten los datos entre
diferentes partes de la aplicación.

\textbf{Token de Acceso}: Credencial digital temporal que permite a un
usuario autenticado acceder a recursos protegidos de la aplicación sin
necesidad de reenviar credenciales.

\textbf{Tribunal de TFG}: Comisión evaluadora compuesta por profesores
académicos (presidente, secretario y vocal) responsable de evaluar y
calificar las defensas de TFG.

\textbf{Utility-First CSS}: Metodología de CSS que utiliza clases
pequeñas y específicas para construir interfaces, característica
principal de frameworks como Tailwind CSS.

\textbf{Validación del lado del servidor}: Proceso de verificación y
sanitización de datos recibidos en el backend antes de su procesamiento
o almacenamiento.

\textbf{Virtual DOM}: Representación en memoria de la estructura DOM
real que permite a React calcular eficientemente los cambios mínimos
necesarios para actualizar la interfaz.

\chapter{Contexto del proyecto}\label{contexto-del-proyecto}
En este capítulo se describe el contexto del proyecto desarrollado,
necesario de conocer antes de abordar la planificación del mismo y, por
supuesto, antes de comenzar con el desarrollo. Se presentará una
descripción general del proyecto, se realizará un análisis detallado de
las características de los usuarios del sistema, se justificará el
modelo de ciclo de vida elegido para el desarrollo, y se enumerarán,
dando una breve explicación de en qué consisten, las tecnologías, los
lenguajes y las herramientas seleccionadas para el proyecto.

El conocimiento del contexto tecnológico y metodológico es fundamental
para comprender las decisiones de diseño y arquitectura adoptadas. Este
capítulo establece las bases técnicas sobre las cuales se sustenta todo
el desarrollo posterior, proporcionando la justificación de las
elecciones tecnológicas y metodológicas realizadas.

\section{Descripción general del
proyecto}\label{descripciuxf3n-general-del-proyecto}

La Plataforma de Gestión de TFG es un sistema web integral diseñado para
automatizar y optimizar el ciclo completo de gestión de Trabajos de Fin
de Grado en entornos universitarios.. El sistema implementa una
arquitectura moderna basada en tecnologías web actuales, proporcionando
una solución escalable que aborda las necesidades específicas de cuatro
tipos de usuarios diferenciados.

La plataforma gestiona el flujo completo del proceso académico, desde la
creación inicial del TFG por parte del estudiante hasta la calificación
final tras la defensa ante el tribunal. El sistema implementa un modelo
de estados bien definido (Borrador → En Revisión → Aprobado → Defendido)
que garantiza la trazabilidad y el cumplimiento de los procedimientos
académicos establecidos.

La arquitectura del sistema se basa en un patrón de separación de
responsabilidades, donde el frontend desarrollado en React 19 se encarga
de la presentación e interacción con el usuario, mientras que el backend
implementado en Symfony 6.4 LTS gestiona la lógica de negocio, la
persistencia de datos y la seguridad del sistema. Esta separación
permite una mayor flexibilidad, escalabilidad y mantenibilidad del
código.

El sistema incorpora funcionalidades avanzadas como un calendario
interactivo para la programación de defensas, un sistema de
notificaciones en tiempo real, gestión segura de archivos PDF, y un
completo panel administrativo con capacidades de reporting y exportación
de datos.

\section{Características del
usuario}\label{caracteruxedsticas-del-usuario}

La identificación y caracterización precisa de los usuarios del sistema
constituye un elemento fundamental para el diseño de una plataforma
efectiva y usable.. El análisis detallado de los perfiles de usuario
permite definir funcionalidades específicas, interfaces adaptadas y
flujos de trabajo optimizados para cada rol dentro del proceso
académico.

El sistema ha sido diseñado para satisfacer las necesidades específicas
de cuatro perfiles de usuario claramente diferenciados, cada uno con
roles, permisos y flujos de trabajo particulares. Esta segmentación
permite una experiencia de usuario personalizada que maximiza la
eficiencia operativa de cada actor en el proceso de gestión de TFG.

\subsection{Estudiante}\label{estudiante}

\textbf{Perfil}: Estudiante universitario en proceso de realización de
su Trabajo de Fin de Grado, con conocimientos básicos de tecnologías web
y experiencia en el uso de plataformas académicas digitales.

\textbf{Responsabilidades principales}: - Creación y actualización de la
información básica del TFG (título, resumen, palabras clave). - Subida y
gestión de archivos PDF con el contenido del trabajo. - Seguimiento del
estado de progreso de su TFG a través del sistema. - Consulta de
comentarios y feedback proporcionado por el tutor. - Visualización de
información relacionada con la defensa (fecha, tribunal, aula). -
Recepción y gestión de notificaciones sobre cambios de estado.

\textbf{Competencias técnicas esperadas}: - Manejo básico de navegadores
web y formularios online. - Capacidad para subir y descargar archivos. -
Comprensión de conceptos básicos de gestión documental digital. -
Familiaridad con herramientas de notificación electrónica.

\subsection{Profesor/Tutor}\label{profesortutor}

\textbf{Perfil}: Docente universitario con experiencia en dirección de
TFG, responsable de la supervisión académica y evaluación de trabajos
asignados.

\textbf{Responsabilidades principales}: - Supervisión y seguimiento del
progreso de TFG asignados. - Revisión y evaluación de documentos subidos
por estudiantes. - Provisión de feedback estructurado mediante sistema
de comentarios. - Gestión de cambios de estado de TFG (aprobación para
defensa). - Participación en tribunales de evaluación como miembro. -
Coordinación con otros miembros del tribunal para programación de
defensas.

\textbf{Competencias técnicas esperadas}: - Experiencia en evaluación de
trabajos académicos. - Manejo avanzado de herramientas digitales de
gestión académica. - Capacidad para proporcionar feedback constructivo a
través de plataformas digitales. - Comprensión de flujos de trabajo
colaborativos online.

\subsection{Presidente del Tribunal}\label{presidente-del-tribunal}

\textbf{Perfil}: Profesor universitario con experiencia avanzada en
evaluación académica, responsable de liderar tribunales de evaluación y
coordinar el proceso de defensas.

\textbf{Responsabilidades principales}: - Creación y configuración de
tribunales de evaluación. - Asignación de miembros de tribunal y
distribución de responsabilidades. - Programación de fechas y horarios
de defensas utilizando el calendario integrado. - Coordinación de
disponibilidad entre miembros del tribunal. - Supervisión del proceso de
evaluación y calificación. - Generación de actas de defensa y
documentación oficial.

\textbf{Competencias técnicas esperadas}: - Experiencia avanzada en
gestión de procesos académicos. - Capacidad de liderazgo y coordinación
de equipos de trabajo. - Manejo experto de herramientas de calendario y
programación. - Comprensión de procedimientos administrativos
universitarios.

\subsection{Administrador}\label{administrador}

\textbf{Perfil}: Personal técnico o administrativo responsable de la
gestión global del sistema, con conocimientos avanzados en
administración de plataformas web y gestión de usuarios.

\textbf{Responsabilidades principales}: - Gestión completa del catálogo
de usuarios del sistema (CRUD). - Asignación y modificación de roles y
permisos de acceso. - Generación de reportes estadísticos y analíticos
del sistema. - Exportación de datos en múltiples formatos (PDF, Excel).
- Configuración y mantenimiento de parámetros del sistema. - Supervisión
del funcionamiento general de la plataforma.

\textbf{Competencias técnicas esperadas}: - Experiencia avanzada en
administración de sistemas web. - Conocimientos en gestión de bases de
datos y reportes. - Capacidad analítica para interpretación de
estadísticas. - Comprensión de conceptos de seguridad y gestión de
accesos.

\section{Modelo de ciclo de vida}\label{modelo-de-ciclo-de-vida}

La selección del modelo de ciclo de vida adecuado es una decisión
estratégica que determina la estructura, organización y metodología de
todo el proceso de desarrollo.. Esta elección impacta directamente en la
gestión de riesgos, la capacidad de adaptación a cambios y la entrega de
valor a lo largo del proyecto.

El desarrollo de la plataforma sigue un \textbf{modelo de ciclo de vida
iterativo incremental}, estructurado en ocho fases bien definidas que
permiten la entrega progresiva de funcionalidades y la validación
continua de los requisitos. Este enfoque facilita la identificación
temprana de problemas, permite ajustes metodológicos y garantiza que
cada incremento del sistema aporte valor tangible al producto final.

\subsection{Metodología de
desarrollo}\label{metodologuxeda-de-desarrollo}

\textbf{Enfoque adoptado}: El proyecto implementa una metodología ágil
adaptada al contexto académico, combinando elementos de Scrum para la
gestión iterativa con prácticas de desarrollo incremental que permiten
la entrega de valor en cada fase.

\textbf{Justificación de la metodología}: - \textbf{Flexibilidad}:
Permite adaptarse a cambios de requisitos durante el desarrollo. -
\textbf{Validación temprana}: Cada fase entrega funcionalidades
operativas. - \textbf{Gestión de riesgos}: Identificación y mitigación
progresiva de problemas técnicos. - \textbf{Feedback continuo}:
Posibilidad de ajustes basados en evaluación de fases anteriores.

\subsection{Fases del proyecto}\label{fases-del-proyecto}

\textbf{Fase 1-2: Fundación del sistema (Semanas 1-2)} - Configuración
del entorno de desarrollo. - Implementación del sistema de ruteo y
navegación. - Desarrollo del sistema de autenticación básico. -
Establecimiento de la arquitectura de componentes React.

\textbf{Fase 3: Módulo de estudiante (Semanas 3-4)} - Implementación
completa de funcionalidades para estudiantes. - Sistema de subida y
gestión de archivos. - Interfaces de seguimiento de estado de TFG. -
Integración con sistema de notificaciones.

\textbf{Fase 4: Módulo de profesor (Semanas 4-5)} - Desarrollo de
herramientas de supervisión para tutores. - Sistema de feedback y
comentarios estructurados. - Interfaces de gestión de TFG asignados. -
Integración con flujos de aprobación.

\textbf{Fase 5: Sistema de defensas (Semanas 5-6)} - Implementación del
calendario interactivo con FullCalendar.js. - Sistema de gestión de
tribunales. - Programación y coordinación de defensas. - Gestión de
disponibilidad de miembros de tribunal.

\textbf{Fase 6: Panel administrativo (Semanas 6-7)} - Sistema completo
de gestión de usuarios (CRUD). - Generación de reportes y estadísticas
avanzadas. - Funcionalidades de exportación de datos. - Configuración
global del sistema.

\textbf{Fase 7: Backend Symfony (Semanas 7-9)} - Implementación completa
del backend con Symfony 6.4 LTS. - Desarrollo de APIs REST con API
Platform. - Sistema de autenticación JWT con refresh tokens. - Migración
de datos desde sistema mock a base de datos MySQL.

\textbf{Fase 8: Pulimiento final (Semanas 9-10)} - Testing exhaustivo
(unitario, integración y E2E). - Optimización de rendimiento. -
Configuración de despliegue en producción. - Documentación técnica y
manuales de usuario.

\subsection{Criterios de finalización de
fase}\label{criterios-de-finalizaciuxf3n-de-fase}

Cada fase debe cumplir criterios específicos antes de proceder a la
siguiente:

\begin{itemize}
\tightlist
\item
  \textbf{Funcionalidades completas}: Todas las características
  planificadas operativas.
\item
  \textbf{Testing básico}: Pruebas unitarias y de integración
  implementadas.
\item
  \textbf{Documentación actualizada}: Registro de cambios y decisiones
  técnicas.
\item
  \textbf{Validación de requisitos}: Confirmación de cumplimiento de
  objetivos de fase.
\end{itemize}

\section{Tecnologías}\label{tecnologuxedas}

La elección de las tecnologías apropiadas constituye uno de los aspectos
más críticos en el desarrollo de cualquier sistema software. Estas
decisiones tecnológicas impactan directamente en la escalabilidad,
mantenibilidad, rendimiento y viabilidad a largo plazo del proyecto. En
esta sección se detallan las principales tecnologías utilizadas,
explicando las razones de su selección y cómo contribuyen al
cumplimiento de los objetivos del sistema.

La selección tecnológica se basa en criterios de modernidad,
estabilidad, escalabilidad y soporte de la comunidad, priorizando
tecnologías con soporte a largo plazo y ecosistemas maduros. Cada
tecnología elegida ha sido evaluada considerando su compatibilidad con
el resto del stack tecnológico y su capacidad para satisfacer los
requisitos específicos del proyecto.

\subsection{React 19}\label{react-19}

React 19 constituye la biblioteca principal para el desarrollo del
frontend de la aplicación, proporcionando un marco de trabajo robusto
para la construcción de interfaces de usuario interactivas y componentes
reutilizables.

\textbf{Características principales utilizadas}: - \textbf{Componentes
funcionales con hooks}: Implementación moderna que permite gestión de
estado y efectos secundarios de manera declarativa. - \textbf{Context
API}: Sistema de gestión de estado global que evita el prop drilling y
centraliza información crítica como autenticación y notificaciones. -
\textbf{Suspense y lazy loading}: Optimización de carga de componentes
para mejorar el rendimiento percibido por el usuario. -
\textbf{Concurrent features}: Aprovechamiento de las nuevas
características de renderizado concurrente para mejorar la responsividad
de la aplicación.

\textbf{Ventajas para el proyecto}: - \textbf{Ecosistema maduro}: Amplia
disponibilidad de librerías y componentes de terceros. -
\textbf{Rendimiento optimizado}: Virtual DOM y algoritmos de
reconciliación eficientes. - \textbf{Curva de aprendizaje}:
Documentación extensa y comunidad activa. - \textbf{Compatibilidad}:
Excelente integración con herramientas de desarrollo y testing.

\subsection{Symfony 6.4 LTS}\label{symfony-6.4-lts}

Symfony 6.4 LTS se utiliza como framework principal para el desarrollo
del backend, proporcionando una arquitectura sólida basada en
componentes modulares y principios de desarrollo empresarial.

\textbf{Componentes principales utilizados}: - \textbf{Symfony
Security}: Gestión de autenticación, autorización y control de acceso
basado en roles. - \textbf{Doctrine ORM}: Mapeo objeto-relacional para
interacción con la base de datos MySQL. - \textbf{Symfony Serializer}:
Transformación de objetos PHP a JSON para APIs REST. - \textbf{Symfony
Mailer}: Sistema de envío de notificaciones por correo electrónico. -
\textbf{Symfony Messenger}: Gestión de colas de mensajes para
procesamiento asíncrono.

\textbf{Ventajas para el proyecto}: - \textbf{Long Term Support}:
Garantía de soporte y actualizaciones de seguridad hasta 2027. -
\textbf{Arquitectura modular}: Flexibilidad para utilizar únicamente los
componentes necesarios. - \textbf{Rendimiento}: Optimizaciones internas
y opcache de PHP para alta eficiencia. - \textbf{Estándares PSR}:
Cumplimiento de estándares de la comunidad PHP.

\subsection{MySQL 8.0}\label{mysql-8.0}

MySQL 8.0 actúa como sistema de gestión de base de datos relacional,
proporcionando persistencia segura y eficiente para todos los datos del
sistema.

\textbf{Características utilizadas}: - \textbf{JSON data type}:
Almacenamiento nativo de datos JSON para metadatos flexibles (roles,
palabras clave). - \textbf{Window functions}: Consultas analíticas
avanzadas para generación de reportes. - \textbf{Common Table
Expressions (CTE)}: Consultas recursivas para jerarquías de datos. -
\textbf{Performance Schema}: Monitorización y optimización de consultas.

\textbf{Ventajas para el proyecto}: - \textbf{Fiabilidad}: Sistema
probado en entornos de producción exigentes. - \textbf{ACID compliance}:
Garantías de consistencia e integridad de datos. -
\textbf{Escalabilidad}: Capacidad de crecimiento horizontal y vertical.
- \textbf{Herramientas}: Ecosistema rico de herramientas de
administración y monitorización.

\subsection{API Platform 3.x}\label{api-platform-3.x}

API Platform 3.x se utiliza para la generación automática de APIs REST,
proporcionando funcionalidades avanzadas de serialización, documentación
y validación..

\textbf{Funcionalidades implementadas}: - \textbf{Auto-documentación
OpenAPI}: Generación automática de documentación interactiva -
\textbf{Serialización contextual}: Control granular de qué datos exponer
según el contexto - \textbf{Validación automática}: Integración con
Symfony Validator para validación de datos - \textbf{Filtrado y
paginación}: Capacidades de consulta avanzada desde el frontend

\textbf{Ventajas para el proyecto}: - \textbf{Desarrollo rápido}:
Reducción significativa del tiempo de implementación de APIs -
\textbf{Estándares REST}: Cumplimiento automático de convenciones REST -
\textbf{Testing integrado}: Herramientas incorporadas para testing de
APIs - \textbf{Documentación viva}: Documentación siempre actualizada
automáticamente

\subsection{JWT Authentication
(LexikJWTAuthenticationBundle)}\label{jwt-authentication-lexikjwtauthenticationbundle}

La autenticación JWT proporciona un sistema de seguridad stateless,
escalable y moderno para el control de acceso a la aplicación.

\textbf{Implementación específica}: - \textbf{Access tokens}: Tokens de
corta duración (1 hora) para operaciones sensibles - \textbf{Refresh
tokens}: Tokens de larga duración (30 días) para renovación automática -
\textbf{Role-based claims}: Información de roles embebida en el payload
del token. - \textbf{Algoritmo RS256}: Firma asimétrica para máxima
seguridad.

\textbf{Ventajas para el proyecto}: - \textbf{Stateless}: No requiere
almacenamiento de sesiones en el servidor. - \textbf{Escalabilidad}:
Compatible con arquitecturas distribuidas. - \textbf{Seguridad}:
Resistente a ataques CSRF y compatible con HTTPS. -
\textbf{Interoperabilidad}: Estándar soportado por múltiples
plataformas.

\subsection{FullCalendar.js}\label{fullcalendar.js}

FullCalendar.js proporciona la funcionalidad de calendario interactivo
para la gestión visual de defensas y programación de eventos
académicos..

\textbf{Características implementadas}: - \textbf{Múltiples vistas}:
Mensual, semanal y diaria para diferentes niveles de detalle -
\textbf{Drag \& drop}: Capacidad de reprogramación intuitiva de defensas
- \textbf{Event rendering}: Personalización visual según estado y tipo
de defensa - \textbf{Responsive design}: Adaptación automática a
dispositivos móviles

\textbf{Ventajas para el proyecto}: - \textbf{UX avanzada}: Interfaz
familiar y intuitiva para usuarios - \textbf{Integración React}: Wrapper
nativo para React con hooks personalizados - \textbf{Personalización}:
Amplia capacidad de customización visual y funcional -
\textbf{Rendimiento}: Optimizado para manejar grandes cantidades de
eventos

\subsection{Tailwind CSS v4}\label{tailwind-css-v4}

Tailwind CSS v4 actúa como framework de estilos utility-first,
proporcionando un sistema de diseño consistente y eficiente para toda la
aplicación.

\textbf{Metodología de implementación}: - \textbf{Utility-first
approach}: Construcción de interfaces mediante clases utilitarias -
\textbf{Design system}: Paleta de colores, tipografías y espaciado
sistemático - \textbf{Responsive design}: Breakpoints móvil-first para
adaptación multi-dispositivo - \textbf{Dark mode support}: Preparación
para futuras implementaciones de tema oscuro

\textbf{Ventajas para el proyecto}: - \textbf{Desarrollo rápido}:
Reducción significativa del tiempo de maquetación -
\textbf{Consistencia}: Sistema de diseño unificado en toda la aplicación
- \textbf{Optimización}: Purge automático de CSS no utilizado -
\textbf{Mantenibilidad}: Estilos co-localizados con componentes

\subsection{DDEV}\label{ddev}

DDEV proporciona un entorno de desarrollo containerizado que garantiza
consistencia entre diferentes máquinas de desarrollo y facilita el
onboarding de nuevos desarrolladores.

\textbf{Configuración específica}: - \textbf{PHP 8.2}: Versión
específica con extensiones requeridas para Symfony - \textbf{MySQL 8.0}:
Base de datos con configuración optimizada para desarrollo -
\textbf{Nginx}: Servidor web con configuración para SPA y APIs -
\textbf{PHPMyAdmin}: Interface web para administración de base de datos

\textbf{Ventajas para el proyecto}: - \textbf{Consistencia}: Entorno
idéntico independientemente del sistema operativo host -
\textbf{Facilidad de setup}: Configuración automática con un comando -
\textbf{Aislamiento}: Contenedores aislados que no interfieren con el
sistema host - \textbf{Productividad}: Herramientas de desarrollo
integradas y optimizadas

\section{Lenguajes}\label{lenguajes}

Los lenguajes de programación seleccionados para el desarrollo de la
plataforma han sido elegidos considerando su madurez, rendimiento,
ecosistema de desarrollo y compatibilidad con las tecnologías del stack
principal. Esta sección detalla las características específicas
utilizadas de cada lenguaje y los patrones de programación aplicados.

\subsection{JavaScript/TypeScript}\label{javascripttypescript}

JavaScript se utiliza como lenguaje principal para el desarrollo del
frontend, aprovechando las características modernas de ECMAScript 2023 y
preparado para migración incremental a TypeScript..

\textbf{Características del lenguaje utilizadas}: - \textbf{ES6+
features}: Destructuring, arrow functions, template literals,
async/await - \textbf{Módulos ES6}: Sistema de importación/exportación
modular - \textbf{Promises y async/await}: Gestión asíncrona moderna
para llamadas a APIs - \textbf{Optional chaining}: Acceso seguro a
propiedades de objetos anidados

\textbf{Patrones de programación aplicados}: - \textbf{Programación
funcional}: Uso extensivo de map, filter, reduce para transformación de
datos - \textbf{Immutability}: Evitar mutaciones directas de estado para
mayor predictibilidad - \textbf{Composition over inheritance}:
Composición de funcionalidades mediante custom hooks -
\textbf{Declarative programming}: Enfoque declarativo en lugar de
imperativo

\subsection{PHP 8.2+}\label{php-8.2}

PHP 8.2+ actúa como lenguaje de backend, aprovechando las mejoras de
rendimiento y características de tipado fuerte introducidas en versiones
recientes.

\textbf{Características modernas utilizadas}: - \textbf{Typed
properties}: Declaración explícita de tipos para propiedades de clase -
\textbf{Union types}: Flexibilidad en declaración de tipos múltiples -
\textbf{Named arguments}: Llamadas a funciones más expresivas y
mantenibles - \textbf{Match expressions}: Alternativa moderna y
expresiva a switch statements - \textbf{Attributes}: Metadatos
declarativos para configuración de componentes

\textbf{Principios de programación aplicados}: - \textbf{SOLID
principles}: Diseño orientado a objetos siguiendo principios de
responsabilidad única, abierto/cerrado, etc. - \textbf{Dependency
injection}: Inversión de control para mayor testabilidad - \textbf{PSR
standards}: Cumplimiento de estándares de la comunidad PHP -
\textbf{Domain-driven design}: Organización del código según dominios de
negocio

\subsection{SQL}\label{sql}

SQL se utiliza para definición de esquemas de base de datos, consultas
complejas y procedimientos de migración, aprovechando características
avanzadas de MySQL 8.0.

\textbf{Características SQL utilizadas}: - \textbf{DDL avanzado}:
Definición de esquemas con constraints, índices y relaciones complejas -
\textbf{Queries analíticas}: Window functions para reportes estadísticos
- \textbf{JSON functions}: Manipulación nativa de campos JSON en MySQL -
\textbf{Stored procedures}: Lógica de negocio crítica ejecutada
directamente en base de datos

\subsection{HTML/CSS}\label{htmlcss}

HTML5 y CSS3 proporcionan la estructura semántica y presentación visual
de la aplicación, siguiendo estándares web modernos y mejores prácticas
de accesibilidad.

\textbf{Estándares aplicados}: - \textbf{Semantic HTML}: Uso de
elementos semánticos para mejor SEO y accesibilidad - \textbf{ARIA
attributes}: Mejoras de accesibilidad para usuarios con discapacidades -
\textbf{CSS Grid y Flexbox}: Sistemas de layout modernos para interfaces
complejas - \textbf{CSS Custom Properties}: Variables CSS para theming y
mantenibilidad

\section{Herramientas}\label{herramientas}

La selección apropiada de herramientas de desarrollo, testing y gestión
de proyecto constituye un factor determinante en la productividad y
calidad del desarrollo software. Las herramientas elegidas deben
integrarse eficientemente entre sí, proporcionando un flujo de trabajo
fluido que minimice la fricción y maximice la capacidad de desarrollo y
debugging.

En esta sección se detallan las principales herramientas utilizadas
durante el ciclo de vida del proyecto, explicando su configuración
específica y las ventajas que aportan al proceso de desarrollo de la
plataforma.

\subsection{Visual Studio Code}\label{visual-studio-code}

VS Code actúa como IDE principal de desarrollo, configurado con
extensiones específicas para el stack tecnológico del proyecto..

\textbf{Extensiones críticas configuradas}: - \textbf{ES7+
React/Redux/React-Native snippets}: Acelera el desarrollo de componentes
React - \textbf{PHP Intelephense}: IntelliSense avanzado para desarrollo
PHP y Symfony - \textbf{Tailwind CSS IntelliSense}: Autocompletado y
validación de clases Tailwind - \textbf{GitLens}: Herramientas avanzadas
de control de versiones Git - \textbf{Thunder Client}: Cliente REST
integrado para testing de APIs - \textbf{Error Lens}: Visualización
inline de errores y warnings

\textbf{Configuración del workspace}: - \textbf{Settings compartidos}:
Configuración unificada para formato, linting y comportamiento -
\textbf{Debugging configurado}: Breakpoints para PHP (Xdebug) y
JavaScript - \textbf{Task automation}: Scripts automatizados para
comandos frecuentes - \textbf{Multi-root workspace}: Gestión simultánea
de frontend y backend

\subsection{Vite}\label{vite}

Vite se utiliza como build tool y servidor de desarrollo para el
frontend, proporcionando una experiencia de desarrollo optimizada con
Hot Module Replacement..

\textbf{Configuración específica}: - \textbf{HMR optimizado}: Recarga
instantánea de componentes modificados - \textbf{Build optimization}:
Tree shaking, code splitting y optimización de assets - \textbf{Proxy
configuration}: Configuración de proxy para APIs durante desarrollo -
\textbf{Environment variables}: Gestión de variables de entorno por
ambiente

\textbf{Plugins utilizados}: - \textbf{@vitejs/plugin-react}: Soporte
completo para React y JSX - \textbf{vite-plugin-eslint}: Integración de
ESLint en tiempo de desarrollo - \textbf{vite-plugin-pwa}: Preparación
para futuras funcionalidades PWA

\subsection{Composer}\label{composer}

Composer gestiona las dependencias PHP del backend, garantizando
versiones consistentes y resolución automática de dependencias..

\textbf{Configuración específica}: - \textbf{Lock file}: Versiones
exactas para despliegues reproducibles - \textbf{Autoloading PSR-4}:
Carga automática de clases siguiendo estándares - \textbf{Scripts
personalizados}: Comandos automatizados para testing y despliegue -
\textbf{Platform requirements}: Especificación de versiones mínimas de
PHP y extensiones

\subsection{Docker / DDEV}\label{docker-ddev}

Docker proporciona containerización del entorno de desarrollo, mientras
DDEV ofrece una capa de abstracción específica para desarrollo web.

\textbf{Servicios configurados}: - \textbf{Web container}: PHP-FPM con
Nginx para servir la aplicación Symfony - \textbf{Database container}:
MySQL 8.0 con configuración optimizada para desarrollo -
\textbf{PHPMyAdmin}: Interface web para administración de base de datos
- \textbf{Mailpit}: Servidor SMTP local para testing de emails

\subsection{Git / GitHub}\label{git-github}

Git actúa como sistema de control de versiones, con GitHub
proporcionando hosting remoto, colaboración y herramientas de CI/CD..

\textbf{Workflow configurado}: - \textbf{Feature branches}: Desarrollo
aislado de funcionalidades - \textbf{Conventional commits}: Estándar de
mensajes de commit para changelog automático - \textbf{Pull requests}:
Code review obligatorio antes de merge - \textbf{GitHub Actions}: CI/CD
automatizado para testing y despliegue

\subsection{Postman / Insomnia}\label{postman-insomnia}

Herramientas de testing de APIs REST que permiten validación exhaustiva
de endpoints durante el desarrollo y documentación de casos de uso..

\textbf{Configuración de testing}: - \textbf{Collections organizadas}:
Agrupación de endpoints por funcionalidad - \textbf{Environment
variables}: Configuración para diferentes ambientes (dev, staging, prod)
- \textbf{Test scripts}: Validación automática de respuestas y status
codes - \textbf{Documentation generation}: Generación automática de
documentación de API

\chapter{Planificación}\label{planificaciuxf3n}
En este capítulo se describirá la planificación seguida durante el
desarrollo del proyecto, abordando desde la iniciación hasta la
finalización del mismo. Se presentará el enfoque metodológico adoptado,
la estructuración en fases iterativas, y la gestión temporal del
proyecto.

Como se comentó en el capítulo anterior, para el proyecto se ha
utilizado un modelo de ciclo de vida iterativo incremental. Esto implica
que el proceso de desarrollo se ha dividido en una serie de iteraciones
bien definidas, donde en cada una de las iteraciones se han abordado
todas las etapas del desarrollo de un producto software: análisis,
diseño, implementación y pruebas. Además, paralelamente a la ejecución
de cada iteración, se ha ido documentando todo lo realizado en la
presente memoria.

La planificación adecuada constituye el fundamento para el éxito de
cualquier proyecto de desarrollo software, especialmente en proyectos
académicos donde la gestión eficiente del tiempo es crítica. A través de
este capítulo se establecerán las bases metodológicas que han guiado
todo el proceso de desarrollo.

\section{Iniciación del proyecto}\label{iniciaciuxf3n-del-proyecto}

\subsection{Contexto de inicio}\label{contexto-de-inicio}

El proyecto ``Plataforma de Gestión de TFG'' se inicia como respuesta a
la necesidad identificada en el entorno académico universitario de
modernizar y automatizar los procesos de gestión de Trabajos de Fin de
Grado. La iniciación formal del proyecto tuvo lugar tras un análisis
preliminar de los procesos existentes y la identificación de
oportunidades de mejora significativas en la eficiencia y trazabilidad
del proceso académico.

La decisión de desarrollo se basó en tres factores críticos: la
disponibilidad de tecnologías web modernas que permiten desarrollo
rápido y escalable, la experiencia previa en desarrollo full-stack con
React y PHP, y la posibilidad de crear una solución integral que abarque
todos los roles involucrados en el proceso de TFG.

\subsection{Análisis de viabilidad}\label{anuxe1lisis-de-viabilidad}

\textbf{Viabilidad técnica}: El proyecto presenta alta viabilidad
técnica dado que utiliza tecnologías consolidadas y ampliamente
documentadas. React 19 y Symfony 6.4 LTS proporcionan ecosistemas
maduros con extensas comunidades de soporte. La arquitectura propuesta
(frontend SPA + backend API) es un patrón arquitectónico probado y
escalable.

\textbf{Viabilidad temporal}: Con una planificación de 10 semanas
distribuidas en 8 fases iterativas, el cronograma permite desarrollo
incremental con entregas funcionales progresivas. La experiencia previa
en las tecnologías seleccionadas reduce significativamente los riesgos
de desviación temporal.

\textbf{Viabilidad de recursos}: El proyecto requiere únicamente
recursos de desarrollo software y herramientas open-source o de libre
acceso educativo. El entorno DDEV containerizado garantiza consistencia
independientemente del hardware de desarrollo disponible.

\subsection{Definición del alcance
inicial}\label{definiciuxf3n-del-alcance-inicial}

El alcance inicial se estableció mediante la definición de requisitos
mínimos viables (MVP) para cada rol de usuario:

\begin{itemize}
\tightlist
\item
  \textbf{Estudiante}: Subida de TFG, seguimiento de estado,
  visualización de feedback.
\item
  \textbf{Profesor}: Gestión de TFG asignados, sistema de comentarios,
  cambios de estado.
\item
  \textbf{Presidente de Tribunal}: Creación de tribunales, programación
  de defensas.
\item
  \textbf{Administrador}: Gestión de usuarios, reportes básicos,
  configuración del sistema.
\end{itemize}

Esta definición de MVP permite validación temprana de hipótesis y ajuste
incremental de funcionalidades según feedback obtenido.

\section{Iteraciones del proceso de
desarrollo}\label{iteraciones-del-proceso-de-desarrollo}

La metodología iterativa incremental adoptada para el proyecto se
materializa a través de ocho fases claramente diferenciadas, cada una
con objetivos específicos, criterios de aceptación bien definidos y
entregables funcionales. Esta aproximación permite una gestión eficiente
de la complejidad del sistema, facilitando la validación continua y la
adaptación a cambios de requisitos.

El desarrollo se estructura en iteraciones que siguen un patrón
consistente: análisis de requisitos específicos, diseño de componentes,
implementación, testing básico y validación funcional. Cada iteración
entrega valor funcional acumulativo y prepara la base para la siguiente
fase. Esta estructuración garantiza que al final de cada fase se
disponga de un producto parcialmente funcional que puede ser evaluado y
validado antes de proceder con el desarrollo posterior.

\subsection{Fase 1-2: Setup inicial y autenticación (Semanas
1-2)}\label{fase-1-2-setup-inicial-y-autenticaciuxf3n-semanas-1-2}

\textbf{Objetivos de la fase}: - Establecer la arquitectura base del
proyecto frontend. - Implementar sistema de routing con protección por
roles. - Desarrollar sistema de autenticación mock funcional. -
Configurar herramientas de desarrollo y linting.

\textbf{Actividades principales}:

\emph{Semana 1: Configuración del entorno} - Inicialización del proyecto
React con Vite. - Configuración de Tailwind CSS v4 y sistema de diseño
base. - Setup de ESLint, Prettier y herramientas de calidad de código. -
Implementación de componentes básicos de Layout y navegación.

\emph{Semana 2: Sistema de autenticación} - Desarrollo del AuthContext
para gestión de estado global. - Implementación de componentes de login
y registro. - Creación del sistema ProtectedRoute con validación de
roles. - Configuración de persistencia en localStorage. - Testing básico
de flujos de autenticación.

\textbf{Entregables}: - Aplicación React funcional con navegación por
roles. - Sistema de autenticación mock operativo. - Arquitectura de
componentes establecida. - Documentación de decisiones técnicas
iniciales.

\textbf{Criterios de aceptación}: - Los cuatro tipos de usuario pueden
autenticarse exitosamente. - Las rutas están protegidas según el rol del
usuario. - La interfaz es responsive y sigue el sistema de diseño
establecido. - El código cumple con los estándares de linting
configurados.

\subsection{Fase 3: Módulo de estudiante (Semanas
3-4)}\label{fase-3-muxf3dulo-de-estudiante-semanas-3-4}

\textbf{Objetivos de la fase}: - Implementar funcionalidades completas
para el rol estudiante. - Desarrollar sistema de gestión de archivos
mock. - Crear interfaces de seguimiento de estado de TFG. - Integrar
sistema de notificaciones básico.

\textbf{Actividades principales}:

\emph{Semana 3: Gestión de TFG} - Desarrollo del custom hook useTFGs
para lógica de negocio. - Implementación de formularios de creación y
edición de TFG. - Sistema de upload de archivos con validación y
progress tracking. - Interfaz de visualización de TFG con metadatos.

\emph{Semana 4: Seguimiento y notificaciones} - Implementación del
sistema de estados (Borrador → En Revisión → Aprobado → Defendido). -
Desarrollo de componentes de timeline para tracking de progreso. -
Integración del NotificacionesContext. - Interfaces de visualización de
comentarios del tutor.

\textbf{Entregables}: - Módulo completo de estudiante operativo. -
Sistema de upload y gestión de archivos. - Interfaz de seguimiento de
estado implementada. - Sistema de notificaciones integrado.

\textbf{Criterios de aceptación}: - Los estudiantes pueden crear, editar
y subir archivos de TFG. - El sistema de estados funciona correctamente
con validaciones apropiadas. - Las notificaciones se muestran en tiempo
real. - Las interfaces son intuitivas y responsive.

\subsection{Fase 4: Módulo de profesor (Semanas
4-5)}\label{fase-4-muxf3dulo-de-profesor-semanas-4-5}

\textbf{Objetivos de la fase}: - Desarrollar herramientas de supervisión
para profesores tutores. - Implementar sistema de feedback estructurado.
- Crear interfaces de gestión de TFG asignados. - Integrar capacidades
de cambio de estado con validaciones.

\textbf{Actividades principales}:

\emph{Semana 4 (solapada): Bases del módulo profesor} - Desarrollo de
interfaces de listado de TFG asignados. - Implementación de filtros y
búsqueda por estado, estudiante, fecha. - Sistema de visualización de
archivos PDF subidos por estudiantes.

\emph{Semana 5: Sistema de feedback y evaluación} - Desarrollo de
formularios de comentarios estructurados. - Implementación de sistema de
calificaciones y evaluaciones. - Interfaces de cambio de estado con
validación de permisos. - Integration con sistema de notificaciones para
estudiantes.

\textbf{Entregables}: - Módulo completo de profesor funcional. - Sistema
de feedback y comentarios implementado. - Interfaces de evaluación y
cambio de estado. - Validaciones de permisos por rol operativas.

\textbf{Criterios de aceptación}: - Los profesores pueden gestionar
eficientemente sus TFG asignados. - El sistema de comentarios permite
feedback estructurado. - Los cambios de estado notifican apropiadamente
a los estudiantes. - Las validaciones de permisos funcionan
correctamente.

\subsection{Fase 5: Sistema de defensas y calendario (Semanas
5-6)}\label{fase-5-sistema-de-defensas-y-calendario-semanas-5-6}

\textbf{Objetivos de la fase}: - Integrar FullCalendar.js para gestión
visual de defensas. - Implementar sistema de gestión de tribunales. -
Desarrollar funcionalidades de programación de defensas. - Crear sistema
de coordinación de disponibilidad.

\textbf{Actividades principales}:

\emph{Semana 5 (solapada): Integración de calendario} - Instalación y
configuración de FullCalendar.js para React. - Desarrollo del custom
hook useCalendario. - Implementación de vistas múltiples (mensual,
semanal, diaria). - Configuración de eventos personalizados para
defensas.

\emph{Semana 6: Gestión de tribunales y defensas} - Desarrollo del
módulo de creación y gestión de tribunales. - Implementación de sistema
de asignación de miembros de tribunal. - Interfaces de programación de
defensas con drag \& drop. - Sistema de notificaciones para tribunales y
estudiantes.

\textbf{Entregables}: - Calendario interactivo completamente funcional.
- Sistema de gestión de tribunales operativo. - Funcionalidades de
programación de defensas implementadas. - Coordinación de disponibilidad
automatizada.

\textbf{Criterios de aceptación}: - El calendario muestra correctamente
todas las defensas programadas. - Los tribunales pueden crearse y
gestionarse eficientemente. - La programación de defensas es intuitiva y
funcional. - Las notificaciones se envían a todos los actores
relevantes.

\subsection{Fase 6: Panel administrativo (Semanas
6-7)}\label{fase-6-panel-administrativo-semanas-6-7}

\textbf{Objetivos de la fase}: - Desarrollar sistema completo de gestión
de usuarios (CRUD). - Implementar generación de reportes y estadísticas.
- Crear funcionalidades de exportación de datos. - Establecer
configuración global del sistema.

\textbf{Actividades principales}:

\emph{Semana 6 (solapada): Gestión de usuarios} - Desarrollo del custom
hook useUsuarios. - Implementación de interfaces CRUD para gestión de
usuarios. - Sistema de asignación de roles con validaciones. - Filtros
avanzados y búsqueda de usuarios.

\emph{Semana 7: Reportes y configuración} - Desarrollo del custom hook
useReportes. - Implementación de dashboards con estadísticas visuales. -
Sistema de exportación a PDF y Excel. - Interfaces de configuración
global del sistema.

\textbf{Entregables}: - Panel administrativo completo y funcional. -
Sistema de reportes con múltiples visualizaciones. - Funcionalidades de
exportación operativas. - Sistema de configuración implementado.

\textbf{Criterios de aceptación}: - La gestión de usuarios permite
operaciones CRUD completas. - Los reportes proporcionan insights
valiosos sobre el sistema. - Las exportaciones generan archivos
correctamente formateados. - La configuración global afecta
apropiadamente el comportamiento del sistema.

\subsection{Fase 7: Backend Symfony (Semanas
7-9)}\label{fase-7-backend-symfony-semanas-7-9}

\textbf{Objetivos de la fase}: - Implementar backend completo con
Symfony 6.4 LTS. - Desarrollar APIs REST con API Platform 3.x. - Migrar
de sistema mock a persistencia real con MySQL. - Implementar
autenticación JWT con refresh tokens.

\textbf{Actividades principales}:

\emph{Semana 7: Setup y arquitectura backend} - Configuración del
proyecto Symfony con DDEV. - Definición de entidades Doctrine (User,
TFG, Tribunal, Defensa, etc.). - Configuración de base de datos MySQL
con migraciones iniciales. - Setup de API Platform y configuración de
serialización.

\emph{Semana 8: APIs y autenticación} - Implementación completa de
endpoints REST. - Configuración de LexikJWTAuthenticationBundle. -
Sistema de roles y permisos con Symfony Security. - Integración de
VichUploaderBundle para gestión de archivos.

\emph{Semana 9: Integración y testing} - Conexión completa
frontend-backend. - Implementación de sistema de notificaciones por
email. - Testing de APIs con PHPUnit. - Optimización de consultas y
rendimiento.

\textbf{Entregables}: - Backend Symfony completamente funcional. - APIs
REST documentadas con OpenAPI. - Sistema de autenticación JWT operativo.
- Integración frontend-backend completada.

\textbf{Criterios de aceptación}: - Todas las funcionalidades frontend
funcionan con APIs reales. - El sistema de autenticación JWT es seguro y
funcional. - Las APIs están correctamente documentadas y testeadas. - El
rendimiento del sistema cumple los objetivos establecidos.

\subsection{Fase 8: Pulimiento final (Semanas
9-10)}\label{fase-8-pulimiento-final-semanas-9-10}

\textbf{Objetivos de la fase}: - Realizar testing exhaustivo de toda la
aplicación. - Optimizar rendimiento y experiencia de usuario. -
Configurar despliegue en producción. - Completar documentación técnica y
manuales.

\textbf{Actividades principales}:

\emph{Semana 9 (solapada): Testing y optimización} - Implementación de
testing E2E con herramientas apropiadas. - Optimización de consultas de
base de datos. - Mejoras de UX basadas en testing de usabilidad. -
Corrección de bugs identificados durante testing integral.

\emph{Semana 10: Despliegue y documentación} - Configuración de entorno
de producción con Docker. - Setup de CI/CD pipeline para despliegues
automatizados. - Finalización de documentación técnica completa. -
Creación de manuales de usuario para todos los roles.

\textbf{Entregables}: - Aplicación completamente testeada y optimizada.
- Configuración de producción operativa. - Documentación técnica y
manuales completos. - Sistema listo para despliegue en producción.

\textbf{Criterios de aceptación}: - Todos los tests (unitarios,
integración, E2E) pasan exitosamente. - El sistema cumple todos los
criterios de rendimiento establecidos. - La documentación está completa
y es comprensible. - El despliegue en producción es exitoso y estable.

\section{Diagrama de Gantt}\label{diagrama-de-gantt}

La representación visual del cronograma del proyecto mediante diagramas
de Gantt constituye una herramienta fundamental para la gestión temporal
y el seguimiento del progreso. Estos diagramas permiten identificar
dependencias críticas, optimizar la distribución de recursos y
establecer puntos de control para la evaluación del avance del proyecto.

El siguiente cronograma ilustra la distribución temporal de las
actividades principales del proyecto, mostrando dependencias entre fases
y solapamientos estratégicos para optimizar el desarrollo. La
visualización facilita la comprensión de la secuencia lógica de
actividades y permite identificar tanto la ruta crítica como las
oportunidades de paralelización del trabajo.

\subsection{Cronograma general del
proyecto}\label{cronograma-general-del-proyecto}

El cronograma general del proyecto establece una visión temporal completa de todas las fases de desarrollo, desde la inicialización hasta el despliegue en producción. La planificación temporal se ha estructurado en 8 fases distribuidas a lo largo de 10 semanas, optimizando los recursos disponibles y garantizando la entrega dentro del plazo establecido.

La metodología de desarrollo adoptada permite solapamientos estratégicos entre fases, especialmente entre el desarrollo del frontend y la preparación del backend, maximizando la eficiencia del proceso de desarrollo. El cronograma contempla hitos de validación al final de cada fase, asegurando la calidad incremental del producto, como se ilustra en la Figura~\ref{fig:cronograma-general}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Cronograma General}]{processed/images/03_planificacion_mermaid_0.png}}
\caption{Cronograma General}
\label{fig:cronograma-general}
\end{figure}

\subsection{Hitos principales y
dependencias}\label{hitos-principales-y-dependencias}

El cronograma principal detalla los hitos críticos y las dependencias entre las diferentes fases del proyecto, facilitando la identificación de puntos de control y la gestión de riesgos temporales. Esta visualización complementaria permite un análisis más granular de la secuencia de actividades y sus interdependencias, como se muestra en la Figura~\ref{fig:cronograma-principal}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Cronograma Principal}]{processed/images/03_planificacion_mermaid_1.png}}
\caption{Cronograma Principal}
\label{fig:cronograma-principal}
\end{figure}

\textbf{Hitos críticos identificados}: - \textbf{H1}: Frontend base
funcional (Semana 3) - Fin de Fase 1-2. - \textbf{H2}: Módulos usuario
completos (Semana 6) - Fin de Fases 3-4. - \textbf{H3}: Sistema frontend
completo (Semana 8) - Fin de Fases 5-6. - \textbf{H4}: Backend integrado
(Semana 9) - Fin de Fase 7. - \textbf{H5}: Sistema productivo (Semana
10) - Fin de Fase 8.

\textbf{Dependencias críticas}: - Fase 3 (Estudiante) requiere completar
Sistema de autenticación. - Fase 4 (Profesor) depende de estados TFG de
Fase 3. - Fase 5 (Defensas) necesita roles y permisos de Fase 4. - Fase
7 (Backend) puede iniciarse en paralelo desde Semana 7. - Fase 8
(Testing) requiere integración completa de Fase 7.

\subsection{Análisis de ruta
crítica}\label{anuxe1lisis-de-ruta-cruxedtica}

\textbf{Ruta crítica identificada}: Fase 1-2 → Fase 3 → Fase 4 → Fase 5
→ Fase 7 → Fase 8

Esta ruta crítica tiene una duración total de 9 semanas, proporcionando
1 semana de margen para el cronograma total de 10 semanas. Los elementos
que componen la ruta crítica son:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Sistema de autenticación} (Fase 1-2): Base fundamental para
  todos los módulos posteriores.
\item
  \textbf{Módulo de estudiante} (Fase 3): Funcionalidad core del
  sistema.
\item
  \textbf{Módulo de profesor} (Fase 4): Dependiente del flujo de estados
  de Fase 3.
\item
  \textbf{Sistema de defensas} (Fase 5): Requiere roles y permisos de
  fases anteriores.
\item
  \textbf{Backend Symfony} (Fase 7): Integración crítica para
  funcionalidad completa.
\item
  \textbf{Pulimiento final} (Fase 8): Testing integral y despliegue.
\end{enumerate}

\subsection{Optimizaciones de
cronograma}\label{optimizaciones-de-cronograma}

\textbf{Desarrollo paralelo estratégico}: Las Fases 6 (Panel
administrativo) y parte de la Fase 7 (Setup backend) pueden
desarrollarse en paralelo con otras fases, reduciendo la ruta crítica
total.

\textbf{Entregas incrementales}: Cada fase produce entregables
funcionales que permiten validación temprana y ajustes de requisitos sin
afectar significativamente el cronograma global.

\textbf{Buffer de tiempo}: La semana adicional disponible (Semana 10
completa) actúa como buffer para gestión de riesgos imprevistos o
refinamiento adicional de funcionalidades críticas.

\section{Cronograma académico}\label{cronograma-acaduxe9mico}

La integración del cronograma del proyecto con el calendario académico
universitario requiere una planificación cuidadosa que considere los
períodos lectivos, épocas de exámenes, festivos académicos y
disponibilidad de recursos universitarios. Esta sincronización es
esencial para garantizar que las entregas del proyecto se realicen en
momentos apropiados y que la validación por parte de usuarios académicos
sea factible.

El cronograma académico establece hitos de entrega que permiten la
evaluación progresiva del trabajo desarrollado, facilitando el feedback
temprano y la corrección de desviaciones antes de que impacten
significativamente en el resultado final del proyecto.

\subsection{Calendario de entregas}\label{calendario-de-entregas}

El cronograma del proyecto se alinea con el calendario académico
universitario, considerando períodos de exámenes, festivos y
disponibilidad de recursos académicos para validación y feedback.

\textbf{Entregas principales programadas}:

\begin{itemize}
\tightlist
\item
  \textbf{Entrega 1 - Semana 3}: Demo del sistema de autenticación y
  módulo de estudiante básico.
\item
  \textbf{Entrega 2 - Semana 5}: Sistema completo de gestión para
  estudiantes y profesores.
\item
  \textbf{Entrega 3 - Semana 7}: Plataforma frontend completa con todas
  las funcionalidades.
\item
  \textbf{Entrega 4 - Semana 9}: Sistema integrado con backend
  funcional.
\item
  \textbf{Entrega final - Semana 10}: Aplicación completa lista para
  producción.
\end{itemize}

\subsection{Sesiones de validación}\label{sesiones-de-validaciuxf3n}

\textbf{Validación de usuarios}: Se programan sesiones de feedback con
representantes de cada rol de usuario al finalizar las fases
correspondientes:

\begin{itemize}
\tightlist
\item
  \textbf{Semana 4}: Validación con estudiantes del módulo desarrollado
  en Fase 3.
\item
  \textbf{Semana 6}: Validación con profesores del sistema de
  supervisión y feedback.
\item
  \textbf{Semana 7}: Validación con administradores del panel de
  gestión.
\item
  \textbf{Semana 9}: Validación integral con todos los tipos de usuario.
\end{itemize}

\textbf{Criterios de validación}: Cada sesión evalúa usabilidad,
funcionalidad completa y cumplimiento de requisitos específicos del rol,
proporcionando input para refinamiento en fases posteriores.

\subsection{Gestión de riesgos
temporales}\label{gestiuxf3n-de-riesgos-temporales}

\textbf{Identificación de riesgos}: - \textbf{Riesgo técnico}:
Dificultades de integración entre frontend y backend. - \textbf{Riesgo
de alcance}: Solicitudes de funcionalidades adicionales durante
desarrollo. - \textbf{Riesgo de recursos}: Disponibilidad limitada
durante períodos de exámenes.

\textbf{Estrategias de mitigación}: - \textbf{Buffer temporal}: 1 semana
adicional para absorber retrasos imprevistos. - \textbf{Desarrollo
incremental}: Entregas funcionales que permiten validación temprana. -
\textbf{Documentación continua}: Registro de decisiones para facilitar
retoma tras interrupciones. - \textbf{Testing automatizado}: Reducción
de tiempo necesario para validación manual.

\subsection{Métricas de seguimiento}\label{muxe9tricas-de-seguimiento}

\textbf{Indicadores de progreso}: - \textbf{Velocity por fase}:
Comparación de tiempo estimado vs.~tiempo real de cada fase. -
\textbf{Funcionalidades completadas}: Porcentaje de features
implementadas vs.~planificadas. - \textbf{Debt técnico}: Cantidad de
refactoring pendiente identificado durante desarrollo. -
\textbf{Coverage de testing}: Porcentaje de código cubierto por tests
automatizados.

\textbf{Herramientas de seguimiento}: - \textbf{Git commits}:
Seguimiento diario de progreso mediante análisis de commits. -
\textbf{Issues tracking}: GitHub Issues para gestión de bugs y features
pendientes. - \textbf{Time tracking}: Registro manual de tiempo
invertido por fase para métricas de velocity. - \textbf{Code quality}:
Métricas automáticas de ESLint, PHPStan y herramientas de análisis.

\chapter{Análisis del sistema}\label{anuxe1lisis-del-sistema}
Durante este capítulo se realizará un análisis exhaustivo del sistema
que se ha desarrollado, abarcando desde la especificación completa de
requisitos hasta la gestión del presupuesto del proyecto. Este análisis
constituye la base fundamental sobre la cual se sustenta todo el diseño
e implementación posterior del sistema.

El análisis del sistema comprende varios aspectos críticos que deben ser
abordados de manera sistemática y rigurosa. En primer lugar, se presenta
la especificación de requisitos, tanto funcionales como no funcionales,
que definen qué debe hacer el sistema y bajo qué condiciones debe
operarlo. Posteriormente, se examina la garantía de calidad,
estableciendo los criterios y estándares que el sistema debe cumplir
para asegurar su correcto funcionamiento.

Finalmente, se incluye la gestión del presupuesto, elemento esencial
para la viabilidad del proyecto que permite evaluar la inversión
requerida y los beneficios esperados. Este enfoque integral garantiza
que el análisis cubra todas las dimensiones relevantes para el éxito del
proyecto.

\section{Especificación de
requisitos}\label{especificaciuxf3n-de-requisitos}

Una vez establecido el marco general del análisis del sistema,
procederemos con la especificación detallada de requisitos del proyecto.
Esta especificación constituye el fundamento técnico sobre el cual se
construye toda la arquitectura del sistema, definiendo de manera precisa
tanto las funcionalidades que debe proporcionar como las restricciones
que debe cumplir.

La especificación de requisitos de la Plataforma de Gestión de TFG se
estructura siguiendo la metodología IEEE Std 830-1998, organizando los
requisitos en categorías funcionales específicas por rol de usuario y
requisitos no funcionales transversales que garantizan la calidad del
sistema.

\subsection{Requisitos de
información}\label{requisitos-de-informaciuxf3n}

Los requisitos de información definen las entidades de datos principales
que el sistema debe gestionar, sus atributos esenciales y las relaciones
entre ellas.

\subsubsection{Entidad Usuario}\label{entidad-usuario}

\textbf{Descripción}: Representa a todos los actores que interactúan con
el sistema, diferenciados por roles específicos.

\textbf{Atributos principales}: - \textbf{Identificador único}: ID
numérico autoincremental - \textbf{Datos personales}: Nombre, apellidos,
DNI, email, teléfono - \textbf{Credenciales}: Email (único), password
hash, fecha último acceso - \textbf{Información académica}: Universidad,
departamento, especialidad - \textbf{Control de sistema}: Rol asignado,
estado activo/inactivo, fechas de creación y actualización

\textbf{Restricciones}: - El email debe ser único en el sistema. - El
DNI debe seguir formato válido español. - Cada usuario debe tener al
menos un rol asignado. - Los datos personales son obligatorios para
activación de cuenta.

\subsubsection{Entidad TFG}\label{entidad-tfg}

\textbf{Descripción}: Representa un Trabajo de Fin de Grado con toda su
información asociada y ciclo de vida.

\textbf{Atributos principales}: - \textbf{Identificador único}: ID
numérico autoincremental - \textbf{Información académica}: Título,
descripción detallada, resumen ejecutivo - \textbf{Metadatos}: Palabras
clave (array JSON), área de conocimiento - \textbf{Relaciones}:
Estudiante asignado, tutor principal, cotutor opcional -
\textbf{Estado}: Enum (borrador, revision, aprobado, defendido) -
\textbf{Fechas}: Inicio, fin estimada, fin real, última modificación -
\textbf{Archivo}: Ruta, nombre original, tamaño, tipo MIME -
\textbf{Evaluación}: Calificación final, comentarios de evaluación

\textbf{Restricciones}: - Un estudiante puede tener máximo un TFG
activo. - El título debe ser único por estudiante. - El archivo debe ser
formato PDF con tamaño máximo 50MB. - Las transiciones de estado deben
seguir el flujo definido.

\subsubsection{Entidad Tribunal}\label{entidad-tribunal}

\textbf{Descripción}: Comisión evaluadora responsable de las defensas de
TFG.

\textbf{Atributos principales}: - \textbf{Identificador único}: ID
numérico autoincremental - \textbf{Información básica}: Nombre
descriptivo, descripción opcional - \textbf{Composición}: Presidente,
secretario, vocal (referencias a usuarios) - \textbf{Estado}:
Activo/inactivo para programación de nuevas defensas -
\textbf{Metadatos}: Fechas de creación y actualización

\textbf{Restricciones}: - Los tres miembros del tribunal deben ser
usuarios con rol profesor o superior. - No puede haber miembros
duplicados en un mismo tribunal. - Al menos el presidente debe tener rol
PRESIDENTE\_TRIBUNAL.

\subsubsection{Entidad Defensa}\label{entidad-defensa}

\textbf{Descripción}: Evento de presentación y evaluación de un TFG ante
un tribunal.

\textbf{Atributos principales}: - \textbf{Identificador único}: ID
numérico autoincremental - \textbf{Relaciones}: TFG a defender, tribunal
asignado - \textbf{Programación}: Fecha y hora, duración estimada, aula
asignada - \textbf{Estado}: Programada, completada, cancelada -
\textbf{Documentación}: Observaciones, acta generada (ruta archivo) -
\textbf{Metadatos}: Fechas de creación y actualización

\textbf{Restricciones}: - Un TFG solo puede tener una defensa activa. -
La fecha de defensa debe ser posterior a la fecha actual. - El tribunal
debe estar disponible en la fecha programada.

\subsection{Requisitos funcionales}\label{requisitos-funcionales}

Los requisitos funcionales se organizan por rol de usuario, definiendo
las capacidades específicas que el sistema debe proporcionar a cada tipo
de actor.

\subsubsection{Requisitos funcionales -
Estudiante}\label{requisitos-funcionales---estudiante}

\textbf{RF-EST-001: Gestión de cuenta de usuario} -
\textbf{Descripción}: El estudiante debe poder visualizar y actualizar
su información personal. - \textbf{Entrada}: Datos personales (nombre,
apellidos, teléfono, etc.). - \textbf{Procesamiento}: Validación de
formato y unicidad. - \textbf{Salida}: Confirmación de actualización
exitosa. - \textbf{Prioridad}: Alta.

\textbf{RF-EST-002: Creación de TFG} - \textbf{Descripción}: El
estudiante debe poder crear un nuevo TFG proporcionando información
básica. - \textbf{Entrada}: Título, descripción, resumen, palabras
clave, tutor seleccionado. - \textbf{Procesamiento}: Validación de
datos, verificación de no duplicidad de título. - \textbf{Salida}: TFG
creado en estado ``borrador''. - \textbf{Prioridad}: Alta.

\textbf{RF-EST-003: Edición de información de TFG} -
\textbf{Descripción}: El estudiante debe poder modificar la información
de su TFG en estado borrador. - \textbf{Entrada}: Campos modificables
del TFG. - \textbf{Procesamiento}: Validación de permisos de edición
según estado. - \textbf{Salida}: TFG actualizado con nueva información.
- \textbf{Prioridad}: Alta.

\textbf{RF-EST-004: Upload de archivo TFG} - \textbf{Descripción}: El
estudiante debe poder subir el archivo PDF de su trabajo. -
\textbf{Entrada}: Archivo PDF (máximo 50MB). - \textbf{Procesamiento}:
Validación de formato, tipo MIME, tamaño. - \textbf{Salida}: Archivo
almacenado y vinculado al TFG. - \textbf{Prioridad}: Alta.

\textbf{RF-EST-005: Seguimiento de estado} - \textbf{Descripción}: El
estudiante debe poder visualizar el estado actual y histórico de su TFG.
- \textbf{Entrada}: ID del TFG del estudiante. - \textbf{Procesamiento}:
Recuperación de información de estado y timeline. - \textbf{Salida}:
Estado actual, fechas de cambios, comentarios asociados. -
\textbf{Prioridad}: Media.

\textbf{RF-EST-006: Visualización de comentarios} -
\textbf{Descripción}: El estudiante debe poder leer comentarios y
feedback de su tutor. - \textbf{Entrada}: ID del TFG. -
\textbf{Procesamiento}: Filtrado de comentarios visibles para el
estudiante. - \textbf{Salida}: Lista de comentarios ordenados
cronológicamente. - \textbf{Prioridad}: Media.

\textbf{RF-EST-007: Consulta de información de defensa} -
\textbf{Descripción}: El estudiante debe poder ver detalles de su
defensa programada. - \textbf{Entrada}: ID del TFG. -
\textbf{Procesamiento}: Búsqueda de defensa asociada. - \textbf{Salida}:
Fecha, hora, tribunal, aula, duración. - \textbf{Prioridad}: Media.

\subsubsection{Requisitos funcionales -
Profesor}\label{requisitos-funcionales---profesor}

\textbf{RF-PROF-001: Visualización de TFG asignados} -
\textbf{Descripción}: El profesor debe poder ver listado de TFG donde
participa como tutor. - \textbf{Entrada}: ID del profesor. -
\textbf{Procesamiento}: Filtrado de TFG por tutor\_id o cotutor\_id. -
\textbf{Salida}: Lista de TFG con información resumida y estado. -
\textbf{Prioridad}: Alta.

\textbf{RF-PROF-002: Revisión de TFG} - \textbf{Descripción}: El
profesor debe poder descargar y revisar archivos de TFG asignados. -
\textbf{Entrada}: ID del TFG, credenciales del profesor. -
\textbf{Procesamiento}: Verificación de permisos, generación de enlace
de descarga. - \textbf{Salida}: Archivo PDF descargable. -
\textbf{Prioridad}: Alta.

\textbf{RF-PROF-003: Gestión de comentarios} - \textbf{Descripción}: El
profesor debe poder agregar comentarios y feedback estructurado. -
\textbf{Entrada}: ID del TFG, texto del comentario, tipo de comentario.
- \textbf{Procesamiento}: Validación de permisos, almacenamiento del
comentario. - \textbf{Salida}: Comentario registrado y notificación al
estudiante. - \textbf{Prioridad}: Alta.

\textbf{RF-PROF-004: Cambio de estado de TFG} - \textbf{Descripción}: El
profesor debe poder cambiar el estado de TFG bajo su supervisión. -
\textbf{Entrada}: ID del TFG, nuevo estado, comentario justificativo. -
\textbf{Procesamiento}: Validación de transición de estado permitida. -
\textbf{Salida}: Estado actualizado y notificaciones automáticas. -
\textbf{Prioridad}: Alta.

\textbf{RF-PROF-005: Gestión de calificaciones} - \textbf{Descripción}:
El profesor debe poder asignar calificaciones a TFG defendidos. -
\textbf{Entrada}: ID de la defensa, calificaciones por criterio,
comentarios. - \textbf{Procesamiento}: Validación de rango de
calificaciones, cálculo de nota final. - \textbf{Salida}: Calificación
registrada y disponible para el estudiante. - \textbf{Prioridad}: Media.

\textbf{RF-PROF-006: Participación en tribunales} -
\textbf{Descripción}: El profesor debe poder ver tribunales donde
participa y defensas programadas. - \textbf{Entrada}: ID del profesor. -
\textbf{Procesamiento}: Búsqueda de tribunales donde es miembro. -
\textbf{Salida}: Lista de tribunales, defensas programadas, calendario.
- \textbf{Prioridad}: Media.

\subsubsection{Requisitos funcionales - Presidente de
Tribunal}\label{requisitos-funcionales---presidente-de-tribunal}

\textbf{RF-PRES-001: Gestión de tribunales} - \textbf{Descripción}: El
presidente debe poder crear, editar y gestionar tribunales. -
\textbf{Entrada}: Información del tribunal, miembros seleccionados. -
\textbf{Procesamiento}: Validación de roles, verificación de
disponibilidad. - \textbf{Salida}: Tribunal creado/actualizado con
miembros asignados. - \textbf{Prioridad}: Alta.

\textbf{RF-PRES-002: Programación de defensas} - \textbf{Descripción}:
El presidente debe poder programar defensas en el calendario. -
\textbf{Entrada}: TFG a defender, tribunal, fecha/hora, aula. -
\textbf{Procesamiento}: Verificación de disponibilidad de tribunal y
recursos. - \textbf{Salida}: Defensa programada con notificaciones
automáticas. - \textbf{Prioridad}: Alta.

\textbf{RF-PRES-003: Gestión de calendario} - \textbf{Descripción}: El
presidente debe poder visualizar y gestionar el calendario de defensas.
- \textbf{Entrada}: Rango de fechas, filtros por tribunal. -
\textbf{Procesamiento}: Agregación de datos de defensas programadas. -
\textbf{Salida}: Vista de calendario con eventos de defensa. -
\textbf{Prioridad}: Alta.

\textbf{RF-PRES-004: Coordinación de disponibilidad} -
\textbf{Descripción}: El presidente debe poder consultar disponibilidad
de miembros de tribunal. - \textbf{Entrada}: Tribunal seleccionado,
rango de fechas. - \textbf{Procesamiento}: Cruce de calendarios de
miembros. - \textbf{Salida}: Slots de tiempo disponibles para todos los
miembros. - \textbf{Prioridad}: Media.

\textbf{RF-PRES-005: Generación de actas} - \textbf{Descripción}: El
presidente debe poder generar actas de defensa en formato PDF. -
\textbf{Entrada}: ID de la defensa completada. - \textbf{Procesamiento}:
Agregación de datos, generación de documento. - \textbf{Salida}: Acta en
formato PDF descargable. - \textbf{Prioridad}: Media.

\subsubsection{Requisitos funcionales -
Administrador}\label{requisitos-funcionales---administrador}

\textbf{RF-ADM-001: Gestión completa de usuarios} -
\textbf{Descripción}: El administrador debe poder realizar operaciones
CRUD sobre usuarios. - \textbf{Entrada}: Datos de usuario, rol asignado.
- \textbf{Procesamiento}: Validación de datos, gestión de permisos. -
\textbf{Salida}: Usuario creado/actualizado/eliminado. -
\textbf{Prioridad}: Alta.

\textbf{RF-ADM-002: Asignación de roles} - \textbf{Descripción}: El
administrador debe poder modificar roles y permisos de usuarios. -
\textbf{Entrada}: ID de usuario, nuevo rol. - \textbf{Procesamiento}:
Validación de permisos, actualización de privilegios. - \textbf{Salida}:
Rol actualizado con permisos correspondientes. - \textbf{Prioridad}:
Alta.

\textbf{RF-ADM-003: Generación de reportes} - \textbf{Descripción}: El
administrador debe poder generar reportes estadísticos del sistema. -
\textbf{Entrada}: Tipo de reporte, filtros temporales, parámetros. -
\textbf{Procesamiento}: Agregación de datos, cálculos estadísticos. -
\textbf{Salida}: Reporte con gráficos y métricas. - \textbf{Prioridad}:
Media.

\textbf{RF-ADM-004: Exportación de datos} - \textbf{Descripción}: El
administrador debe poder exportar datos en múltiples formatos. -
\textbf{Entrada}: Conjunto de datos seleccionado, formato de
exportación. - \textbf{Procesamiento}: Serialización de datos según
formato. - \textbf{Salida}: Archivo exportado (PDF, Excel, CSV). -
\textbf{Prioridad}: Media.

\textbf{RF-ADM-005: Configuración del sistema} - \textbf{Descripción}:
El administrador debe poder configurar parámetros globales. -
\textbf{Entrada}: Parámetros de configuración. - \textbf{Procesamiento}:
Validación de valores, actualización de configuración. -
\textbf{Salida}: Configuración actualizada en el sistema. -
\textbf{Prioridad}: Baja.

\subsection{Diagrama de casos de uso}\label{diagrama-de-casos-de-uso}

El siguiente diagrama representa las principales interacciones entre los
actores del sistema y las funcionalidades disponibles para cada rol, como se ilustra en la Figura~\ref{fig:diagrama-casos-uso}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Diagrama de casos de uso}]{processed/images/04_analisis_sistema_plantuml_0.png}}
\caption{Diagrama de casos de uso}
\label{fig:diagrama-casos-uso}
\end{figure}

\subsection{Descripción de casos de
uso}\label{descripciuxf3n-de-casos-de-uso}

\subsubsection{UC001 - Crear TFG}\label{uc001---crear-tfg}

\textbf{Actor principal}: Estudiante\\
\textbf{Precondiciones}: - El usuario está autenticado con rol
estudiante. - El estudiante no tiene un TFG activo.

\textbf{Flujo principal}: 1. El estudiante accede a la opción ``Nuevo
TFG''. 2. El sistema muestra el formulario de creación. 3. El estudiante
completa título, descripción, resumen y palabras clave. 4. El estudiante
selecciona un tutor de la lista disponible. 5. El estudiante confirma la
creación. 6. El sistema valida la información proporcionada. 7. El
sistema crea el TFG en estado ``borrador''. 8. El sistema notifica al
tutor seleccionado.

\textbf{Flujos alternativos}: - \textbf{6a}: Si la validación falla, el
sistema muestra errores específicos. - \textbf{7a}: Si el estudiante ya
tiene un TFG activo, el sistema rechaza la operación.

\textbf{Postcondiciones}: - Se crea un nuevo TFG en estado ``borrador''.
- El tutor recibe notificación de asignación.

\subsubsection{UC005 - Revisar TFG}\label{uc005---revisar-tfg}

\textbf{Actor principal}: Profesor\\
\textbf{Precondiciones}: - El usuario está autenticado con rol profesor.
- El TFG está asignado al profesor como tutor.

\textbf{Flujo principal}: 1. El profesor accede a su lista de TFG
asignados. 2. El profesor selecciona un TFG específico. 3. El sistema
muestra detalles del TFG. 4. El profesor descarga el archivo PDF si está
disponible. 5. El profesor revisa el contenido del trabajo.

\textbf{Flujos alternativos}: - \textbf{4a}: Si no hay archivo subido,
el sistema informa de la situación. - \textbf{2a}: Si el TFG no está
asignado al profesor, el sistema deniega acceso.

\textbf{Postcondiciones}: - El profesor tiene acceso al contenido del
TFG para evaluación.

\subsubsection{UC010 - Programar
defensa}\label{uc010---programar-defensa}

\textbf{Actor principal}: Presidente de Tribunal\\
\textbf{Precondiciones}: - El usuario está autenticado con rol
presidente de tribunal. - Existe al menos un tribunal creado. - El TFG
está en estado ``aprobado''.

\textbf{Flujo principal}: 1. El presidente accede al calendario de
defensas. 2. El presidente selecciona un TFG aprobado para programar. 3.
El sistema muestra opciones de tribunales disponibles. 4. El presidente
selecciona tribunal, fecha, hora y aula. 5. El sistema verifica
disponibilidad de todos los miembros. 6. El presidente confirma la
programación. 7. El sistema crea la defensa programada. 8. El sistema
envía notificaciones a estudiante y miembros del tribunal.

\textbf{Flujos alternativos}: - \textbf{5a}: Si hay conflictos de
disponibilidad, el sistema sugiere alternativas. - \textbf{4a}: Si no
hay tribunales disponibles, el sistema solicita crear uno.

\textbf{Postcondiciones}: - Se programa una defensa con fecha y tribunal
asignados. - Todos los involucrados reciben notificaciones.

\subsection{Diagramas de secuencia}\label{diagramas-de-secuencia}

Los diagramas de secuencia ilustran la interacción temporal entre los diferentes componentes del sistema durante la ejecución de los casos de uso más críticos. Estas representaciones permiten comprender el flujo de mensajes, la sincronización de operaciones y las responsabilidades de cada actor en los procesos principales del sistema.

\subsubsection{Secuencia: Subida de archivo
TFG}\label{secuencia-subida-de-archivo-tfg}

El proceso de subida de archivos TFG representa una de las funcionalidades core del sistema, involucrando validación, almacenamiento seguro y notificación de cambios de estado. La secuencia completa se detalla en la Figura~\ref{fig:secuencia-subida-archivo}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Secuencia: Subida de archivo TFG}]{processed/images/04_analisis_sistema_plantuml_1.png}}
\caption{Secuencia: Subida de archivo TFG}
\label{fig:secuencia-subida-archivo}
\end{figure}

\subsubsection{Secuencia: Cambio de estado de
TFG}\label{secuencia-cambio-de-estado-de-tfg}

La gestión de estados del TFG requiere validación de permisos, actualización de datos y coordinación entre múltiples actores del sistema. Este flujo crítico se representa en la Figura~\ref{fig:secuencia-cambio-estado}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Secuencia: Cambio de estado de TFG}]{processed/images/04_analisis_sistema_plantuml_2.png}}
\caption{Secuencia: Cambio de estado de TFG}
\label{fig:secuencia-cambio-estado}
\end{figure}

\subsubsection{Secuencia: Programación de
defensa}\label{secuencia-programaciuxf3n-de-defensa}

La programación de defensas involucra la coordinación entre tribunales, verificación de disponibilidad y asignación de recursos. El proceso completo de coordinación se ilustra en la Figura~\ref{fig:secuencia-programacion-defensa}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Secuencia: Programación de defensa}]{processed/images/04_analisis_sistema_plantuml_3.png}}
\caption{Secuencia: Programación de defensa}
\label{fig:secuencia-programacion-defensa}
\end{figure}

\subsection{Requisitos no funcionales}\label{requisitos-no-funcionales}

\subsubsection{Rendimiento}\label{rendimiento}

\textbf{RNF-001: Tiempo de respuesta} - \textbf{Descripción}: Las
operaciones críticas deben completarse en tiempo óptimo. -
\textbf{Criterio}: - Login y autenticación: \textless{} 2 segundos. -
Carga de páginas principales: \textless{} 3 segundos.\\
- Upload de archivos (50MB): \textless{} 30 segundos. - Generación de
reportes: \textless{} 10 segundos. - \textbf{Prioridad}: Alta.

\textbf{RNF-002: Throughput} - \textbf{Descripción}: El sistema debe
soportar carga concurrente de usuarios. - \textbf{Criterio}: 100
usuarios concurrentes sin degradación de rendimiento. -
\textbf{Prioridad}: Media.

\textbf{RNF-003: Escalabilidad} - \textbf{Descripción}: Capacidad de
crecimiento con aumento de usuarios. - \textbf{Criterio}: Arquitectura
preparada para escalado horizontal. - \textbf{Prioridad}: Media.

\subsubsection{Seguridad}\label{seguridad}

\textbf{RNF-004: Autenticación} - \textbf{Descripción}: Control de
acceso seguro basado en JWT. - \textbf{Criterio}: - Tokens con
expiración de 1 hora. - Refresh tokens con rotación. - Logout que
invalida tokens. - \textbf{Prioridad}: Alta.

\textbf{RNF-005: Autorización} - \textbf{Descripción}: Control granular
de permisos por rol. - \textbf{Criterio}: Verificación de permisos en
cada operación sensible. - \textbf{Prioridad}: Alta.

\textbf{RNF-006: Protección de datos} - \textbf{Descripción}:
Cumplimiento de RGPD para datos personales. - \textbf{Criterio}: -
Cifrado de datos sensibles. - Logs de auditoría. - Políticas de
retención. - \textbf{Prioridad}: Alta.

\subsubsection{Usabilidad}\label{usabilidad}

\textbf{RNF-007: Interfaz intuitiva} - \textbf{Descripción}: Facilidad
de uso para usuarios no técnicos. - \textbf{Criterio}: Curva de
aprendizaje \textless{} 30 minutos para operaciones básicas. -
\textbf{Prioridad}: Alta.

\textbf{RNF-008: Responsive design} - \textbf{Descripción}:
Adaptabilidad a diferentes dispositivos. - \textbf{Criterio}:
Funcionalidad completa en desktop, tablet y móvil. - \textbf{Prioridad}:
Media.

\textbf{RNF-009: Accesibilidad} - \textbf{Descripción}: Cumplimiento de
estándares de accesibilidad. - \textbf{Criterio}: Nivel AA de WCAG 2.1.
- \textbf{Prioridad}: Media.

\subsubsection{Confiabilidad}\label{confiabilidad}

\textbf{RNF-010: Disponibilidad} - \textbf{Descripción}: Sistema
disponible durante horario académico. - \textbf{Criterio}: 99.5\% uptime
en horario académico (8:00-20:00). - \textbf{Prioridad}: Alta.

\textbf{RNF-011: Recuperación de errores} - \textbf{Descripción}:
Capacidad de recuperación ante fallos. - \textbf{Criterio}: RTO
\textless{} 4 horas, RPO \textless{} 1 hora. - \textbf{Prioridad}:
Media.

\textbf{RNF-012: Consistencia de datos} - \textbf{Descripción}:
Integridad y consistencia de información. - \textbf{Criterio}:
Transacciones ACID, validación de integridad referencial. -
\textbf{Prioridad}: Alta.

\section{Garantía de calidad}\label{garantuxeda-de-calidad}

Habiendo completado la especificación de requisitos, es fundamental
abordar los aspectos relacionados con la garantía de calidad del
sistema. Esta sección establece los mecanismos y procedimientos
necesarios para asegurar que el sistema desarrollado cumpla con los
estándares de calidad requeridos, tanto en términos de seguridad como de
rendimiento y confiabilidad.

La garantía de calidad no se limita únicamente a la fase de desarrollo,
sino que abarca todo el ciclo de vida del sistema, incluyendo las fases
de diseño, implementación, pruebas y mantenimiento. Para ello, se
definen criterios específicos de seguridad, estrategias de testing y
validación, así como protocolos de monitorización y mantenimiento
continuo.

\subsection{Seguridad}\label{seguridad-1}

La seguridad del sistema se implementa mediante múltiples capas de
protección que abarcan desde la autenticación hasta la protección de
datos en tránsito y reposo..

\subsubsection{Autenticación y
autorización}\label{autenticaciuxf3n-y-autorizaciuxf3n}

\textbf{Sistema JWT implementado}: - \textbf{Access tokens}: Duración de
1 hora con payload mínimo (ID usuario, roles, timestamp). -
\textbf{Refresh tokens}: Duración de 30 días con rotación automática en
cada uso. - \textbf{Algoritmo de firma}: RS256 con claves asimétricas
para máxima seguridad. - \textbf{Revocación}: Lista negra de tokens
comprometidos con limpieza automática.

\textbf{Control de acceso basado en roles (RBAC)}: - \textbf{Jerarquía
de roles}: ADMIN \textgreater{} PRESIDENTE\_TRIBUNAL \textgreater{}
PROFESOR \textgreater{} ESTUDIANTE. - \textbf{Permisos granulares}:
Verificación a nivel de endpoint y recurso específico. -
\textbf{Validación doble}: Frontend para UX, backend para seguridad
crítica.

\subsubsection{Protección de datos}\label{protecciuxf3n-de-datos}

\textbf{Cifrado de datos}: - \textbf{En tránsito}: HTTPS/TLS 1.3
obligatorio en producción. - \textbf{En reposo}: Cifrado AES-256 para
campos sensibles (passwords, datos personales). - \textbf{Archivos PDF}:
Almacenamiento seguro con URLs firmadas temporalmente.

\textbf{Validación y sanitización}: - \textbf{Input validation}:
Validación estricta en backend para todos los inputs. - \textbf{SQL
injection}: Uso exclusivo de prepared statements con Doctrine ORM. -
\textbf{XSS protection}: Sanitización automática en frontend y CSP
headers. - \textbf{File upload}: Validación de tipo MIME, tamaño y
escaneo de malware.

\subsubsection{Auditoría y logs}\label{auditoruxeda-y-logs}

\textbf{Sistema de logs implementado}: - \textbf{Eventos de seguridad}:
Login, logout, cambios de permisos, accesos denegados. -
\textbf{Operaciones críticas}: Cambios de estado TFG, uploads,
modificaciones de usuarios. - \textbf{Retención}: Logs conservados 12
meses con rotación automática. - \textbf{Alertas}: Notificaciones
automáticas para patrones de actividad sospechosa.

\subsection{Interoperabilidad}\label{interoperabilidad}

\subsubsection{APIs REST estándar}\label{apis-rest-estuxe1ndar}

\textbf{Diseño RESTful}: - \textbf{Recursos bien definidos}: URLs
descriptivas siguiendo convenciones REST. - \textbf{Métodos HTTP
apropiados}: GET (lectura), POST (creación), PUT (actualización), DELETE
(eliminación). - \textbf{Códigos de estado consistentes}: 200 (OK), 201
(Created), 400 (Bad Request), 401 (Unauthorized), 403 (Forbidden), 404
(Not Found), 500 (Internal Error). - \textbf{Content negotiation}:
Soporte para JSON con posibilidad de extensión a XML.

\textbf{Documentación automática}: - \textbf{OpenAPI 3.0}:
Especificación completa generada automáticamente por API Platform. -
\textbf{Swagger UI}: Interface interactiva para testing y exploración de
APIs. - \textbf{Postman collections}: Colecciones exportables para
testing automatizado.

\subsubsection{Formato de datos
estándar}\label{formato-de-datos-estuxe1ndar}

\textbf{Serialización JSON}: - \textbf{HAL+JSON}: Links hipermedia para
navegabilidad de recursos relacionados. - \textbf{Paginación}: Metadata
estándar con total, página actual, enlaces siguiente/anterior. -
\textbf{Filtrado}: Query parameters consistentes para búsqueda y
filtrado. - \textbf{Versionado}: Headers de versión para evolución de
APIs sin breaking changes.

\subsection{Operabilidad}\label{operabilidad}

\subsubsection{Monitorización}\label{monitorizaciuxf3n}

\textbf{Métricas de aplicación}: - \textbf{Performance}: Tiempo de
respuesta por endpoint, throughput, latencia P95/P99. -
\textbf{Errores}: Rate de errores, tipos de error más frecuentes, stack
traces. - \textbf{Uso}: Usuarios activos, operaciones más utilizadas,
patrones de uso.

\textbf{Health checks}: - \textbf{Endpoint /health}: Estado de la
aplicación, base de datos, servicios externos. - \textbf{Métricas de
infraestructura}: CPU, memoria, disco, conexiones de BD. -
\textbf{Alertas proactivas}: Notificaciones antes de que los problemas
afecten usuarios.

\subsubsection{Mantenibilidad}\label{mantenibilidad}

\textbf{Arquitectura limpia}: - \textbf{Separación de
responsabilidades}: Capas bien definidas (presentación, lógica,
persistencia). - \textbf{Dependency injection}: Inversión de control
para testing y flexibilidad. - \textbf{Principios SOLID}: Código
mantenible y extensible.

\textbf{Documentación técnica}: - \textbf{README actualizado}:
Instrucciones de instalación, configuración, desarrollo. -
\textbf{Comentarios en código}: Documentación inline para lógica
compleja. - \textbf{Architectural Decision Records (ADR)}: Registro de
decisiones técnicas importantes.

\subsection{Transferibilidad}\label{transferibilidad}

\subsubsection{Containerización}\label{containerizaciuxf3n}

\textbf{Docker para desarrollo}: - \textbf{DDEV}: Entorno de desarrollo
reproducible con Docker. - \textbf{Servicios aislados}: Web, base de
datos, email, cache en contenedores separados. - \textbf{Configuración
compartida}: docker-compose.yml versionado en repositorio.

\textbf{Preparación para producción}: - \textbf{Multistage builds}:
Imágenes optimizadas para producción. - \textbf{Environment variables}:
Configuración externalizada para diferentes entornos. - \textbf{Health
checks}: Verificaciones de salud integradas en contenedores.

\subsubsection{Despliegue automatizado}\label{despliegue-automatizado}

\textbf{CI/CD Pipeline}: - \textbf{GitHub Actions}: Automatización de
testing, build y deploy. - \textbf{Testing automatizado}: Ejecución de
tests unitarios e integración en cada commit. - \textbf{Deploy scripts}:
Automatización de despliegue a diferentes entornos.

\subsection{Eficiencia}\label{eficiencia}

\subsubsection{Optimización frontend}\label{optimizaciuxf3n-frontend}

\textbf{React performance}: - \textbf{Code splitting}: Carga lazy de
componentes por ruta. - \textbf{Memoization}: useMemo y useCallback para
optimizar re-renders. - \textbf{Virtual scrolling}: Para listas largas
de TFGs o usuarios. - \textbf{Bundle optimization}: Tree shaking y
minificación con Vite.

\textbf{Caching estratégico}: - \textbf{Browser caching}: Headers
apropiados para assets estáticos. - \textbf{React Query}: Caching
inteligente de datos de APIs. - \textbf{Service Workers}: Cache offline
para funcionalidad básica.

\subsubsection{Optimización backend}\label{optimizaciuxf3n-backend}

\textbf{Base de datos}: - \textbf{Índices optimizados}: Índices
compuestos para queries frecuentes. - \textbf{Query optimization}:
Análisis de explain plans, evitar N+1 queries. - \textbf{Connection
pooling}: Gestión eficiente de conexiones de BD. - \textbf{Lazy
loading}: Carga diferida de relaciones no críticas.

\textbf{API optimization}: - \textbf{Response compression}: Gzip para
reducir payload. - \textbf{Pagination}: Limitación de resultados para
evitar respuestas masivas. - \textbf{Field selection}: Permitir
especificar campos requeridos en responses. - \textbf{Rate limiting}:
Prevención de abuso con limitación de requests.

\subsection{Mantenibilidad}\label{mantenibilidad-1}

\subsubsection{Calidad de código}\label{calidad-de-cuxf3digo}

\textbf{Estándares de codificación}: - \textbf{ESLint + Prettier}:
Formateo automático y reglas de calidad JavaScript. - \textbf{PHP CS
Fixer}: Estándares PSR-12 para código PHP. - \textbf{PHPStan}: Análisis
estático nivel 8 para detección temprana de errores. -
\textbf{Conventional commits}: Mensajes de commit estructurados para
changelog automático.

\textbf{Testing estratégico}: - \textbf{Unit tests}: 80\%+ coverage para
lógica de negocio crítica. - \textbf{Integration tests}: Validación de
APIs y flujos completos. - \textbf{E2E tests}: Casos de usuario críticos
automatizados. - \textbf{Visual regression}: Detección de cambios no
intencionados en UI.

\subsubsection{Arquitectura mantenible}\label{arquitectura-mantenible}

\textbf{Patrones de diseño}: - \textbf{Repository pattern}: Abstracción
de persistencia de datos. - \textbf{Factory pattern}: Creación de
objetos complejos. - \textbf{Observer pattern}: Sistema de eventos para
notificaciones. - \textbf{Strategy pattern}: Diferentes estrategias de
validación y procesamiento.

\section{Gestión del presupuesto}\label{gestiuxf3n-del-presupuesto}

Para completar el análisis del sistema, es esencial evaluar los aspectos
económicos del proyecto. La gestión del presupuesto proporciona una
perspectiva financiera que permite determinar la viabilidad económica
del desarrollo y establecer las bases para la justificación de la
inversión realizada.

En el contexto de un proyecto académico como este TFG, la gestión
presupuestaria adquiere características particulares, ya que se basa
principalmente en la valorización del tiempo de desarrollo, el uso de
herramientas y recursos educativos, así como en la estimación de los
costos que tendría el proyecto en un entorno profesional real. Esta
evaluación resulta fundamental para comprender el valor del trabajo
realizado y su equivalencia en términos de mercado.

\subsection{Estructura de costos}\label{estructura-de-costos}

El proyecto se desarrolla en modalidad académica con recursos
principalmente de tiempo de desarrollo, herramientas open source y
servicios gratuitos para educación..

\subsubsection{Costos de desarrollo}\label{costos-de-desarrollo}

\textbf{Tiempo de desarrollo}: - \textbf{Total estimado}: 400 horas de
desarrollo durante 10 semanas. - \textbf{Distribución semanal}: 40
horas/semana promedio con picos en fases críticas. - \textbf{Valor hora
de desarrollo junior}: €15/hora (referencia mercado). - \textbf{Costo
total de desarrollo}: €6,000 (estimación teórica).

\textbf{Fases con mayor intensidad}: - Fase 7 (Backend Symfony): 80
horas. - Fase 3-4 (Módulos usuario): 120 horas. - Fase 8 (Testing y
deploy): 60 horas.

\subsubsection{Infraestructura y
herramientas}\label{infraestructura-y-herramientas}

\textbf{Herramientas de desarrollo} (gratuitas para estudiantes): -
\textbf{GitHub Education Pack}: Repositorio privado, GitHub Actions
gratuitas. - \textbf{DDEV}: Herramienta open source gratuita. -
\textbf{VS Code}: IDE gratuito con extensiones. - \textbf{Draw.io}:
Diagramas UML gratuitos.

\textbf{Infraestructura de desarrollo}: - \textbf{Desarrollo local}: Sin
costo (máquina personal). - \textbf{Base de datos}: MySQL en contenedor
local. - \textbf{Testing}: Servicios locales con DDEV.

\subsubsection{Costos de producción
estimados}\label{costos-de-producciuxf3n-estimados}

\textbf{Hosting y dominio} (mensual): - \textbf{VPS básico}: €10-20/mes
(2GB RAM, 1 CPU, 40GB SSD). - \textbf{Dominio}: €10/año. -
\textbf{Certificado SSL}: Gratuito (Let's Encrypt). - \textbf{Email
transaccional}: €0 (hasta 100 emails/día con servicios gratuitos).

\textbf{Escalabilidad futura}: - \textbf{CDN}: €0-5/mes (Cloudflare free
tier). - \textbf{Backup}: €5-10/mes (almacenamiento cloud). -
\textbf{Monitoring}: €0-15/mes (New Relic, DataDog tier gratuito).

\subsection{Return on Investment (ROI)}\label{return-on-investment-roi}

\subsubsection{Beneficios
cuantificables}\label{beneficios-cuantificables}

\textbf{Ahorro en tiempo administrativo}: - \textbf{Gestión manual
actual}: 2 horas/TFG por administrativo. - \textbf{TFG procesados
anualmente}: 200 (estimación universidad media). - \textbf{Ahorro
total}: 400 horas/año. - \textbf{Valor por hora administrativa}:
€20/hora. - \textbf{Ahorro anual}: €8,000.

\textbf{Reducción de errores}: - \textbf{Errores manuales}: 5\% de TFG
con errores de proceso. - \textbf{Costo promedio de corrección}: €50 por
error. - \textbf{Ahorro en correcciones}: €500/año.

\subsubsection{Beneficios intangibles}\label{beneficios-intangibles}

\textbf{Mejora en satisfacción}: - \textbf{Estudiantes}: Mayor
transparencia y seguimiento en tiempo real. - \textbf{Profesores}:
Herramientas digitales que facilitan supervisión. -
\textbf{Administración}: Reporting automático y métricas precisas.

\textbf{Modernización académica}: - \textbf{Imagen institucional}:
Universidad tecnológicamente avanzada. - \textbf{Preparación futura}:
Base para expansión a otros procesos académicos. -
\textbf{Competitividad}: Ventaja frente a instituciones con procesos
manuales.

\subsection{Análisis de viabilidad
económica}\label{anuxe1lisis-de-viabilidad-econuxf3mica}

\subsubsection{Punto de equilibrio}\label{punto-de-equilibrio}

\textbf{Inversión inicial}: €6,000 (desarrollo) + €200 (infraestructura
año 1) = €6,200.\\
\textbf{Ahorro anual}: €8,500 (tiempo + errores).\\
\textbf{Tiempo de recuperación}: 8.7 meses.

\textbf{Proyección a 3 años}: - \textbf{Inversión total}: €6,200 + (€300
× 3 años) = €7,100. - \textbf{Ahorros totales}: €8,500 × 3 = €25,500. -
\textbf{ROI}: 259\% en 3 años.

\subsubsection{Análisis de
sensibilidad}\label{anuxe1lisis-de-sensibilidad}

\textbf{Escenario conservador} (50\% de beneficios estimados): -
\textbf{Ahorro anual}: €4,250. - \textbf{ROI}: 79\% en 3 años.

\textbf{Escenario optimista} (expansión a otros procesos): -
\textbf{Ahorro anual}: €15,000 (incluyendo otros procesos académicos). -
\textbf{ROI}: 534\% en 3 años.

La viabilidad económica es positiva en todos los escenarios analizados,
con recuperación de inversión en menos de 1 año en el escenario base.

\chapter{Diseño}\label{diseuxf1o}
Una vez completado el análisis del sistema, procederemos con la fase de
diseño, la cual constituye el puente entre los requisitos identificados
y la implementación técnica del proyecto. En este capítulo se
desarrollarán los aspectos fundamentales del diseño del sistema,
abarcando desde la arquitectura general hasta los detalles específicos
de implementación.

El diseño del sistema se estructura en varias dimensiones
complementarias que garantizan una solución integral y robusta. En
primer lugar, se presenta la arquitectura física, que define la
organización estructural de los componentes del sistema y sus
interacciones. Posteriormente, se aborda la arquitectura lógica,
estableciendo los patrones de diseño y las responsabilidades de cada
módulo. Finalmente, se incluye el esquema de la base de datos y el
diseño de la interfaz de usuario, elementos esenciales para completar la
visión técnica del proyecto.

\section{Arquitectura física}\label{arquitectura-fuxedsica}

Iniciando con la arquitectura física del sistema, se establece la base
estructural sobre la cual se construye toda la plataforma. Esta
arquitectura define la organización de los componentes de hardware y
software, así como sus interacciones y dependencias, proporcionando una
visión clara de cómo se despliega y ejecuta el sistema en un entorno
real.

La arquitectura física de la Plataforma de Gestión de TFG se basa en una
separación clara entre capas de presentación, lógica de negocio y
persistencia, implementando un patrón de arquitectura distribuida que
garantiza escalabilidad, mantenibilidad y seguridad..

\subsection{Módulo frontend (Capa de
presentación)}\label{muxf3dulo-frontend-capa-de-presentaciuxf3n}

El frontend constituye la capa de presentación del sistema, desarrollado
como una Single Page Application (SPA) que se ejecuta completamente en
el navegador del usuario..

\subsubsection{Arquitectura de componentes
React}\label{arquitectura-de-componentes-react}

La arquitectura de componentes React implementa un patrón jerárquico que facilita la reutilización, mantenimiento y escalabilidad del código frontend. Esta estructura modular permite una clara separación de responsabilidades y optimiza el rendimiento mediante técnicas de lazy loading y memoización, como se ilustra en la Figura~\ref{fig:arquitectura-componentes-react}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Arquitectura de componentes React}]{processed/images/05_diseno_plantuml_0.png}}
\caption{Arquitectura de componentes React}
\label{fig:arquitectura-componentes-react}
\end{figure}

\textbf{Componentes principales}:

\begin{itemize}
\tightlist
\item
  \textbf{Layout Component}: Contenedor principal que gestiona la
  estructura visual global.
\item
  \textbf{Navigation}: Sistema de navegación dinámico basado en roles de
  usuario.
\item
  \textbf{Protected Routes}: Wrapper que controla acceso a rutas según
  autenticación y permisos.
\item
  \textbf{Page Components}: Componentes de página específicos para cada
  funcionalidad.
\end{itemize}

\textbf{Patrones de diseño implementados}:

\begin{itemize}
\tightlist
\item
  \textbf{Component Composition}: Composición de funcionalidades
  mediante componentes reutilizables.
\item
  \textbf{Higher-Order Components}: ProtectedRoute como HOC para control
  de acceso.
\item
  \textbf{Render Props}: Componentes que exponen funcionalidad mediante
  props de función.
\item
  \textbf{Custom Hooks}: Abstracción de lógica de negocio reutilizable
  entre componentes.
\end{itemize}

\subsubsection{Gestión de estado
global}\label{gestiuxf3n-de-estado-global}

\textbf{Estrategia Context API}:

\begin{lstlisting}
// AuthContext - Gestión de autenticación y usuario actual
const AuthContext = {
  user: User | null,
  token: string | null,
  isAuthenticated: boolean,
  login: (credentials) => Promise<void>,
  logout: () => void,
  refreshToken: () => Promise<void>
}

// NotificacionesContext - Sistema de notificaciones globales
const NotificacionesContext = {
  notifications: Notification[],
  addNotification: (notification) => void,
  removeNotification: (id) => void,
  markAsRead: (id) => void
}
\end{lstlisting}

\textbf{Custom Hooks Architecture}: - \textbf{useTFGs}: Gestión completa
del ciclo de vida de TFG (CRUD, estados, archivos). -
\textbf{useUsuarios}: Administración de usuarios para rol admin. -
\textbf{useTribunales}: Gestión de tribunales y asignación de miembros.
- \textbf{useCalendario}: Integración con FullCalendar y gestión de
eventos. - \textbf{useReportes}: Generación y exportación de reportes
estadísticos.

\subsubsection{Comunicación con
backend}\label{comunicaciuxf3n-con-backend}

\textbf{Configuración del Cliente HTTP}:

\begin{lstlisting}
// Axios instance con interceptores
const apiClient = axios.create({
  baseURL: process.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
});

// Request interceptor para JWT
apiClient.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('access_token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  }
);

// Response interceptor para manejo de errores
apiClient.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      // Redirect to login
    }
    return Promise.reject(error);
  }
);
\end{lstlisting}

\textbf{Service Layer Pattern}: - \textbf{AuthService}: Autenticación,
registro, refresh tokens. - \textbf{TFGService}: Operaciones CRUD de
TFG, upload de archivos. - \textbf{UserService}: Gestión de usuarios
para administradores. - \textbf{TribunalService}: Gestión de tribunales
y defensas. - \textbf{NotificationService}: Sistema de notificaciones.

\subsection{Módulo backend (Capa de lógica de
negocio)}\label{muxf3dulo-backend-capa-de-luxf3gica-de-negocio}

El backend implementa una arquitectura hexagonal (puertos y adaptadores)
usando Symfony 6.4 LTS, proporcionando APIs REST robustas y escalables..

\subsubsection{Arquitectura hexagonal}\label{arquitectura-hexagonal}

La arquitectura hexagonal, también conocida como arquitectura de puertos y adaptadores, permite aislar la lógica de negocio de las dependencias externas, facilitando el testing, la mantenibilidad y la evolución del sistema. Esta aproximación garantiza que los cambios en tecnologías específicas no impacten el core del negocio, como se representa en la Figura~\ref{fig:arquitectura-hexagonal}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Arquitectura hexagonal}]{processed/images/05_diseno_plantuml_1.png}}
\caption{Arquitectura hexagonal}
\label{fig:arquitectura-hexagonal}
\end{figure}

\textbf{Capas de la arquitectura}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Domain Layer}: Lógica de negocio pura, independiente de
  frameworks.
\item
  \textbf{Application Layer}: Casos de uso y servicios de aplicación.
\item
  \textbf{Infrastructure Layer}: Implementaciones concretas (BD,
  servicios externos).
\item
  \textbf{Interface Layer}: Controladores API y serialización.
\end{enumerate}

\subsubsection{Estructura de directorios
Symfony}\label{estructura-de-directorios-symfony}

\begin{lstlisting}
src/
├── Controller/           # API Controllers
│   ├── AuthController.php
│   ├── TFGController.php
│   ├── UserController.php
│   └── TribunalController.php
├── Entity/               # Doctrine Entities
│   ├── User.php
│   ├── TFG.php
│   ├── Tribunal.php
│   ├── Defensa.php
│   └── Notificacion.php
├── Repository/           # Data Access Layer
│   ├── UserRepository.php
│   ├── TFGRepository.php
│   └── TribunalRepository.php
├── Service/              # Business Services
│   ├── TFGStateManager.php
│   ├── NotificationService.php
│   └── FileUploadService.php
├── Security/             # Authentication & Authorization
│   ├── JWTAuthenticator.php
│   ├── UserProvider.php
│   └── Voter/
├── Serializer/           # API Serialization
│   └── Normalizer/
└── EventListener/        # Event Handling
    ├── TFGStateListener.php
    └── UserActivityListener.php
\end{lstlisting}

\subsubsection{Configuración API
Platform}\label{configuraciuxf3n-api-platform}

\textbf{Ejemplo de configuración de Recursos}:

\begin{lstlisting}[language=PHP]
<?php
// src/Entity/TFG.php
#[ApiResource(
    operations: [
        new GetCollection(
            uriTemplate: '/tfgs/mis-tfgs',
            security: "is_granted('ROLE_USER')"
        ),
        new Post(
            security: "is_granted('ROLE_ESTUDIANTE')",
            processor: TFGCreateProcessor::class
        ),
        new Put(
            security: "is_granted('TFG_EDIT', object)",
            processor: TFGUpdateProcessor::class
        )
    ],
    normalizationContext: ['groups' => ['tfg:read']],
    denormalizationContext: ['groups' => ['tfg:write']]
)]
class TFG
{
    // Entity implementation
}
\end{lstlisting}

\subsection{Módulo de base de datos (Capa de
persistencia)}\label{muxf3dulo-de-base-de-datos-capa-de-persistencia}

La capa de persistencia utiliza MySQL 8.0 como sistema de gestión de
base de datos, implementando un diseño relacional optimizado con
Doctrine ORM..

\subsubsection{Estrategia de
persistencia}\label{estrategia-de-persistencia}

\textbf{Configuración de Doctrine ORM}:

\begin{lstlisting}
## config/packages/doctrine.yaml
doctrine:
    dbal:
        url: '%env(resolve:DATABASE_URL)%'
        charset: utf8mb4
        default_table_options:
            charset: utf8mb4
            collate: utf8mb4_unicode_ci
    orm:
        auto_generate_proxy_classes: true
        naming_strategy: doctrine.orm.naming_strategy.underscore_number_aware
        auto_mapping: true
        mappings:
            App:
                is_bundle: false
                type: attribute
                dir: '%kernel.project_dir%/src/Entity'
                prefix: 'App\Entity'
                alias: App
\end{lstlisting}

\textbf{Migration Strategy}: - \textbf{Versionado automático}: Doctrine
Migrations para control de esquema. - \textbf{Rollback capability}:
Posibilidad de rollback a versiones anteriores. - \textbf{Production
safety}: Validación antes de aplicar migraciones en producción.

\subsection{Módulo de archivos
(Almacenamiento)}\label{muxf3dulo-de-archivos-almacenamiento}

El sistema de archivos está diseñado para manejar uploads seguros de
documentos PDF con validación exhaustiva y almacenamiento optimizado..

\subsubsection{Configuración de
VichUploader}\label{configuraciuxf3n-de-vichuploader}

\begin{lstlisting}
## config/packages/vich_uploader.yaml
vich_uploader:
    db_driver: orm
    mappings:
        tfg_documents:
            uri_prefix: /uploads/tfgs
            upload_destination: '%kernel.project_dir%/public/uploads/tfgs'
            namer: Vich\UploaderBundle\Naming\SmartUniqueNamer
            inject_on_load: false
            delete_on_update: true
            delete_on_remove: true
\end{lstlisting}

\textbf{File Security Measures}: - \textbf{MIME type validation}: Solo
archivos PDF permitidos. - \textbf{Size limits}: Máximo 50MB por
archivo. - \textbf{Virus scanning}: Integración con ClamAV para escaneo
de malware. - \textbf{Access control}: URLs firmadas temporalmente para
descarga segura.

\subsubsection{Estrategia
Almacenamiento}\label{estrategia-almacenamiento}

La estrategia de almacenamiento de archivos implementa un sistema robusto y escalable que garantiza la integridad, seguridad y disponibilidad de los documentos TFG. Este diseño contempla validación automática, almacenamiento seguro y mecanismos de backup, como se detalla en la Figura~\ref{fig:estrategia-almacenamiento}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Estrategia Almacenamiento}]{processed/images/05_diseno_plantuml_2.png}}
\caption{Estrategia Almacenamiento}
\label{fig:estrategia-almacenamiento}
\end{figure}

\textbf{Flujo de procesamiento de archivos}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Validación previa}: MIME type, tamaño y estructura básica del
  PDF.
\item
  \textbf{Procesamiento seguro}: Almacenamiento con nombre único y path
  encriptado.
\item
  \textbf{Metadatos}: Extracción y almacenamiento de información del
  archivo.
\item
  \textbf{Acceso controlado}: URLs temporales con expiración automática.
\end{enumerate}

\section{Arquitectura lógica}\label{arquitectura-luxf3gica}

Habiendo establecido la arquitectura física del sistema, es fundamental
abordar la arquitectura lógica, la cual define la organización
conceptual y funcional de los componentes de software. Esta perspectiva
complementa la visión física proporcionando un entendimiento profundo de
cómo se estructura el código, se organizan las responsabilidades y se
implementan los patrones de diseño.

La arquitectura lógica trasciende la implementación específica para
establecer principios de diseño que aseguran la mantenibilidad,
extensibilidad y robustez del sistema. A través de esta organización
lógica, se garantiza que cada componente tenga responsabilidades bien
definidas y que las interacciones entre ellos sigan patrones
establecidos y probados en la industria del software.

La arquitectura lógica organiza los componentes del sistema según
responsabilidades funcionales, implementando patrones de diseño que
garantizan separación de concerns y alta cohesión..

\subsection{Capa de presentación
(Frontend)}\label{capa-de-presentaciuxf3n-frontend}

\subsubsection{Patrón
Container/Presentational}\label{patruxf3n-containerpresentational}

\textbf{Componentes de Container} (Smart Components):

\begin{lstlisting}
// pages/estudiante/MisTFGs.jsx
const MisTFGs = () => {
  const { tfgs, loading, error, createTFG, updateTFG } = useTFGs();
  const { user } = useAuth();
  
  // Lógica de negocio y obtención de datos
  useEffect(() => {
    fetchTFGsByStudent(user.id);
  }, [user.id]);
  
  return (
    <TFGsListPresentation 
      tfgs={tfgs}
      loading={loading}
      error={error}
      onCreateTFG={createTFG}
      onUpdateTFG={updateTFG}
    />
  );
};
\end{lstlisting}

\textbf{Componentes Presentational} (Dumb Components):

\begin{lstlisting}
// components/tfgs/TFGsListPresentation.jsx
const TFGsListPresentation = ({ 
  tfgs, 
  loading, 
  error, 
  onCreateTFG, 
  onUpdateTFG 
}) => {
  if (loading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    <div className="tfgs-list">
      {tfgs.map(tfg => (
        <TFGCard 
          key={tfg.id} 
          tfg={tfg} 
          onUpdate={onUpdateTFG} 
        />
      ))}
    </div>
  );
};
\end{lstlisting}

\subsubsection{State Management Pattern}\label{state-management-pattern}

\textbf{Hierarchical Context Structure}:

\begin{lstlisting}
// App.jsx - Contexto Raíz
<AuthProvider>
  <NotificacionesProvider>
    <Router>
      <Layout>
        <Routes>
          {/* Rutas de la Aplicación*/}
        </Routes>
      </Layout>
    </Router>
  </NotificacionesProvider>
</AuthProvider>
\end{lstlisting}

\textbf{Custom Hook Composition}:

\begin{lstlisting}
// hooks/useTFGs.js
const useTFGs = () => {
  const [tfgs, setTFGs] = useState([]);
  const [loading, setLoading] = useState(false);
  const { addNotification } = useNotifications();
  
  const fetchTFGs = useCallback(async () => {
    setLoading(true);
    try {
      const data = await TFGService.getMisTFGs();
      setTFGs(data);
    } catch (error) {
      addNotification({
        type: 'error',
        message: 'Error al cargar TFGs'
      });
    } finally {
      setLoading(false);
    }
  }, [addNotification]);
  
  return {
    tfgs,
    loading,
    fetchTFGs,
    createTFG: useCallback(/* ... */, []),
    updateTFG: useCallback(/* ... */, [])
  };
};
\end{lstlisting}

\subsection{Capa de lógica de negocio
(Backend)}\label{capa-de-luxf3gica-de-negocio-backend}

\subsubsection{Domain-Driven Design}\label{domain-driven-design}

\textbf{Aggregate Pattern}:

\begin{lstlisting}[language=PHP]
<?php
// src/Entity/TFG.php
class TFG
{
    private const VALID_TRANSITIONS = [
        'borrador' => ['revision'],
        'revision' => ['borrador', 'aprobado'],
        'aprobado' => ['defendido'],
        'defendido' => []
    ];
    
    public function changeState(string $newState, User $user): void
    {
        if (!$this->canTransitionTo($newState)) {
            throw new InvalidStateTransitionException();
        }
        
        if (!$this->userCanChangeState($user, $newState)) {
            throw new InsufficientPermissionsException();
        }
        
        $this->estado = $newState;
        $this->updatedAt = new \DateTime();
        
        // Dispatch domain event
        DomainEvents::raise(new TFGStateChanged($this, $newState));
    }
    
    private function canTransitionTo(string $state): bool
    {
        return in_array($state, self::VALID_TRANSITIONS[$this->estado] ?? []);
    }
}
\end{lstlisting}

\textbf{Clases Value}:

\begin{lstlisting}[language=PHP]
<?php
// src/ValueObject/Email.php
final class Email
{
    private string $value;
    
    public function __construct(string $email)
    {
        if (!filter_var($email, FILTER_VALIDATE_EMAIL)) {
            throw new InvalidEmailException($email);
        }
        
        $this->value = strtolower(trim($email));
    }
    
    public function getValue(): string
    {
        return $this->value;
    }
    
    public function equals(Email $other): bool
    {
        return $this->value === $other->value;
    }
}
\end{lstlisting}

\subsubsection{Patrón Service Layer}\label{patruxf3n-service-layer}

\textbf{Servicios de la Aplicación}:

\begin{lstlisting}[language=PHP]
<?php
// src/Service/TFGService.php
class TFGService
{
    public function __construct(
        private TFGRepository $tfgRepository,
        private NotificationService $notificationService,
        private EventDispatcherInterface $eventDispatcher
    ) {}
    
    public function createTFG(CreateTFGDTO $dto, User $student): TFG
    {
        $this->validateStudentCanCreateTFG($student);
        
        $tfg = new TFG(
            titulo: $dto->titulo,
            descripcion: $dto->descripcion,
            estudiante: $student,
            tutor: $this->findTutorById($dto->tutorId)
        );
        
        $this->tfgRepository->save($tfg);
        
        $this->notificationService->notifyTutorOfNewTFG($tfg);
        
        $this->eventDispatcher->dispatch(
            new TFGCreatedEvent($tfg),
            TFGCreatedEvent::NAME
        );
        
        return $tfg;
    }
}
\end{lstlisting}

\subsection{Capa de persistencia}\label{capa-de-persistencia}

\subsubsection{Repository Pattern}\label{repository-pattern}

\textbf{Interface Definition}:

\begin{lstlisting}[language=PHP]
<?php
// src/Repository/TFGRepositoryInterface.php
interface TFGRepositoryInterface
{
    public function findById(int $id): ?TFG;
    public function findByStudent(User $student): array;
    public function findByTutor(User $tutor): array;
    public function findByState(string $state): array;
    public function save(TFG $tfg): void;
    public function delete(TFG $tfg): void;
}
\end{lstlisting}

\textbf{Implementation de Doctrine}:

\begin{lstlisting}[language=PHP]
<?php
// src/Repository/TFGRepository.php
class TFGRepository extends ServiceEntityRepository implements TFGRepositoryInterface
{
    public function findByStudent(User $student): array
    {
        return $this->createQueryBuilder('t')
            ->where('t.estudiante = :student')
            ->setParameter('student', $student)
            ->orderBy('t.createdAt', 'DESC')
            ->getQuery()
            ->getResult();
    }
    
    public function findByTutorWithStats(User $tutor): array
    {
        return $this->createQueryBuilder('t')
            ->select('t, COUNT(c.id) as comment_count')
            ->leftJoin('t.comentarios', 'c')
            ->where('t.tutor = :tutor OR t.cotutor = :tutor')
            ->setParameter('tutor', $tutor)
            ->groupBy('t.id')
            ->orderBy('t.updatedAt', 'DESC')
            ->getQuery()
            ->getResult();
    }
}
\end{lstlisting}

\section{Esquema de la base de datos}\label{esquema-de-la-base-de-datos}

Completando el diseño arquitectónico del sistema, es esencial definir el
esquema de la base de datos, componente fundamental que sustenta toda la
funcionalidad del sistema mediante el almacenamiento y gestión eficiente
de la información. El diseño de la base de datos no solo determina cómo
se almacenan los datos, sino que también influye directamente en el
rendimiento, la integridad y la escalabilidad del sistema completo.

El esquema de base de datos propuesto sigue principios de normalización
que garantizan la consistencia y eliminan la redundancia, mientras que
los índices y constraints aseguran tanto el rendimiento como la
integridad referencial. Esta estructura de datos ha sido cuidadosamente
diseñada para soportar eficientemente todas las operaciones requeridas
por los diferentes módulos del sistema.

\subsection{Modelo conceptual}\label{modelo-conceptual}

El modelo conceptual de la base de datos representa las entidades principales del sistema y sus relaciones, proporcionando la base para la implementación física. Este diseño garantiza la integridad referencial, optimiza las consultas más frecuentes y establece la estructura de datos necesaria para soportar todas las funcionalidades del sistema, como se ilustra en la Figura~\ref{fig:modelo-conceptual}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Modelo conceptual}]{processed/images/05_diseno_plantuml_3.png}}
\caption{Modelo conceptual}
\label{fig:modelo-conceptual}
\end{figure}

\subsection{Normalización y
constraints}\label{normalizaciuxf3n-y-constraints}

\subsubsection{Tercera forma normal
(3NF)}\label{tercera-forma-normal-3nf}

El esquema cumple con la tercera forma normal mediante:

\textbf{Primera Forma Normal (1NF)}: - Todos los campos contienen
valores atómicos. - Campos JSON utilizados únicamente para datos
semi-estructurados (roles, palabras clave, metadata). - No hay grupos
repetitivos de columnas.

\textbf{Segunda Forma Normal (2NF)}: - Todas las tablas tienen claves
primarias definidas. - Todos los atributos no-clave dependen
completamente de la clave primaria. - No hay dependencias parciales.

\textbf{Tercera Forma Normal (3NF)}: - No existen dependencias
transitivas. - Cada atributo no-clave depende directamente de la clave
primaria.

\subsubsection{Constraints e integridad
referencial}\label{constraints-e-integridad-referencial}

\textbf{Primary Keys}:

\begin{lstlisting}[language=SQL]
ALTER TABLE users ADD CONSTRAINT pk_users PRIMARY KEY (id);
ALTER TABLE tfgs ADD CONSTRAINT pk_tfgs PRIMARY KEY (id);
ALTER TABLE tribunales ADD CONSTRAINT pk_tribunales PRIMARY KEY (id);
ALTER TABLE defensas ADD CONSTRAINT pk_defensas PRIMARY KEY (id);
\end{lstlisting}

\textbf{Foreign Keys}:

\begin{lstlisting}[language=SQL]
ALTER TABLE tfgs 
  ADD CONSTRAINT fk_tfg_estudiante 
  FOREIGN KEY (estudiante_id) REFERENCES users(id) ON DELETE RESTRICT;

ALTER TABLE tfgs 
  ADD CONSTRAINT fk_tfg_tutor 
  FOREIGN KEY (tutor_id) REFERENCES users(id) ON DELETE RESTRICT;

ALTER TABLE defensas 
  ADD CONSTRAINT fk_defensa_tfg 
  FOREIGN KEY (tfg_id) REFERENCES tfgs(id) ON DELETE CASCADE;
\end{lstlisting}

\textbf{Unique Constraints}:

\begin{lstlisting}[language=SQL]
ALTER TABLE users ADD CONSTRAINT uk_users_email UNIQUE (email);
ALTER TABLE users ADD CONSTRAINT uk_users_dni UNIQUE (dni);
ALTER TABLE defensas ADD CONSTRAINT uk_defensa_tfg UNIQUE (tfg_id);
\end{lstlisting}

\textbf{Check Constraints}:

\begin{lstlisting}[language=SQL]
ALTER TABLE tfgs 
  ADD CONSTRAINT ck_tfg_estado 
  CHECK (estado IN ('borrador', 'revision', 'aprobado', 'defendido'));

ALTER TABLE calificaciones 
  ADD CONSTRAINT ck_calificacion_notas 
  CHECK (
    nota_presentacion >= 0 AND nota_presentacion <= 10 AND
    nota_contenido >= 0 AND nota_contenido <= 10 AND
    nota_defensa >= 0 AND nota_defensa <= 10 AND
    nota_final >= 0 AND nota_final <= 10
  );
\end{lstlisting}

\subsection{Índices de rendimiento}\label{uxedndices-de-rendimiento}

\subsubsection{Índices principales}\label{uxedndices-principales}

\textbf{Índices de búsqueda frecuente}:

\begin{lstlisting}[language=SQL]
-- Búsquedas por estudiante (muy frecuente)
CREATE INDEX idx_tfgs_estudiante ON tfgs(estudiante_id);

-- Búsquedas por tutor (muy frecuente)  
CREATE INDEX idx_tfgs_tutor ON tfgs(tutor_id);

-- Búsquedas por estado (frecuente para reportes)
CREATE INDEX idx_tfgs_estado ON tfgs(estado);

-- Búsquedas de defensas por fecha (calendario)
CREATE INDEX idx_defensas_fecha ON defensas(fecha_defensa);

-- Notificaciones no leídas por usuario
CREATE INDEX idx_notificaciones_usuario_leida ON notificaciones(usuario_id, leida);
\end{lstlisting}

\textbf{Índices compuestos}:

\begin{lstlisting}[language=SQL]
-- Combinación frecuente: tutor + estado
CREATE INDEX idx_tfgs_tutor_estado ON tfgs(tutor_id, estado);

-- Tribunal disponible para programación
CREATE INDEX idx_tribunales_activo ON tribunales(activo, created_at);

-- Defensas por tribunal y fecha
CREATE INDEX idx_defensas_tribunal_fecha ON defensas(tribunal_id, fecha_defensa);
\end{lstlisting}

\subsubsection{Análisis de consultas}\label{anuxe1lisis-de-consultas}

\textbf{Query más frecuente - TFGs por tutor}:

\begin{lstlisting}[language=SQL]
EXPLAIN SELECT t.*, e.nombre as estudiante_nombre
FROM tfgs t 
INNER JOIN users e ON t.estudiante_id = e.id
WHERE t.tutor_id = ? 
ORDER BY t.updated_at DESC;

-- Usa índice: idx_tfgs_tutor
-- Rows examined: ~10-50 por profesor
-- Execution time: < 5ms
\end{lstlisting}

\textbf{Query compleja - Dashboard admin}:

\begin{lstlisting}[language=SQL]
EXPLAIN SELECT 
  COUNT(*) as total_tfgs,
  COUNT(CASE WHEN estado = 'borrador' THEN 1 END) as borradores,
  COUNT(CASE WHEN estado = 'revision' THEN 1 END) as en_revision,
  COUNT(CASE WHEN estado = 'aprobado' THEN 1 END) as aprobados,
  COUNT(CASE WHEN estado = 'defendido' THEN 1 END) as defendidos
FROM tfgs 
WHERE created_at >= DATE_SUB(CURDATE(), INTERVAL 1 YEAR);

-- Usa índice: idx_tfgs_estado + created_at
-- Query optimizada para agregaciones
\end{lstlisting}

\section{Diseño de la interfaz de
usuario}\label{diseuxf1o-de-la-interfaz-de-usuario}

Para completar la visión integral del diseño del sistema, es fundamental
abordar el diseño de la interfaz de usuario, elemento que determina la
experiencia y satisfacción de los usuarios finales. La interfaz de
usuario representa el punto de contacto entre el sistema y sus usuarios,
por lo que su diseño debe equilibrar funcionalidad, usabilidad y
estética para proporcionar una experiencia óptima a cada tipo de
usuario.

El diseño de la interfaz va más allá de la simple presentación visual,
abarcando aspectos como la arquitectura de la información, los patrones
de interacción, la accesibilidad y la adaptabilidad a diferentes
dispositivos. A través de un sistema de diseño coherente y bien
estructurado, se garantiza la consistencia visual y funcional en toda la
aplicación, facilitando tanto el uso como el mantenimiento futuro.

\subsection{Sistema de diseño}\label{sistema-de-diseuxf1o}

\subsubsection{Design System basado en Tailwind
CSS}\label{design-system-basado-en-tailwind-css}

\textbf{Color Palette}:

\begin{lstlisting}
/* Primary Colors - Academic Blue */
--color-primary-50: #eff6ff;
--color-primary-100: #dbeafe;
--color-primary-500: #3b82f6;
--color-primary-600: #2563eb;
--color-primary-700: #1d4ed8;

/* Semantic Colors */
--color-success: #10b981;  /* Aprobado, Defendido */
--color-warning: #f59e0b;  /* En Revisión */
--color-error: #ef4444;    /* Errores, Rechazado */
--color-info: #06b6d4;     /* Información, Borrador */

/* Neutral Grays */
--color-gray-50: #f9fafb;
--color-gray-100: #f3f4f6;
--color-gray-500: #6b7280;
--color-gray-900: #111827;
\end{lstlisting}

\textbf{Typography Scale}:

\begin{lstlisting}
/* Font Family */
font-family: 'Inter', system-ui, sans-serif;

/* Font Sizes */
text-xs: 0.75rem;     /* 12px - Metadatos */
text-sm: 0.875rem;    /* 14px - Cuerpo pequeño */
text-base: 1rem;      /* 16px - Cuerpo principal */
text-lg: 1.125rem;    /* 18px - Subtítulos */
text-xl: 1.25rem;     /* 20px - Títulos sección */
text-2xl: 1.5rem;     /* 24px - Títulos página */
text-3xl: 1.875rem;   /* 30px - Títulos principales */
\end{lstlisting}

\textbf{Spacing System}:

\begin{lstlisting}
/* Espaciado basado en 4px grid */
space-1: 0.25rem;  /* 4px */
space-2: 0.5rem;   /* 8px */
space-4: 1rem;     /* 16px - Base unit */
space-6: 1.5rem;   /* 24px */
space-8: 2rem;     /* 32px */
space-12: 3rem;    /* 48px */
\end{lstlisting}

\subsubsection{Componentes base
reutilizables}\label{componentes-base-reutilizables}

\textbf{Button Component System}:

\begin{lstlisting}
// components/ui/Button.jsx
const Button = ({ 
  variant = 'primary', 
  size = 'md', 
  children, 
  loading = false,
  ...props 
}) => {
  const baseClasses = 'inline-flex items-center justify-center font-medium rounded-md transition-colors focus:outline-none focus:ring-2';
  
  const variants = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-200 text-gray-900 hover:bg-gray-300 focus:ring-gray-500',
    danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500',
    outline: 'border border-gray-300 bg-white text-gray-700 hover:bg-gray-50'
  };
  
  const sizes = {
    sm: 'px-3 py-2 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg'
  };
  
  return (
    <button 
      className={`${baseClasses} ${variants[variant]} ${sizes[size]}`}
      disabled={loading}
      {...props}
    >
      {loading && <Spinner className="mr-2" />}
      {children}
    </button>
  );
};
\end{lstlisting}

\textbf{Form Components}:

\begin{lstlisting}
// components/ui/FormField.jsx
const FormField = ({ 
  label, 
  error, 
  required = false, 
  children 
}) => (
  <div className="space-y-1">
    <label className="block text-sm font-medium text-gray-700">
      {label}
      {required && <span className="text-red-500 ml-1">*</span>}
    </label>
    {children}
    {error && (
      <p className="text-sm text-red-600 flex items-center">
        <ExclamationIcon className="h-4 w-4 mr-1" />
        {error}
      </p>
    )}
  </div>
);
\end{lstlisting}

\subsection{Diseño responsive}\label{diseuxf1o-responsive}

\subsubsection{Breakpoints y grid
system}\label{breakpoints-y-grid-system}

\textbf{Responsive Breakpoints}:

\begin{lstlisting}
/* Mobile First Approach */
sm: 640px;   /* Small devices (landscape phones) */
md: 768px;   /* Medium devices (tablets) */
lg: 1024px;  /* Large devices (desktops) */
xl: 1280px;  /* Extra large devices */
2xl: 1536px; /* 2X Extra large devices */
\end{lstlisting}

\textbf{Grid Layout Pattern}:

\begin{lstlisting}
// Layout component responsive
const DashboardLayout = ({ children }) => (
  <div className="min-h-screen bg-gray-50">
    {/* Header */}
    <header className="bg-white shadow-sm border-b border-gray-200">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        {/* Navigation content */}
      </div>
    </header>
    
    {/* Main Content */}
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
      <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
        {/* Sidebar */}
        <aside className="lg:col-span-1">
          <Navigation />
        </aside>
        
        {/* Content */}
        <main className="lg:col-span-3">
          {children}
        </main>
      </div>
    </div>
  </div>
);
\end{lstlisting}

\subsubsection{Mobile-first components}\label{mobile-first-components}

\textbf{Responsive Table Pattern}:

\begin{lstlisting}
// components/TFGTable.jsx
const TFGTable = ({ tfgs }) => (
  <div className="overflow-hidden">
    {/* Desktop Table */}
    <div className="hidden md:block">
      <table className="min-w-full divide-y divide-gray-200">
        <thead className="bg-gray-50">
          <tr>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
              Título
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
              Estado
            </th>
            <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase">
              Fecha
            </th>
          </tr>
        </thead>
        <tbody className="bg-white divide-y divide-gray-200">
          {tfgs.map(tfg => (
            <TFGTableRow key={tfg.id} tfg={tfg} />
          ))}
        </tbody>
      </table>
    </div>
    
    {/* Mobile Cards */}
    <div className="md:hidden space-y-4">
      {tfgs.map(tfg => (
        <TFGMobileCard key={tfg.id} tfg={tfg} />
      ))}
    </div>
  </div>
);
\end{lstlisting}

\subsection{Wireframes y flujos de
usuario}\label{wireframes-y-flujos-de-usuario}

\subsubsection{Flujo principal -
Estudiante}\label{flujo-principal---estudiante}

El flujo principal del estudiante representa el recorrido típico que realiza un usuario con este rol desde el acceso inicial al sistema hasta la finalización del proceso de TFG. Este diagrama de flujo identifica los puntos de decisión, las interacciones críticas y los estados principales del proceso académico, como se muestra en la Figura~\ref{fig:flujo-principal-estudiante}.

\begin{figure}[H]
\centering
\pandocbounded{\includegraphics[keepaspectratio,alt={Flujo principal - Estudiante}]{processed/images/05_diseno_plantuml_4.png}}
\caption{Flujo principal - Estudiante}
\label{fig:flujo-principal-estudiante}
\end{figure}

\subsubsection{Wireframe - Dashboard
Estudiante}\label{wireframe---dashboard-estudiante}

\begin{lstlisting}
┌─────────────────────────────────────────────────────────────┐
│ [Logo] Plataforma TFG        [Notificaciones] [Usuario] [⚙] │
├─────────────────────────────────────────────────────────────┤
│ Dashboard > Mi TFG                                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│ ┌─────────────────┐  ┌───────────────────────────────────┐  │
│ │   Mi TFG        │  │         Estado Actual             │  │
│ │                 │  │                                   │  │
│ │ [📄] Título del    │    ● En Revisión                  │   │
│ │      TFG        │  │                                   │  │
│ │                 │  │    Enviado hace 3 días            │  │
│ │ [📤] Archivo:   │  │    Esperando feedback del tutor   │   │
│ │     tfg_v1.pdf  │  │                                   │  │
│ │                 │  │    [ Ver Timeline ]               │  │
│ └─────────────────┘  └───────────────────────────────────┘  │
│                                                             │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │                    Comentarios del Tutor                │ │
│ │ ┌─────────────────────────────────────────────────────┐ │ │
│ │ │ 👨‍🏫 Dr. García - hace 1 día                          │ │ │
│ │ │ "El abstract necesita ser más específico..."        │ │ │
│ │ └─────────────────────────────────────────────────────┘ │ │
│ └─────────────────────────────────────────────────────────┘ │
│                                                             │
│ [ Subir Nueva Versión ]  [ Editar Información ]             │
└─────────────────────────────────────────────────────────────┘
\end{lstlisting}

\subsubsection{Wireframe - Calendario de
Defensas}\label{wireframe---calendario-de-defensas}

\begin{lstlisting}
┌─────────────────────────────────────────────────────────────┐
│ Gestión de Defensas                      [Nuevo] [Filtros]  │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│      Octubre 2025                                           │
│ ┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐                 │
│ │ Dom │ Lun │ Mar │ Mié │ Jue │ Vie │ Sáb │                 │
│ ├─────┼─────┼─────┼─────┼─────┼─────┼─────┤                 │
│ │  1  │  2  │  3  │  4  │  5  │  6  │  7  │                 │
│ │     │     │     │     │[10h]│     │     │                 │
│ │     │     │     │     │TFG-1│     │     │                 │
│ ├─────┼─────┼─────┼─────┼─────┼─────┼─────┤                 │
│ │  8  │  9  │ 10  │ 11  │ 12  │ 13  │ 14  │                 │
│ │     │[9h] │     │[11h]│     │[16h]│     │                 │
│ │     │TFG-2│     │TFG-3│     │TFG-4│     │                 │
│ └─────┴─────┴─────┴─────┴─────┴─────┴─────┘                 │
│                                                             │
│ Próximas Defensas:                                          │
│ ┌─────────────────────────────────────────────────────────┐ │
│ │ 🕐 5 Oct, 10:00 - "Desarrollo de App Móvil"             │ │
│ │    Tribunal A • Aula 101 • Juan Pérez                   │ │
│ │    [ Ver Detalles ] [ Editar ]                          │ │
│ ├─────────────────────────────────────────────────────────┤ │
│ │ 🕘 9 Oct, 09:00 - "Machine Learning en Salud"           │ │
│ │    Tribunal B • Aula 205 • María López                  │ │
│ │    [ Ver Detalles ] [ Editar ]                          │ │
│ └─────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────┘
\end{lstlisting}

\chapter{Implementación}\label{implementaciuxf3n}
Tras haber completado las fases de análisis y diseño del sistema,
procederemos con la descripción detallada de la implementación del
proyecto. Este capítulo documenta cómo se han materializado los
requisitos y el diseño establecidos en las fases anteriores,
proporcionando una visión técnica completa del desarrollo realizado.

La implementación abarca múltiples aspectos técnicos que van desde la
arquitectura de componentes del frontend hasta las configuraciones
específicas de despliegue y las pruebas realizadas. Cada sección de este
capítulo detalla las decisiones técnicas tomadas, las herramientas
utilizadas y las buenas prácticas aplicadas durante el desarrollo,
ofreciendo tanto una guía para futuras modificaciones como una base para
la evaluación técnica del proyecto.

\section{Arquitectura de componentes
React}\label{arquitectura-de-componentes-react-1}

Iniciando con los aspectos técnicos más fundamentales de la
implementación, se presenta la arquitectura de componentes React que
constituye la base sobre la cual se construye todo el frontend de la
aplicación. Esta arquitectura define la organización del código, los
patrones de reutilización y la estructura general que facilita tanto el
desarrollo como el mantenimiento futuro del sistema.

La implementación del frontend se estructura siguiendo principios de
Clean Architecture adaptados a React, con una separación clara entre
lógica de presentación, estado global y comunicación con APIs.

\subsection{Estructura de directorios}\label{estructura-de-directorios}

\begin{lstlisting}
src/
├── components/           # Componentes reutilizables
│   ├── Layout.jsx       # Layout principal con navegación
│   ├── ProtectedRoute.jsx # Control de acceso por roles
│   ├── NotificacionesDropdown.jsx # Sistema notificaciones
│   ├── ui/              # Componentes base del design system
│   │   ├── Button.jsx
│   │   ├── Input.jsx
│   │   ├── Modal.jsx
│   │   └── LoadingSpinner.jsx
│   ├── forms/           # Componentes de formularios
│   │   ├── TFGForm.jsx
│   │   ├── UserForm.jsx
│   │   └── TribunalForm.jsx
│   └── calendario/      # Componentes específicos de calendario
├── pages/               # Páginas organizadas por rol
│   ├── auth/
│   │   ├── Login.jsx
│   │   └── Register.jsx
│   ├── dashboard/
│   │   └── Dashboard.jsx
│   ├── estudiante/
│   │   ├── MisTFGs.jsx
│   │   ├── NuevoTFG.jsx
│   │   ├── EditarTFG.jsx
│   │   ├── SeguimientoTFG.jsx
│   │   └── DefensaProgramada.jsx
│   ├── profesor/
│   │   ├── TFGsAsignados.jsx
│   │   ├── RevisarTFG.jsx
│   │   ├── CalificarTFG.jsx
│   │   ├── MisTribunales.jsx
│   │   └── CalendarioDefensas.jsx
│   └── admin/
│       ├── GestionUsuarios.jsx
│       └── Reportes.jsx
├── context/             # Gestión de estado global
│   ├── AuthContext.jsx
│   └── NotificacionesContext.jsx
├── hooks/               # Custom hooks con lógica de negocio
│   ├── useAuth.js
│   ├── useTFGs.js
│   ├── useUsuarios.js
│   ├── useTribunales.js
│   ├── useCalendario.js
│   └── useReportes.js
├── services/            # Comunicación con APIs
│   ├── api.js
│   ├── authService.js
│   ├── tfgService.js
│   ├── userService.js
│   └── tribunalService.js
└── utils/               # Utilidades y helpers
    ├── constants.js
    ├── validators.js
    └── formatters.js
\end{lstlisting}

\subsection{Implementación del sistema de
autenticación}\label{implementaciuxf3n-del-sistema-de-autenticaciuxf3n}

\subsubsection{AuthContext y Provider}\label{authcontext-y-provider}

\begin{lstlisting}
// src/context/AuthContext.jsx
import React, { createContext, useContext, useReducer, useEffect } from 'react';
import { authService } from '../services/authService';

const AuthContext = createContext();

const authReducer = (state, action) => {
  switch (action.type) {
    case 'LOGIN_START':
      return { ...state, loading: true, error: null };
    
    case 'LOGIN_SUCCESS':
      return {
        ...state,
        loading: false,
        isAuthenticated: true,
        user: action.payload.user,
        token: action.payload.token
      };
    
    case 'LOGIN_ERROR':
      return {
        ...state,
        loading: false,
        error: action.payload,
        isAuthenticated: false,
        user: null,
        token: null
      };
    
    case 'LOGOUT':
      return {
        ...state,
        isAuthenticated: false,
        user: null,
        token: null,
        error: null
      };
    
    case 'UPDATE_USER':
      return {
        ...state,
        user: { ...state.user, ...action.payload }
      };
    
    default:
      return state;
  }
};

const initialState = {
  isAuthenticated: false,
  user: null,
  token: null,
  loading: false,
  error: null
};

export const AuthProvider = ({ children }) => {
  const [state, dispatch] = useReducer(authReducer, initialState);

  // Inicialización desde localStorage.
  useEffect(() => {
    const token = localStorage.getItem('access_token');
    const userData = localStorage.getItem('user_data');
    
    if (token && userData) {
      try {
        const user = JSON.parse(userData);
        dispatch({
          type: 'LOGIN_SUCCESS',
          payload: { user, token }
        });
      } catch (error) {
        localStorage.removeItem('access_token');
        localStorage.removeItem('user_data');
      }
    }
  }, []);

  const login = async (credentials) => {
    dispatch({ type: 'LOGIN_START' });
    
    try {
      const response = await authService.login(credentials);
      
      localStorage.setItem('access_token', response.token);
      localStorage.setItem('user_data', JSON.stringify(response.user));
      
      dispatch({
        type: 'LOGIN_SUCCESS',
        payload: {
          user: response.user,
          token: response.token
        }
      });
      
      return response;
    } catch (error) {
      dispatch({
        type: 'LOGIN_ERROR',
        payload: error.message
      });
      throw error;
    }
  };

  const logout = () => {
    localStorage.removeItem('access_token');
    localStorage.removeItem('user_data');
    dispatch({ type: 'LOGOUT' });
  };

  const updateUser = (userData) => {
    const updatedUser = { ...state.user, ...userData };
    localStorage.setItem('user_data', JSON.stringify(updatedUser));
    dispatch({ type: 'UPDATE_USER', payload: userData });
  };

  const value = {
    ...state,
    login,
    logout,
    updateUser
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};
\end{lstlisting}

\subsubsection{Componente
ProtectedRoute}\label{componente-protectedroute}

\begin{lstlisting}
// src/components/ProtectedRoute.jsx
import React from 'react';
import { Navigate, useLocation } from 'react-router-dom';
import { useAuth } from '../context/AuthContext';
import LoadingSpinner from './ui/LoadingSpinner';

const ProtectedRoute = ({ 
  children, 
  requireRoles = [],
  redirectTo = '/login' 
}) => {
  const { isAuthenticated, user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <LoadingSpinner size="lg" />
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <Navigate 
        to={redirectTo} 
        state={{ from: location }} 
        replace 
      />
    );
  }

  // Verificar roles requeridos.
  if (requireRoles.length > 0) {
    const userRoles = user?.roles || [];
    const hasRequiredRole = requireRoles.some(role => 
      userRoles.includes(role)
    );

    if (!hasRequiredRole) {
      return (
        <Navigate 
          to="/unauthorized" 
          state={{ requiredRoles: requireRoles }} 
          replace 
        />
      );
    }
  }

  return children;
};

export default ProtectedRoute;
\end{lstlisting}

\subsection{Implementación de Hooks
Personalizados}\label{implementaciuxf3n-de-hooks-personalizados}

\subsubsection{useTFGs Hook}\label{usetfgs-hook}

\begin{lstlisting}
// src/hooks/useTFGs.js
import { useState, useEffect, useCallback } from 'react';
import { tfgService } from '../services/tfgService';
import { useNotifications } from '../context/NotificacionesContext';

export const useTFGs = () => {
  const [tfgs, setTFGs] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const { addNotification } = useNotifications();

  const fetchTFGs = useCallback(async (filters = {}) => {
    setLoading(true);
    setError(null);
    
    try {
      const data = await tfgService.getMisTFGs(filters);
      setTFGs(data);
    } catch (error) {
      setError(error.message);
      addNotification({
        type: 'error',
        titulo: 'Error al cargar TFGs',
        mensaje: error.message
      });
    } finally {
      setLoading(false);
    }
  }, [addNotification]);

  const createTFG = useCallback(async (tfgData) => {
    setLoading(true);
    
    try {
      const newTFG = await tfgService.createTFG(tfgData);
      setTFGs(prev => [newTFG, ...prev]);
      
      addNotification({
        type: 'success',
        titulo: 'TFG creado exitosamente',
        mensaje: `El TFG "${newTFG.titulo}" ha sido creado`
      });
      
      return newTFG;
    } catch (error) {
      addNotification({
        type: 'error',
        titulo: 'Error al crear TFG',
        mensaje: error.message
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, [addNotification]);

  const updateTFG = useCallback(async (id, tfgData) => {
    setLoading(true);
    
    try {
      const updatedTFG = await tfgService.updateTFG(id, tfgData);
      setTFGs(prev => prev.map(tfg => 
        tfg.id === id ? updatedTFG : tfg
      ));
      
      addNotification({
        type: 'success',
        titulo: 'TFG actualizado',
        mensaje: 'Los cambios han sido guardados exitosamente'
      });
      
      return updatedTFG;
    } catch (error) {
      addNotification({
        type: 'error',
        titulo: 'Error al actualizar TFG',
        mensaje: error.message
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, [addNotification]);

  const uploadFile = useCallback(async (tfgId, file, onProgress) => {
    try {
      const result = await tfgService.uploadFile(tfgId, file, onProgress);
      
      // Actualizar el TFG en el estado local.
      setTFGs(prev => prev.map(tfg => 
        tfg.id === tfgId 
          ? { ...tfg, archivo: result.archivo }
          : tfg
      ));
      
      addNotification({
        type: 'success',
        titulo: 'Archivo subido exitosamente',
        mensaje: `El archivo ${file.name} ha sido subido correctamente`
      });
      
      return result;
    } catch (error) {
      addNotification({
        type: 'error',
        titulo: 'Error al subir archivo',
        mensaje: error.message
      });
      throw error;
    }
  }, [addNotification]);

  const changeState = useCallback(async (tfgId, newState, comment = '') => {
    try {
      const updatedTFG = await tfgService.changeState(tfgId, newState, comment);
      
      setTFGs(prev => prev.map(tfg => 
        tfg.id === tfgId ? updatedTFG : tfg
      ));
      
      addNotification({
        type: 'success',
        titulo: 'Estado actualizado',
        mensaje: `El TFG ha cambiado a estado "${newState}"`
      });
      
      return updatedTFG;
    } catch (error) {
      addNotification({
        type: 'error',
        titulo: 'Error al cambiar estado',
        mensaje: error.message
      });
      throw error;
    }
  }, [addNotification]);

  return {
    tfgs,
    loading,
    error,
    fetchTFGs,
    createTFG,
    updateTFG,
    uploadFile,
    changeState
  };
};
\end{lstlisting}

\subsection{Componentes de interfaz
principales}\label{componentes-de-interfaz-principales}

\subsubsection{Componente Dashboard}\label{componente-dashboard}

\begin{lstlisting}
// src/pages/dashboard/Dashboard.jsx
import React, { useEffect, useState } from 'react';
import { useAuth } from '../../context/AuthContext';
import { useTFGs } from '../../hooks/useTFGs';
import { useNotifications } from '../../context/NotificacionesContext';

const Dashboard = () => {
  const { user } = useAuth();
  const { tfgs, fetchTFGs } = useTFGs();
  const { notifications } = useNotifications();
  
  const [stats, setStats] = useState({
    total: 0,
    enRevision: 0,
    aprobados: 0,
    defendidos: 0
  });

  useEffect(() => {
    if (user) {
      fetchTFGs();
    }
  }, [user, fetchTFGs]);

  useEffect(() => {
    if (tfgs.length > 0) {
      const newStats = tfgs.reduce((acc, tfg) => {
        acc.total++;
        switch (tfg.estado) {
          case 'revision':
            acc.enRevision++;
            break;
          case 'aprobado':
            acc.aprobados++;
            break;
          case 'defendido':
            acc.defendidos++;
            break;
        }
        return acc;
      }, { total: 0, enRevision: 0, aprobados: 0, defendidos: 0 });
      
      setStats(newStats);
    }
  }, [tfgs]);

  const getDashboardContent = () => {
    switch (user?.roles[0]) {
      case 'ROLE_ESTUDIANTE':
        return <EstudianteDashboard stats={stats} tfgs={tfgs} />;
      case 'ROLE_PROFESOR':
        return <ProfesorDashboard stats={stats} tfgs={tfgs} />;
      case 'ROLE_PRESIDENTE_TRIBUNAL':
        return <PresidenteDashboard stats={stats} />;
      case 'ROLE_ADMIN':
        return <AdminDashboard stats={stats} />;
      default:
        return <div>Rol no reconocido</div>;
    }
  };

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="bg-white shadow rounded-lg p-6">
        <h1 className="text-2xl font-bold text-gray-900">
          Bienvenido, {user?.nombre} {user?.apellidos}
        </h1>
        <p className="text-gray-600 mt-1">
          {getRoleDescription(user?.roles[0])}
        </p>
      </div>

      {/* Notificaciones recientes */}
      {notifications.filter(n => !n.leida).length > 0 && (
        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
          <h3 className="text-sm font-medium text-blue-800">
            Notificaciones pendientes ({notifications.filter(n => !n.leida).length})
          </h3>
          <div className="mt-2 space-y-1">
            {notifications.filter(n => !n.leida).slice(0, 3).map(notification => (
              <p key={notification.id} className="text-sm text-blue-700">
                • {notification.titulo}
              </p>
            ))}
          </div>
        </div>
      )}

      {/* Dashboard específico por rol */}
      {getDashboardContent()}
    </div>
  );
};

const getRoleDescription = (role) => {
  const descriptions = {
    'ROLE_ESTUDIANTE': 'Gestiona tu Trabajo de Fin de Grado',
    'ROLE_PROFESOR': 'Supervisa y evalúa TFGs asignados',
    'ROLE_PRESIDENTE_TRIBUNAL': 'Coordina tribunales y defensas',
    'ROLE_ADMIN': 'Administra el sistema y usuarios'
  };
  return descriptions[role] || 'Usuario del sistema';
};

export default Dashboard;
\end{lstlisting}

\section{Sistema de autenticación y
roles}\label{sistema-de-autenticaciuxf3n-y-roles}

Habiendo establecido la arquitectura base de componentes React,
procedemos con uno de los aspectos más críticos de cualquier sistema de
gestión: la implementación del sistema de autenticación y roles. Este
componente determina no solo quién puede acceder al sistema, sino
también qué acciones puede realizar cada usuario según su rol asignado,
constituyendo la base de la seguridad de toda la plataforma.

La implementación de la autenticación y autorización requiere una
coordinación precisa entre el frontend y el backend, utilizando
estándares de la industria como JWT (JSON Web Tokens) para el
intercambio seguro de información de autenticación. El sistema debe
garantizar tanto la seguridad como la usabilidad, proporcionando una
experiencia fluida al usuario mientras mantiene rigurosos controles de
acceso.

\subsection{Implementación backend con Symfony
Security}\label{implementaciuxf3n-backend-con-symfony-security}

\subsubsection{Configuración de
seguridad}\label{configuraciuxf3n-de-seguridad}

\begin{lstlisting}
## config/packages/security.yaml
security:
    password_hashers:
        App\Entity\User:
            algorithm: auto

    providers:
        app_user_provider:
            entity:
                class: App\Entity\User
                property: email

    firewalls:
        dev:
            pattern: ^/(_(profiler|wdt)|css|images|js)/
            security: false
            
        api:
            pattern: ^/api
            stateless: true
            jwt: ~
            
        main:
            lazy: true
            provider: app_user_provider

    access_control:
        - { path: ^/api/auth, roles: PUBLIC_ACCESS }
        - { path: ^/api/users, roles: ROLE_ADMIN }
        - { path: ^/api/tfgs/mis-tfgs, roles: ROLE_USER }
        - { path: ^/api/tfgs, roles: [ROLE_ESTUDIANTE, ROLE_ADMIN] }
        - { path: ^/api/tribunales, roles: [ROLE_PRESIDENTE_TRIBUNAL, ROLE_ADMIN] }
        - { path: ^/api, roles: IS_AUTHENTICATED_FULLY }

    role_hierarchy:
        ROLE_ADMIN: [ROLE_PRESIDENTE_TRIBUNAL, ROLE_PROFESOR, ROLE_ESTUDIANTE, ROLE_USER]
        ROLE_PRESIDENTE_TRIBUNAL: [ROLE_PROFESOR, ROLE_USER]
        ROLE_PROFESOR: [ROLE_ESTUDIANTE, ROLE_USER]
        ROLE_ESTUDIANTE: [ROLE_USER]
\end{lstlisting}

\subsubsection{Controlador de Autenticación
JWT.}\label{controlador-de-autenticaciuxf3n-jwt.}

\begin{lstlisting}[language=PHP]
<?php
// src/Controller/AuthController.php
namespace App\Controller;

use App\Entity\User;
use App\Service\AuthService;
use Lexik\Bundle\JWTAuthenticationBundle\Services\JWTTokenManagerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\PasswordHasher\Hasher\UserPasswordHasherInterface;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\CurrentUser;
use Symfony\Component\Serializer\SerializerInterface;
use Symfony\Component\Validator\Validator\ValidatorInterface;

#[Route('/api/auth')]
class AuthController extends AbstractController
{
    public function __construct(
        private UserPasswordHasherInterface $passwordHasher,
        private JWTTokenManagerInterface $jwtManager,
        private AuthService $authService,
        private SerializerInterface $serializer,
        private ValidatorInterface $validator
    ) {}

    #[Route('/login', name: 'api_login', methods: ['POST'])]
    public function login(#[CurrentUser] ?User $user): JsonResponse
    {
        if (!$user) {
            return $this->json([
                'message' => 'Credenciales inválidas'
            ], Response::HTTP_UNAUTHORIZED);
        }

        $token = $this->jwtManager->create($user);
        $refreshToken = $this->authService->createRefreshToken($user);

        return $this->json([
            'token' => $token,
            'refresh_token' => $refreshToken,
            'user' => [
                'id' => $user->getId(),
                'email' => $user->getEmail(),
                'nombre' => $user->getNombre(),
                'apellidos' => $user->getApellidos(),
                'roles' => $user->getRoles()
            ]
        ]);
    }

    #[Route('/refresh', name: 'api_refresh', methods: ['POST'])]
    public function refresh(Request $request): JsonResponse
    {
        $data = json_decode($request->getContent(), true);
        $refreshToken = $data['refresh_token'] ?? null;

        if (!$refreshToken) {
            return $this->json([
                'message' => 'Refresh token requerido'
            ], Response::HTTP_BAD_REQUEST);
        }

        try {
            $newToken = $this->authService->refreshToken($refreshToken);
            
            return $this->json([
                'token' => $newToken
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'message' => 'Token inválido o expirado'
            ], Response::HTTP_UNAUTHORIZED);
        }
    }

    #[Route('/me', name: 'api_me', methods: ['GET'])]
    public function me(#[CurrentUser] User $user): JsonResponse
    {
        return $this->json($user, Response::HTTP_OK, [], [
            'groups' => ['user:read']
        ]);
    }

    #[Route('/logout', name: 'api_logout', methods: ['POST'])]
    public function logout(Request $request): JsonResponse
    {
        $token = $request->headers->get('Authorization');
        
        if ($token && str_starts_with($token, 'Bearer ')) {
            $token = substr($token, 7);
            $this->authService->blacklistToken($token);
        }

        return $this->json([
            'message' => 'Logout exitoso'
        ]);
    }
}
\end{lstlisting}

\subsection{Voters para control granular de
permisos}\label{voters-para-control-granular-de-permisos}

\begin{lstlisting}[language=PHP]
<?php
// src/Security/TFGVoter.php
namespace App\Security;

use App\Entity\TFG;
use App\Entity\User;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Authorization\Voter\Voter;

class TFGVoter extends Voter
{
    public const EDIT = 'TFG_EDIT';
    public const VIEW = 'TFG_VIEW';
    public const DELETE = 'TFG_DELETE';
    public const CHANGE_STATE = 'TFG_CHANGE_STATE';

    protected function supports(string $attribute, mixed $subject): bool
    {
        return in_array($attribute, [self::EDIT, self::VIEW, self::DELETE, self::CHANGE_STATE])
            && $subject instanceof TFG;
    }

    protected function voteOnAttribute(string $attribute, mixed $subject, TokenInterface $token): bool
    {
        $user = $token->getUser();

        if (!$user instanceof User) {
            return false;
        }

        /** @var TFG $tfg */
        $tfg = $subject;

        return match($attribute) {
            self::VIEW => $this->canView($tfg, $user),
            self::EDIT => $this->canEdit($tfg, $user),
            self::DELETE => $this->canDelete($tfg, $user),
            self::CHANGE_STATE => $this->canChangeState($tfg, $user),
            default => false,
        };
    }

    private function canView(TFG $tfg, User $user): bool
    {
        // Admin puede ver todos.
        if (in_array('ROLE_ADMIN', $user->getRoles())) {
            return true;
        }

        // El estudiante puede ver su propio TFG.
        if ($tfg->getEstudiante() === $user) {
            return true;
        }

        // El tutor puede ver TFGs asignados.
        if ($tfg->getTutor() === $user || $tfg->getCotutor() === $user) {
            return true;
        }

        // Miembros del tribunal pueden ver TFGs para defensas programadas.
        if (in_array('ROLE_PROFESOR', $user->getRoles())) {
            $defensa = $tfg->getDefensa();
            if ($defensa && $this->isUserInTribunal($user, $defensa->getTribunal())) {
                return true;
            }
        }

        return false;
    }

    private function canEdit(TFG $tfg, User $user): bool
    {
        // Admin puede editar todos.
        if (in_array('ROLE_ADMIN', $user->getRoles())) {
            return true;
        }

        // El estudiante solo puede editar su TFG en estado borrador.
        if ($tfg->getEstudiante() === $user && $tfg->getEstado() === 'borrador') {
            return true;
        }

        return false;
    }

    private function canChangeState(TFG $tfg, User $user): bool
    {
        // Admin puede cambiar cualquier estado.
        if (in_array('ROLE_ADMIN', $user->getRoles())) {
            return true;
        }

        // El tutor puede cambiar estado de TFGs asignados.
        if (($tfg->getTutor() === $user || $tfg->getCotutor() === $user) 
            && in_array('ROLE_PROFESOR', $user->getRoles())) {
            return true;
        }

        return false;
    }

    private function isUserInTribunal(User $user, $tribunal): bool
    {
        if (!$tribunal) {
            return false;
        }

        return $tribunal->getPresidente() === $user ||
               $tribunal->getSecretario() === $user ||
               $tribunal->getVocal() === $user;
    }
}
\end{lstlisting}

\section{Gestión de estado con Context
API}\label{gestiuxf3n-de-estado-con-context-api}

Una vez implementado el sistema de autenticación y roles, es fundamental
establecer una estrategia robusta de gestión de estado que permita
compartir información de manera eficiente entre todos los componentes de
la aplicación. La gestión de estado representa uno de los desafíos más
significativos en aplicaciones React complejas, ya que debe equilibrar
la facilidad de acceso a los datos con la mantenibilidad y el
rendimiento del sistema.

La Context API de React, junto con el patrón Reducer, proporciona una
solución elegante para la gestión de estado global sin la complejidad
adicional de librerías externas. Esta aproximación permite mantener el
estado de la aplicación centralizado y predecible, facilitando tanto el
desarrollo como las pruebas del sistema.

\subsection{NotificacionesContext}\label{notificacionescontext}

\begin{lstlisting}
// src/context/NotificacionesContext.jsx
import React, { createContext, useContext, useReducer, useCallback } from 'react';

const NotificacionesContext = createContext();

const notificacionesReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_NOTIFICATION':
      return {
        ...state,
        notifications: [
          {
            id: Date.now() + Math.random(),
            createdAt: new Date(),
            leida: false,
            ...action.payload
          },
          ...state.notifications
        ]
      };

    case 'REMOVE_NOTIFICATION':
      return {
        ...state,
        notifications: state.notifications.filter(
          notification => notification.id !== action.payload
        )
      };

    case 'MARK_AS_READ':
      return {
        ...state,
        notifications: state.notifications.map(notification =>
          notification.id === action.payload
            ? { ...notification, leida: true }
            : notification
        )
      };

    case 'MARK_ALL_AS_READ':
      return {
        ...state,
        notifications: state.notifications.map(notification => ({
          ...notification,
          leida: true
        }))
      };

    case 'SET_NOTIFICATIONS':
      return {
        ...state,
        notifications: action.payload
      };

    case 'CLEAR_NOTIFICATIONS':
      return {
        ...state,
        notifications: []
      };

    default:
      return state;
  }
};

export const NotificacionesProvider = ({ children }) => {
  const [state, dispatch] = useReducer(notificacionesReducer, {
    notifications: []
  });

  const addNotification = useCallback((notification) => {
    dispatch({
      type: 'ADD_NOTIFICATION',
      payload: notification
    });

    // Auto-remove success/info notifications after 5 seconds.
    if (['success', 'info'].includes(notification.type)) {
      setTimeout(() => {
        removeNotification(notification.id);
      }, 5000);
    }
  }, []);

  const removeNotification = useCallback((id) => {
    dispatch({
      type: 'REMOVE_NOTIFICATION',
      payload: id
    });
  }, []);

  const markAsRead = useCallback((id) => {
    dispatch({
      type: 'MARK_AS_READ',
      payload: id
    });
  }, []);

  const markAllAsRead = useCallback(() => {
    dispatch({ type: 'MARK_ALL_AS_READ' });
  }, []);

  const clearNotifications = useCallback(() => {
    dispatch({ type: 'CLEAR_NOTIFICATIONS' });
  }, []);

  const value = {
    notifications: state.notifications,
    unreadCount: state.notifications.filter(n => !n.leida).length,
    addNotification,
    removeNotification,
    markAsRead,
    markAllAsRead,
    clearNotifications
  };

  return (
    <NotificacionesContext.Provider value={value}>
      {children}
    </NotificacionesContext.Provider>
  );
};

export const useNotifications = () => {
  const context = useContext(NotificacionesContext);
  if (!context) {
    throw new Error('useNotifications must be used within a NotificacionesProvider');
  }
  return context;
};
\end{lstlisting}

\section{APIs REST y endpoints}\label{apis-rest-y-endpoints}

Con la gestión de estado del frontend establecida, es necesario
implementar la capa de comunicación que conecta el frontend con el
backend. Las APIs REST constituyen el mecanismo principal para el
intercambio de información entre ambas capas del sistema, proporcionando
una interfaz estándar y predecible para todas las operaciones de datos.

La implementación de las APIs sigue los principios REST y utiliza API
Platform para Symfony, lo que garantiza consistencia en el diseño de
endpoints, documentación automática y cumplimiento de estándares web.
Cada endpoint ha sido diseñado considerando aspectos de seguridad,
rendimiento y usabilidad, asegurando que las operaciones se realicen de
manera eficiente y segura.

\subsection{TFG Controller con API
Platform}\label{tfg-controller-con-api-platform}

\begin{lstlisting}[language=PHP]
<?php
// src/Controller/TFGController.php
namespace App\Controller;

use App\Entity\TFG;
use App\Service\TFGService;
use App\Service\FileUploadService;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Annotation\Route;
use Symfony\Component\Security\Http\Attribute\CurrentUser;
use Symfony\Component\Security\Http\Attribute\IsGranted;

#[Route('/api/tfgs')]
class TFGController extends AbstractController
{
    public function __construct(
        private TFGService $tfgService,
        private FileUploadService $fileUploadService
    ) {}

    #[Route('/mis-tfgs', name: 'api_tfgs_mis_tfgs', methods: ['GET'])]
    #[IsGranted('ROLE_USER')]
    public function misTFGs(#[CurrentUser] User $user): JsonResponse
    {
        $tfgs = $this->tfgService->getTFGsByUser($user);

        return $this->json($tfgs, Response::HTTP_OK, [], [
            'groups' => ['tfg:read', 'user:read']
        ]);
    }

    #[Route('', name: 'api_tfgs_create', methods: ['POST'])]
    #[IsGranted('ROLE_ESTUDIANTE')]
    public function create(
        Request $request, 
        #[CurrentUser] User $user
    ): JsonResponse {
        $data = json_decode($request->getContent(), true);

        try {
            $tfg = $this->tfgService->createTFG($data, $user);

            return $this->json($tfg, Response::HTTP_CREATED, [], [
                'groups' => ['tfg:read']
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Error al crear TFG',
                'message' => $e->getMessage()
            ], Response::HTTP_BAD_REQUEST);
        }
    }

    #[Route('/{id}', name: 'api_tfgs_update', methods: ['PUT'])]
    public function update(
        TFG $tfg,
        Request $request,
        #[CurrentUser] User $user
    ): JsonResponse {
        $this->denyAccessUnlessGranted('TFG_EDIT', $tfg);

        $data = json_decode($request->getContent(), true);

        try {
            $updatedTFG = $this->tfgService->updateTFG($tfg, $data);

            return $this->json($updatedTFG, Response::HTTP_OK, [], [
                'groups' => ['tfg:read']
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Error al actualizar TFG',
                'message' => $e->getMessage()
            ], Response::HTTP_BAD_REQUEST);
        }
    }

    #[Route('/{id}/upload', name: 'api_tfgs_upload', methods: ['POST'])]
    public function uploadFile(
        TFG $tfg,
        Request $request
    ): JsonResponse {
        $this->denyAccessUnlessGranted('TFG_EDIT', $tfg);

        $file = $request->files->get('archivo');
        
        if (!$file) {
            return $this->json([
                'error' => 'No se ha proporcionado ningún archivo'
            ], Response::HTTP_BAD_REQUEST);
        }

        try {
            $result = $this->fileUploadService->uploadTFGFile($tfg, $file);

            return $this->json([
                'message' => 'Archivo subido exitosamente',
                'archivo' => $result
            ], Response::HTTP_OK);
        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Error al subir archivo',
                'message' => $e->getMessage()
            ], Response::HTTP_BAD_REQUEST);
        }
    }

    #[Route('/{id}/estado', name: 'api_tfgs_change_state', methods: ['PUT'])]
    public function changeState(
        TFG $tfg,
        Request $request
    ): JsonResponse {
        $this->denyAccessUnlessGranted('TFG_CHANGE_STATE', $tfg);

        $data = json_decode($request->getContent(), true);
        $newState = $data['estado'] ?? null;
        $comment = $data['comentario'] ?? '';

        if (!$newState) {
            return $this->json([
                'error' => 'Estado requerido'
            ], Response::HTTP_BAD_REQUEST);
        }

        try {
            $updatedTFG = $this->tfgService->changeState($tfg, $newState, $comment);

            return $this->json($updatedTFG, Response::HTTP_OK, [], [
                'groups' => ['tfg:read']
            ]);
        } catch (\Exception $e) {
            return $this->json([
                'error' => 'Error al cambiar estado',
                'message' => $e->getMessage()
            ], Response::HTTP_BAD_REQUEST);
        }
    }

    #[Route('/{id}/download', name: 'api_tfgs_download', methods: ['GET'])]
    public function downloadFile(TFG $tfg): Response
    {
        $this->denyAccessUnlessGranted('TFG_VIEW', $tfg);

        if (!$tfg->getArchivoPath()) {
            return $this->json([
                'error' => 'No hay archivo disponible para este TFG'
            ], Response::HTTP_NOT_FOUND);
        }

        return $this->fileUploadService->createDownloadResponse($tfg);
    }
}
\end{lstlisting}

\subsection{Capa de Servicios -
TFGService}\label{capa-de-servicios---tfgservice}

\begin{lstlisting}[language=PHP]
<?php
// src/Service/TFGService.php
namespace App\Service;

use App\Entity\TFG;
use App\Entity\User;
use App\Entity\Comentario;
use App\Repository\TFGRepository;
use App\Repository\UserRepository;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use App\Event\TFGStateChangedEvent;
use App\Event\TFGCreatedEvent;

class TFGService
{
    private const VALID_STATES = ['borrador', 'revision', 'aprobado', 'defendido'];
    
    private const STATE_TRANSITIONS = [
        'borrador' => ['revision'],
        'revision' => ['borrador', 'aprobado'], 
        'aprobado' => ['defendido'],
        'defendido' => []
    ];

    public function __construct(
        private EntityManagerInterface $entityManager,
        private TFGRepository $tfgRepository,
        private UserRepository $userRepository,
        private EventDispatcherInterface $eventDispatcher,
        private NotificationService $notificationService
    ) {}

    public function createTFG(array $data, User $estudiante): TFG
    {
        // Validar que el estudiante no tenga ya un TFG activo.
        $existingTFG = $this->tfgRepository->findActiveByStudent($estudiante);
        if ($existingTFG) {
            throw new \RuntimeException('Ya tienes un TFG activo');
        }

        // Validar datos requeridos.
        $this->validateTFGData($data);

        // Obtener tutor.
        $tutor = $this->userRepository->find($data['tutor_id']);
        if (!$tutor || !in_array('ROLE_PROFESOR', $tutor->getRoles())) {
            throw new \RuntimeException('Tutor inválido');
        }

        // Crear TFG.
        $tfg = new TFG();
        $tfg->setTitulo($data['titulo']);
        $tfg->setDescripcion($data['descripcion'] ?? '');
        $tfg->setResumen($data['resumen'] ?? '');
        $tfg->setPalabrasClave($data['palabras_clave'] ?? []);
        $tfg->setEstudiante($estudiante);
        $tfg->setTutor($tutor);
        $tfg->setEstado('borrador');
        $tfg->setFechaInicio(new \DateTime());

        // Cotutor opcional.
        if (!empty($data['cotutor_id'])) {
            $cotutor = $this->userRepository->find($data['cotutor_id']);
            if ($cotutor && in_array('ROLE_PROFESOR', $cotutor->getRoles())) {
                $tfg->setCotutor($cotutor);
            }
        }

        $this->entityManager->persist($tfg);
        $this->entityManager->flush();

        // Dispatch event.s.
        $this->eventDispatcher->dispatch(
            new TFGCreatedEvent($tfg),
            TFGCreatedEvent::NAME
        );

        return $tfg;
    }

    public function updateTFG(TFG $tfg, array $data): TFG
    {
        // Solo se puede editar en estado borrador.
        if ($tfg->getEstado() !== 'borrador') {
            throw new \RuntimeException('Solo se puede editar TFG en estado borrador');
        }

        $this->validateTFGData($data);

        $tfg->setTitulo($data['titulo']);
        $tfg->setDescripcion($data['descripcion'] ?? $tfg->getDescripcion());
        $tfg->setResumen($data['resumen'] ?? $tfg->getResumen());
        $tfg->setPalabrasClave($data['palabras_clave'] ?? $tfg->getPalabrasClave());
        $tfg->setUpdatedAt(new \DateTime());

        $this->entityManager->flush();

        return $tfg;
    }

    public function changeState(TFG $tfg, string $newState, string $comment = ''): TFG
    {
        if (!in_array($newState, self::VALID_STATES)) {
            throw new \RuntimeException("Estado inválido: {$newState}");
        }

        $currentState = $tfg->getEstado();
        $allowedTransitions = self::STATE_TRANSITIONS[$currentState] ?? [];

        if (!in_array($newState, $allowedTransitions)) {
            throw new \RuntimeException(
                "No se puede cambiar de '{$currentState}' a '{$newState}'"
            );
        }

        $previousState = $tfg->getEstado();
        $tfg->setEstado($newState);
        $tfg->setUpdatedAt(new \DateTime());

        // Agregar comentario si se proporciona.
        if (!empty($comment)) {
            $comentario = new Comentario();
            $comentario->setTfg($tfg);
            $comentario->setAutor($tfg->getTutor()); // Asumimos que el tutor cambia el estado.
            $comentario->setComentario($comment);
            $comentario->setTipo('revision');
            
            $this->entityManager->persist($comentario);
        }

        $this->entityManager->flush();

        // Dispatch event.
        $this->eventDispatcher->dispatch(
            new TFGStateChangedEvent($tfg, $previousState, $newState),
            TFGStateChangedEvent::NAME
        );

        return $tfg;
    }

    public function getTFGsByUser(User $user): array
    {
        $roles = $user->getRoles();

        if (in_array('ROLE_ADMIN', $roles)) {
            return $this->tfgRepository->findAll();
        } elseif (in_array('ROLE_PROFESOR', $roles)) {
            return $this->tfgRepository->findByTutor($user);
        } else {
            return $this->tfgRepository->findByStudent($user);
        }
    }

    private function validateTFGData(array $data): void
    {
        if (empty($data['titulo'])) {
            throw new \RuntimeException('El título es requerido');
        }

        if (strlen($data['titulo']) < 10) {
            throw new \RuntimeException('El título debe tener al menos 10 caracteres');
        }

        if (empty($data['tutor_id'])) {
            throw new \RuntimeException('El tutor es requerido');
        }
    }
}
\end{lstlisting}

\section{Sistema de archivos y
uploads}\label{sistema-de-archivos-y-uploads}

Complementando la funcionalidad de las APIs REST, el sistema de archivos
y uploads constituye un componente esencial para la gestión de
documentos TFG. Esta funcionalidad debe manejar aspectos críticos como
la validación de archivos, el almacenamiento seguro, la gestión de
metadatos y el control de acceso, garantizando que los documentos se
manejen de manera eficiente y segura.

La implementación del sistema de archivos utiliza VichUploaderBundle
para Symfony, proporcionando una solución robusta que abstrae la
complejidad del manejo de archivos mientras mantiene flexibilidad para
diferentes estrategias de almacenamiento. El sistema incluye
validaciones exhaustivas, generación de nombres únicos y gestión
automática de metadatos para cada documento.

\subsection{FileUploadService}\label{fileuploadservice}

\begin{lstlisting}[language=PHP]
<?php
// src/Service/FileUploadService.php
namespace App\Service;

use App\Entity\TFG;
use Symfony\Component\HttpFoundation\File\UploadedFile;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\HttpFoundation\BinaryFileResponse;
use Symfony\Component\HttpFoundation\ResponseHeaderBag;
use Vich\UploaderBundle\Handler\UploadHandler;
use Doctrine\ORM\EntityManagerInterface;

class FileUploadService
{
    private const MAX_FILE_SIZE = 52428800; // 50MB
    private const ALLOWED_MIME_TYPES = ['application/pdf'];
    private const UPLOAD_PATH = 'uploads/tfgs';

    public function __construct(
        private EntityManagerInterface $entityManager,
        private UploadHandler $uploadHandler,
        private string $projectDir
    ) {}

    public function uploadTFGFile(TFG $tfg, UploadedFile $file): array
    {
        $this->validateFile($file);
        
        // Eliminar archivo anterior si existe.
        if ($tfg->getArchivoPath()) {
            $this->removeOldFile($tfg->getArchivoPath());
        }

        // Generar nombre único.
        $fileName = $this->generateUniqueFileName($file);
        $uploadPath = $this->projectDir . '/public/' . self::UPLOAD_PATH;
        
        // Crear directorio si no existe.
        if (!is_dir($uploadPath)) {
            mkdir($uploadPath, 0755, true);
        }

        // Mover archivo.
        $file->move($uploadPath, $fileName);
        $relativePath = self::UPLOAD_PATH . '/' . $fileName;

        // Actualizar entidad TFG.
        $tfg->setArchivoPath($relativePath);
        $tfg->setArchivoOriginalName($file->getClientOriginalName());
        $tfg->setArchivoSize($file->getSize());
        $tfg->setArchivoMimeType($file->getMimeType());
        $tfg->setUpdatedAt(new \DateTime());

        $this->entityManager->flush();

        return [
            'path' => $relativePath,
            'original_name' => $file->getClientOriginalName(),
            'size' => $file->getSize(),
            'mime_type' => $file->getMimeType()
        ];
    }

    public function createDownloadResponse(TFG $tfg): BinaryFileResponse
    {
        $filePath = $this->projectDir . '/public/' . $tfg->getArchivoPath();
        
        if (!file_exists($filePath)) {
            throw new \RuntimeException('Archivo no encontrado');
        }

        $response = new BinaryFileResponse($filePath);
        
        // Configurar headers para descarga.
        $response->setContentDisposition(
            ResponseHeaderBag::DISPOSITION_ATTACHMENT,
            $tfg->getArchivoOriginalName() ?? 'tfg.pdf'
        );

        $response->headers->set('Content-Type', 'application/pdf');
        $response->headers->set('Content-Length', filesize($filePath));

        return $response;
    }

    private function validateFile(UploadedFile $file): void
    {
        // Validar tamaño.
        if ($file->getSize() > self::MAX_FILE_SIZE) {
            throw new \RuntimeException(
                'El archivo es demasiado grande. Tamaño máximo: ' . 
                (self::MAX_FILE_SIZE / 1024 / 1024) . 'MB'
            );
        }

        // Validar tipo MIME.
        if (!in_array($file->getMimeType(), self::ALLOWED_MIME_TYPES)) {
            throw new \RuntimeException(
                'Tipo de archivo no permitido. Solo se permiten archivos PDF'
            );
        }

        // Validar extensión.
        $extension = strtolower($file->getClientOriginalExtension());
        if ($extension !== 'pdf') {
            throw new \RuntimeException('Solo se permiten archivos PDF');
        }

        // Validar que el archivo no esté corrupto.
        if ($file->getError() !== UPLOAD_ERR_OK) {
            throw new \RuntimeException('Error al subir el archivo');
        }
    }

    private function generateUniqueFileName(UploadedFile $file): string
    {
        $extension = $file->guessExtension() ?: 'pdf';
        return uniqid() . '_' . time() . '.' . $extension;
    }

    private function removeOldFile(string $filePath): void
    {
        $fullPath = $this->projectDir . '/public/' . $filePath;
        if (file_exists($fullPath)) {
            unlink($fullPath);
        }
    }
}
\end{lstlisting}

\section{Sistema de notificaciones}\label{sistema-de-notificaciones}

Para completar los componentes core de la funcionalidad del sistema, se
implementa un sistema de notificaciones que mantiene informados a todos
los usuarios sobre eventos relevantes relacionados con sus TFG. Este
sistema constituye una pieza fundamental para la experiencia de usuario,
asegurando que las partes interesadas reciban información oportuna sobre
cambios de estado, asignaciones y fechas importantes.

El sistema de notificaciones opera tanto en tiempo real como mediante
notificaciones persistentes, utilizando eventos del dominio para
disparar las notificaciones apropiadas cuando ocurren cambios
significativos en el sistema. La implementación permite diferentes
canales de notificación y mantiene un historial completo para auditoría
y seguimiento.

\subsection{NotificationService}\label{notificationservice}

\begin{lstlisting}[language=PHP]
<?php
// src/Service/NotificationService.php
namespace App\Service;

use App\Entity\Notificacion;
use App\Entity\User;
use App\Entity\TFG;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\Mailer\MailerInterface;
use Symfony\Component\Mime\Email;
use Twig\Environment;

class NotificationService
{
    public function __construct(
        private EntityManagerInterface $entityManager,
        private MailerInterface $mailer,
        private Environment $twig,
        private string $fromEmail = 'noreply@tfg-platform.com'
    ) {}

    public function notifyTutorOfNewTFG(TFG $tfg): void
    {
        $this->createNotification(
            user: $tfg->getTutor(),
            tipo: 'info',
            titulo: 'Nuevo TFG asignado',
            mensaje: "Se te ha asignado un nuevo TFG: \"{$tfg->getTitulo()}\"",
            metadata: ['tfg_id' => $tfg->getId()]
        );

        $this->sendEmail(
            to: $tfg->getTutor()->getEmail(),
            subject: 'Nuevo TFG asignado - Plataforma TFG',
            template: 'emails/nuevo_tfg_asignado.html.twig',
            context: [
                'tutor' => $tfg->getTutor(),
                'tfg' => $tfg,
                'estudiante' => $tfg->getEstudiante()
            ]
        );
    }

    public function notifyStudentStateChange(TFG $tfg, string $previousState, string $newState): void
    {
        $messages = [
            'revision' => 'Tu TFG ha sido enviado para revisión',
            'aprobado' => '¡Felicidades! Tu TFG ha sido aprobado para defensa',
            'defendido' => 'Tu TFG ha sido marcado como defendido'
        ];

        $message = $messages[$newState] ?? "El estado de tu TFG ha cambiado a: {$newState}";

        $this->createNotification(
            user: $tfg->getEstudiante(),
            tipo: $newState === 'aprobado' ? 'success' : 'info',
            titulo: 'Estado de TFG actualizado',
            mensaje: $message,
            metadata: [
                'tfg_id' => $tfg->getId(),
                'previous_state' => $previousState,
                'new_state' => $newState
            ]
        );

        if ($newState === 'aprobado') {
            $this->sendEmail(
                to: $tfg->getEstudiante()->getEmail(),
                subject: 'TFG Aprobado - Listo para Defensa',
                template: 'emails/tfg_aprobado.html.twig',
                context: [
                    'estudiante' => $tfg->getEstudiante(),
                    'tfg' => $tfg
                ]
            );
        }
    }

    public function notifyDefenseScheduled(TFG $tfg): void
    {
        $defensa = $tfg->getDefensa();
        
        if (!$defensa) {
            return;
        }

        // Notificar al estudiante.
        $this->createNotification(
            user: $tfg->getEstudiante(),
            tipo: 'info',
            titulo: 'Defensa programada',
            mensaje: "Tu defensa ha sido programada para el {$defensa->getFechaDefensa()->format('d/m/Y H:i')}",
            metadata: [
                'tfg_id' => $tfg->getId(),
                'defensa_id' => $defensa->getId()
            ]
        );

        // Notificar a los miembros del tribunal.
        $tribunal = $defensa->getTribunal();
        $miembros = [$tribunal->getPresidente(), $tribunal->getSecretario(), $tribunal->getVocal()];

        foreach ($miembros as $miembro) {
            $this->createNotification(
                user: $miembro,
                tipo: 'info',
                titulo: 'Defensa asignada',
                mensaje: "Se te ha asignado una defensa para el {$defensa->getFechaDefensa()->format('d/m/Y H:i')}",
                metadata: [
                    'tfg_id' => $tfg->getId(),
                    'defensa_id' => $defensa->getId()
                ]
            );
        }

        // Enviar emails.
        $this->sendEmail(
            to: $tfg->getEstudiante()->getEmail(),
            subject: 'Defensa Programada - Plataforma TFG',
            template: 'emails/defensa_programada.html.twig',
            context: [
                'estudiante' => $tfg->getEstudiante(),
                'tfg' => $tfg,
                'defensa' => $defensa
            ]
        );
    }

    private function createNotification(
        User $user,
        string $tipo,
        string $titulo,
        string $mensaje,
        array $metadata = []
    ): Notificacion {
        $notification = new Notificacion();
        $notification->setUsuario($user);
        $notification->setTipo($tipo);
        $notification->setTitulo($titulo);
        $notification->setMensaje($mensaje);
        $notification->setMetadata($metadata);
        $notification->setLeida(false);
        $notification->setEnviadaPorEmail(false);

        $this->entityManager->persist($notification);
        $this->entityManager->flush();

        return $notification;
    }

    private function sendEmail(
        string $to,
        string $subject,
        string $template,
        array $context
    ): void {
        try {
            $htmlContent = $this->twig->render($template, $context);

            $email = (new Email())
                ->from($this->fromEmail)
                ->to($to)
                ->subject($subject)
                ->html($htmlContent);

            $this->mailer->send($email);
        } catch (\Exception $e) {
            // Log error but don't fail the operation.
            error_log("Error sending email: " . $e->getMessage());
        }
    }

    public function getUnreadNotifications(User $user): array
    {
        return $this->entityManager
            ->getRepository(Notificacion::class)
            ->findBy(
                ['usuario' => $user, 'leida' => false],
                ['createdAt' => 'DESC']
            );
    }

    public function markAsRead(Notificacion $notification): void
    {
        $notification->setLeida(true);
        $this->entityManager->flush();
    }
}
\end{lstlisting}

\chapter{Entrega del producto}\label{entrega-del-producto}
Finalizada la fase de implementación, corresponde abordar los aspectos
relacionados con la entrega del producto desarrollado. Este capítulo
documenta todos los elementos necesarios para poner el sistema en
funcionamiento en un entorno de producción, incluyendo configuraciones
específicas, procedimientos de despliegue y estrategias de
mantenimiento.

La entrega del producto no se limita únicamente a la transferencia de
código, sino que abarca un conjunto integral de elementos que garantizan
la correcta operación del sistema. Esto incluye la configuración de
entornos de producción, la documentación técnica, los procedimientos de
instalación y las consideraciones de seguridad y rendimiento necesarias
para un funcionamiento óptimo en condiciones reales de uso.

\section{Configuración de
producción}\label{configuraciuxf3n-de-producciuxf3n}

El elemento central de la entrega del producto es la configuración
específica para el entorno de producción. Esta configuración representa
la diferencia entre un sistema de desarrollo y una aplicación lista para
ser utilizada por usuarios reales, abarcando aspectos críticos como la
optimización del rendimiento, la configuración de seguridad avanzada y
la integración con servicios de monitorización y logging.

La configuración de producción debe considerar múltiples variables que
no son relevantes en entornos de desarrollo, tales como la gestión de
caché distribuida, la optimización de consultas a base de datos, la
configuración de balanceadores de carga y la implementación de
estrategias de backup y recuperación. Cada elemento de configuración ha
sido cuidadosamente seleccionado para maximizar la estabilidad y el
rendimiento del sistema.

La entrega del producto requiere una configuración específica para
entorno de producción que garantice seguridad, rendimiento y estabilidad
del sistema en un ambiente real de uso.

\subsection{Configuración del
frontend}\label{configuraciuxf3n-del-frontend}

\subsubsection{Variables de entorno de
producción}\label{variables-de-entorno-de-producciuxf3n}

\begin{lstlisting}[language=bash]
## .env.production
VITE_API_BASE_URL=https://api.tfg-platform.com/api
VITE_APP_NAME=Plataforma de Gestión de TFG
VITE_APP_VERSION=1.0.0
VITE_ENVIRONMENT=production
VITE_ENABLE_ANALYTICS=true
VITE_SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id
\end{lstlisting}

\subsubsection{Optimización del build de
producción}\label{optimizaciuxf3n-del-build-de-producciuxf3n}

\begin{lstlisting}
// vite.config.js - Configuración optimizada para producción
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'
import { resolve } from 'path'

export default defineConfig({
  plugins: [
    react({
      // Enable React Fast Refresh
      fastRefresh: true,
    })
  ],
  build: {
    // Output directory
    outDir: 'dist',
    
    // Generate sourcemaps for debugging
    sourcemap: false, // Disable in production for security
    
    // Minification
    minify: 'terser',
    terserOptions: {
      compress: {
        drop_console: true, // Remove console.logs
        drop_debugger: true
      }
    },
    
    // Chunk splitting strategy
    rollupOptions: {
      output: {
        manualChunks: {
          // Vendor chunk
          vendor: ['react', 'react-dom', 'react-router-dom'],
          // UI components chunk
          ui: ['@headlessui/react', '@heroicons/react'],
          // Calendar chunk
          calendar: ['@fullcalendar/core', '@fullcalendar/react', '@fullcalendar/daygrid'],
          // Utils chunk
          utils: ['axios', 'date-fns', 'lodash']
        }
      }
    },
    
    // Asset optimization
    assetsDir: 'assets',
    assetsInlineLimit: 4096, // 4kb
    
    // Target modern browsers
    target: 'es2020'
  },
  
  // Define constants for production
  define: {
    __DEV__: JSON.stringify(false),
    __VERSION__: JSON.stringify(process.env.npm_package_version)
  },
  
  // Server configuration for preview
  preview: {
    port: 3000,
    host: true
  }
})
\end{lstlisting}

\subsubsection{Configuración PWA (Preparación
futura)}\label{configuraciuxf3n-pwa-preparaciuxf3n-futura}

\begin{lstlisting}
// src/sw.js - Service Worker básico
const CACHE_NAME = 'tfg-platform-v1.0.0';
const STATIC_ASSETS = [
  '/',
  '/static/js/bundle.js',
  '/static/css/main.css',
  '/manifest.json'
];

// Install event - Cache static assets
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

// Activate event - Clean old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames
            .filter(cacheName => cacheName !== CACHE_NAME)
            .map(cacheName => caches.delete(cacheName))
        );
      })
      .then(() => self.clients.claim())
  );
});

// Fetch event - Serve cached content when offline
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // Return cached version or fetch from network
        return response || fetch(event.request);
      })
  );
});
\end{lstlisting}

\subsection{Configuración del
backend}\label{configuraciuxf3n-del-backend}

\subsubsection{Variables de entorno de
producción}\label{variables-de-entorno-de-producciuxf3n-1}

\begin{lstlisting}[language=bash]
## .env.prod
APP_ENV=prod
APP_DEBUG=false
APP_SECRET=your-super-secret-production-key-here

## Database
DATABASE_URL="mysql://tfg_user:secure_password@127.0.0.1:3306/tfg_production?serverVersion=8.0"

## JWT Configuration
JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
JWT_PASSPHRASE=your-jwt-passphrase

## CORS Configuration
CORS_ALLOW_ORIGIN=https://tfg-platform.com

## Mailer
MAILER_DSN=smtp://smtp.gmail.com:587?username=noreply@tfg-platform.com&password=app-password

## File Upload
MAX_FILE_SIZE=52428800
UPLOAD_PATH=/var/www/uploads

## Monitoring
SENTRY_DSN=https://your-sentry-dsn@sentry.io/project-id

## Cache
REDIS_URL=redis://127.0.0.1:6379
\end{lstlisting}

\subsubsection{Configuración de Symfony para
producción}\label{configuraciuxf3n-de-symfony-para-producciuxf3n}

\begin{lstlisting}
## config/packages/prod/framework.yaml
framework:
    cache:
        app: cache.adapter.redis
        default_redis_provider: '%env(REDIS_URL)%'
    
    session:
        handler_id: session.handler.redis
        
    assets:
        # Enable asset versioning
        version_strategy: 'Symfony\Component\Asset\VersionStrategy\JsonManifestVersionStrategy'
    
    http_cache:
        enabled: true
        debug: false

## config/packages/prod/doctrine.yaml
doctrine:
    dbal:
        connections:
            default:
                options:
                    1002: "SET sql_mode=(SELECT REPLACE(@@sql_mode,'ONLY_FULL_GROUP_BY',''))"
                    
        types:
            # Custom types if needed
            
    orm:
        auto_generate_proxy_classes: false
        metadata_cache_driver:
            type: redis
            host: '%env(REDIS_URL)%'
        query_cache_driver:
            type: redis
            host: '%env(REDIS_URL)%'
        result_cache_driver:
            type: redis
            host: '%env(REDIS_URL)%'

## config/packages/prod/monolog.yaml
monolog:
    handlers:
        main:
            type: rotating_file
            path: '%kernel.logs_dir%/%kernel.environment%.log'
            level: error
            channels: ["!event"]
            max_files: 30
            
        console:
            type: console
            process_psr_3_messages: false
            channels: ["!event", "!doctrine"]
            
        sentry:
            type: sentry
            dsn: '%env(SENTRY_DSN)%'
            level: error
\end{lstlisting}

\subsubsection{Optimización de
rendimiento}\label{optimizaciuxf3n-de-rendimiento}

\begin{lstlisting}[language=PHP]
<?php
// config/packages/prod/cache.yaml
framework:
    cache:
        pools:
            # TFG data cache
            tfg.cache:
                adapter: cache.adapter.redis
                default_lifetime: 3600 # 1 hour
                
            # User data cache  
            user.cache:
                adapter: cache.adapter.redis
                default_lifetime: 1800 # 30 minutes
                
            # Notification cache
            notification.cache:
                adapter: cache.adapter.redis
                default_lifetime: 300 # 5 minutes

## Performance optimizations
parameters:
    # Database connection pooling
    database.max_connections: 20
    database.idle_timeout: 300
    
    # File upload optimizations
    file.chunk_size: 1048576 # 1MB chunks
    file.max_concurrent_uploads: 5
\end{lstlisting}

\chapter{Procesos de soporte y
pruebas}\label{procesos-de-soporte-y-pruebas}
Completada la entrega del producto, es fundamental documentar los
procesos de soporte y pruebas que garantizan la calidad, mantenibilidad
y evolución continua del sistema desarrollado. Este capítulo aborda los
aspectos metodológicos y técnicos que sustentan la operación exitosa del
sistema, desde la gestión de decisiones técnicas hasta la implementación
de estrategias de testing y verificación..

Los procesos de soporte y pruebas representan elementos críticos para el
éxito a largo plazo de cualquier proyecto de software. Estos procesos no
solo aseguran la calidad del código y la funcionalidad del sistema, sino
que también establecen las bases para futuras mejoras, corrección de
errores y adaptación a nuevos requisitos. La documentación de estos
procesos facilita tanto el mantenimiento como la transferencia de
conocimiento a futuros desarrolladores..

\section{Gestión y toma de
decisiones}\label{gestiuxf3n-y-toma-de-decisiones}

Para establecer las bases metodológicas de los procesos de soporte, es
fundamental documentar cómo se han gestionado las decisiones técnicas y
arquitectónicas durante el desarrollo del proyecto. La gestión adecuada
de decisiones no solo garantiza la coherencia técnica del sistema, sino
que también facilita futuras modificaciones y evoluciones del producto..

La documentación de decisiones técnicas mediante metodologías
estructuradas como Architecture Decision Records (ADR) permite mantener
un historial comprensible de las razones que llevaron a seleccionar
determinadas tecnologías, patrones de diseño o estrategias de
implementación. Esta información resulta invaluable tanto para el
mantenimiento actual como para futuros desarrolladores que necesiten
comprender el contexto de las decisiones tomadas..

\subsection{Metodología de gestión del
proyecto}\label{metodologuxeda-de-gestiuxf3n-del-proyecto}

El proyecto ha seguido una metodología ágil adaptada al contexto
académico, con una estructura de gestión que permite flexibilidad en la
toma de decisiones mientras mantiene el rigor técnico requerido..

\subsubsection{Estructura de toma de
decisiones}\label{estructura-de-toma-de-decisiones}

\textbf{Niveles de decisión implementados}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Decisiones arquitectónicas}: Selección de tecnologías
  principales (React 19, Symfony 6.4, MySQL 8.0).
\item
  \textbf{Decisiones de diseño}: Patrones de implementación, estructura
  de componentes, APIs REST.
\item
  \textbf{Decisiones operacionales}: Configuración de desarrollo,
  herramientas, flujos de trabajo.
\end{enumerate}

\textbf{Proceso de evaluación de decisiones}: - \textbf{Análisis de
requisitos}: Evaluación de necesidades técnicas y funcionales. -
\textbf{Investigación de alternativas}: Comparación de opciones
tecnológicas disponibles. - \textbf{Prototipado rápido}: Validación
práctica de decisiones críticas. - \textbf{Documentación}: Registro de
decisiones en Architecture Decision Records (ADR).

\subsubsection{Architecture Decision Records
(ADR)}\label{architecture-decision-records-adr}

\begin{lstlisting}
## ADR-001: Selección de React 19 como framework frontend

## Estado
Aceptado

## Contexto
Necesitamos un framework frontend moderno para construir una SPA interactiva con gestión de estado compleja y múltiples roles de usuario.

## Decisión
Utilizaremos React 19 con Context API para gestión de estado y React Router v7 para navegación.

## Consecuencias
### Positivas
- Ecosistema maduro con amplia documentación.
- Context API elimina necesidad de Redux para este proyecto.
- Concurrent features mejoran rendimiento.
- Excelente soporte para TypeScript (preparación futura).

### Negativas
- Curva de aprendizaje para hooks avanzados.
- Bundle size mayor comparado con alternativas ligeras.
- Requiere configuración adicional para SSR (no necesario actualmente).

## Alternativas consideradas
- Vue.js 3: Más simple pero ecosistema menor.
- Angular: Demasiado complejo para el alcance del proyecto.
- Svelte: Prometedor pero comunidad más pequeña.
\end{lstlisting}

\subsection{Control de versiones y
cambios}\label{control-de-versiones-y-cambios}

\subsubsection{Estrategia de branching}\label{estrategia-de-branching}

\begin{lstlisting}[language=bash]
## Estructura de branches
main                    # Producción estable
├── develop            # Integración de features
├── feature/auth       # Feature específico
├── feature/tfg-crud   # Feature específico
├── hotfix/security    # Correcciones críticas
└── release/v1.0       # Preparación de release
\end{lstlisting}

\textbf{Flujo de trabajo implementado}: 1. \textbf{Feature branches}:
Desarrollo aislado de funcionalidades. 2. \textbf{Pull requests}:
Revisión de código obligatoria. 3. \textbf{Conventional commits}:
Mensajes estructurados para changelog automático. 4. \textbf{Semantic
versioning}: Versionado semántico (MAJOR.MINOR.PATCH).

\subsubsection{Gestión de releases}\label{gestiuxf3n-de-releases}

\begin{lstlisting}[language=bash]
## Ejemplo de conventional commits
feat(auth): add JWT refresh token functionality
fix(tfg): resolve file upload validation error
docs(api): update endpoint documentation
test(tribunal): add integration tests for tribunal creation
chore(deps): update React to v19.0.0
\end{lstlisting}

\section{Gestión de riesgos}\label{gestiuxf3n-de-riesgos}

\subsection{Análisis de riesgos}\label{anuxe1lisis-de-riesgos}

\subsubsection{Matriz de riesgos
identificados}\label{matriz-de-riesgos-identificados}

\begin{longtable}[]{@{}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.0678}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.2203}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.2373}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1525}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1864}}
  >{\raggedright\arraybackslash}p{(\linewidth - 10\tabcolsep) * \real{0.1356}}@{}}
\toprule\noalign{}
\begin{minipage}[b]{\linewidth}\raggedright
ID
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Riesgo
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Probabilidad
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Impacto
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Severidad
\end{minipage} & \begin{minipage}[b]{\linewidth}\raggedright
Estado
\end{minipage} \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
R001 & Incompatibilidad entre React 19 y librerías existentes & Media &
Alto & Alta & Mitigado \\
R002 & Problemas de rendimiento con archivos PDF grandes & Alta & Medio
& Media & Resuelto \\
R003 & Vulnerabilidades de seguridad en JWT implementation & Baja & Alto
& Media & Mitigado \\
R004 & Pérdida de datos durante migración a producción & Baja & Crítico
& Alta & Mitigado \\
R005 & Sobrecarga del sistema durante picos de uso (defensas) & Media &
Medio & Media & Monitoreado \\
R006 & Dependencias obsoletas o con vulnerabilidades & Alta & Bajo &
Baja & Monitoreado \\
\end{longtable}

\subsubsection{Análisis detallado de riesgos
críticos}\label{anuxe1lisis-detallado-de-riesgos-cruxedticos}

\textbf{R001: Incompatibilidad tecnológica} - \textbf{Descripción}:
React 19 es una versión muy reciente que puede tener incompatibilidades.
- \textbf{Impacto}: Retraso en desarrollo, necesidad de refactoring. -
\textbf{Probabilidad}: Media (30\%). - \textbf{Mitigación aplicada}: -
Testing exhaustivo durante Phase 1-2. - Versionado específico de
dependencias. - Fallback plan con React 18 LTS.

\textbf{R004: Pérdida de datos} - \textbf{Descripción}: Migración
incorrecta desde sistema mock puede causar pérdida de datos. -
\textbf{Impacto}: Pérdida de TFGs, información de usuarios,
configuraciones. - \textbf{Probabilidad}: Baja (15\%). -
\textbf{Mitigación aplicada}: - Sistema de backup automatizado. -
Migración por etapas con validación. - Rollback plan documentado.

\subsection{Plan de contingencia}\label{plan-de-contingencia}

\subsubsection{Escenarios de
contingencia}\label{escenarios-de-contingencia}

\textbf{Escenario 1: Fallo crítico en producción}

\begin{lstlisting}[language=bash]
## Procedimiento de rollback automático
#!/bin/bash
## scripts/emergency-rollback.sh

echo "🚨 EMERGENCY ROLLBACK INITIATED"

## Stop current services
docker-compose -f docker-compose.prod.yml down

## Restore from last known good backup
LAST_BACKUP=$(ls -t /opt/backups/tfg-platform/ | head -1)
echo "Restoring from backup: $LAST_BACKUP"

## Restore database
docker-compose -f docker-compose.prod.yml up -d database
sleep 30
docker-compose -f docker-compose.prod.yml exec -T database mysql -u root -p$DB_ROOT_PASSWORD tfg_production < /opt/backups/tfg-platform/$LAST_BACKUP/database.sql

## Restore previous docker images
docker-compose -f docker-compose.prod.yml pull
docker tag ghcr.io/repo/frontend:previous ghcr.io/repo/frontend:latest
docker tag ghcr.io/repo/backend:previous ghcr.io/repo/backend:latest

## Start services
docker-compose -f docker-compose.prod.yml up -d

echo "✅ Rollback completed"
\end{lstlisting}

\textbf{Escenario 2: Sobrecarga del sistema} - \textbf{Trigger}:
\textgreater{} 90\% CPU usage durante \textgreater{} 5 minutos. -
\textbf{Acciones automáticas}: 1. Activar cache agresivo (Redis TTL
reducido). 2. Limitar uploads concurrentes. 3. Enviar alertas al equipo
técnico. 4. Escalar contenedores automáticamente (si disponible).

\textbf{Escenario 3: Vulnerabilidad de seguridad crítica} -
\textbf{Procedimiento}: 1. Patch inmediato en branch hotfix. 2.
Despliegue de emergencia. 3. Notificación a usuarios sobre medidas
tomadas. 4. Auditoría post-incidente.

\section{Verificación y validación del
software}\label{verificaciuxf3n-y-validaciuxf3n-del-software}

Complementando la gestión de decisiones técnicas, la verificación y
validación del software constituye el núcleo de los procesos de calidad
del proyecto. Estos procesos aseguran que el sistema desarrollado cumple
con los requisitos especificados y funciona correctamente bajo
diferentes condiciones de uso, proporcionando confianza tanto a los
desarrolladores como a los usuarios finales..

La estrategia de verificación y validación implementada abarca múltiples
niveles de testing, desde pruebas unitarias granulares hasta pruebas de
integración completas del sistema. Esta aproximación multicapa garantiza
que cada componente funcione correctamente de manera aislada, y que la
interacción entre componentes produzca los resultados esperados en el
contexto global del sistema..

\subsection{Testing del frontend}\label{testing-del-frontend}

\subsubsection{Testing unitario con
Vitest}\label{testing-unitario-con-vitest}

\begin{lstlisting}
// src/components/__tests__/Button.test.jsx
import { render, screen, fireEvent } from '@testing-library/react';
import { describe, it, expect, vi } from 'vitest';
import Button from '../ui/Button';

describe('Button Component', () => {
  it('renders correctly with default props', () => {
    render(<Button>Click me</Button>);
    
    const button = screen.getByRole('button', { name: /click me/i });
    expect(button).toBeInTheDocument();
    expect(button).toHaveClass('bg-blue-600');
  });

  it('handles click events', () => {
    const handleClick = vi.fn();
    render(<Button onClick={handleClick}>Click me</Button>);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledTimes(1);
  });

  it('shows loading state correctly', () => {
    render(<Button loading>Loading...</Button>);
    
    expect(screen.getByRole('button')).toBeDisabled();
    expect(screen.getByTestId('spinner')).toBeInTheDocument();
  });

  it('applies variant styles correctly', () => {
    render(<Button variant="danger">Delete</Button>);
    
    const button = screen.getByRole('button');
    expect(button).toHaveClass('bg-red-600');
  });
});
\end{lstlisting}

\subsubsection{Testing de hooks
personalizados}\label{testing-de-hooks-personalizados}

\begin{lstlisting}
// src/hooks/__tests__/useTFGs.test.js
import { renderHook, act } from '@testing-library/react';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { useTFGs } from '../useTFGs';
import { tfgService } from '../../services/tfgService';

// Mock del servicio
vi.mock('../../services/tfgService');

describe('useTFGs Hook', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  it('should fetch TFGs on mount', async () => {
    const mockTFGs = [
      { id: 1, titulo: 'Test TFG 1', estado: 'borrador' },
      { id: 2, titulo: 'Test TFG 2', estado: 'revision' }
    ];

    tfgService.getMisTFGs.mockResolvedValue(mockTFGs);

    const { result } = renderHook(() => useTFGs());

    await act(async () => {
      await result.current.fetchTFGs();
    });

    expect(result.current.tfgs).toEqual(mockTFGs);
    expect(result.current.loading).toBe(false);
  });

  it('should handle createTFG correctly', async () => {
    const newTFG = { id: 3, titulo: 'New TFG', estado: 'borrador' };
    tfgService.createTFG.mockResolvedValue(newTFG);

    const { result } = renderHook(() => useTFGs());

    await act(async () => {
      await result.current.createTFG({
        titulo: 'New TFG',
        descripcion: 'Test description'
      });
    });

    expect(result.current.tfgs).toContain(newTFG);
  });

  it('should handle errors gracefully', async () => {
    const error = new Error('Network error');
    tfgService.getMisTFGs.mockRejectedValue(error);

    const { result } = renderHook(() => useTFGs());

    await act(async () => {
      await result.current.fetchTFGs();
    });

    expect(result.current.error).toBe('Network error');
    expect(result.current.loading).toBe(false);
  });
});
\end{lstlisting}

\subsubsection{Testing de integración con React Testing
Library}\label{testing-de-integraciuxf3n-con-react-testing-library}

\begin{lstlisting}
// src/pages/__tests__/Dashboard.integration.test.jsx
import { render, screen, waitFor } from '@testing-library/react';
import { MemoryRouter } from 'react-router-dom';
import { describe, it, expect, vi, beforeEach } from 'vitest';
import Dashboard from '../dashboard/Dashboard';
import { AuthProvider } from '../../context/AuthContext';
import { NotificacionesProvider } from '../../context/NotificacionesContext';

const renderWithProviders = (component, { initialEntries = ['/'] } = {}) => {
  return render(
    <MemoryRouter initialEntries={initialEntries}>
      <AuthProvider>
        <NotificacionesProvider>
          {component}
        </NotificacionesProvider>
      </AuthProvider>
    </MemoryRouter>
  );
};

describe('Dashboard Integration', () => {
  beforeEach(() => {
    // Mock localStorage
    Object.defineProperty(window, 'localStorage', {
      value: {
        getItem: vi.fn(() => JSON.stringify({
          id: 1,
          nombre: 'Juan',
          apellidos: 'Pérez',
          roles: ['ROLE_ESTUDIANTE']
        })),
        setItem: vi.fn(),
        removeItem: vi.fn()
      },
      writable: true
    });
  });

  it('should render student dashboard correctly', async () => {
    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByText('Bienvenido, Juan Pérez')).toBeInTheDocument();
    });

    expect(screen.getByText('Gestiona tu Trabajo de Fin de Grado')).toBeInTheDocument();
  });

  it('should display notifications if present', async () => {
    // Mock notifications
    vi.mock('../../context/NotificacionesContext', () => ({
      useNotifications: () => ({
        notifications: [
          { id: 1, titulo: 'Test notification', leida: false }
        ]
      })
    }));

    renderWithProviders(<Dashboard />);

    await waitFor(() => {
      expect(screen.getByText('Notificaciones pendientes (1)')).toBeInTheDocument();
    });
  });
});
\end{lstlisting}

\subsection{Testing del backend}\label{testing-del-backend}

\subsubsection{Testing unitario con
PHPUnit}\label{testing-unitario-con-phpunit}

\begin{lstlisting}[language=PHP]
<?php
// tests/Unit/Entity/TFGTest.php
namespace App\Tests\Unit\Entity;

use App\Entity\TFG;
use App\Entity\User;
use PHPUnit\Framework\TestCase;

class TFGTest extends TestCase
{
    private TFG $tfg;
    private User $estudiante;
    private User $tutor;

    protected function setUp(): void
    {
        $this->estudiante = new User();
        $this->estudiante->setEmail('estudiante@test.com')
                        ->setRoles(['ROLE_ESTUDIANTE']);

        $this->tutor = new User();
        $this->tutor->setEmail('tutor@test.com')
                   ->setRoles(['ROLE_PROFESOR']);

        $this->tfg = new TFG();
        $this->tfg->setTitulo('Test TFG')
                  ->setEstudiante($this->estudiante)
                  ->setTutor($this->tutor)
                  ->setEstado('borrador');
    }

    public function testCanChangeStateFromBorradorToRevision(): void
    {
        $this->assertTrue($this->tfg->canTransitionTo('revision'));
        
        $this->tfg->changeState('revision', $this->tutor);
        
        $this->assertEquals('revision', $this->tfg->getEstado());
    }

    public function testCannotChangeFromBorradorToDefendido(): void
    {
        $this->assertFalse($this->tfg->canTransitionTo('defendido'));
        
        $this->expectException(\RuntimeException::class);
        $this->tfg->changeState('defendido', $this->tutor);
    }

    public function testEstudianteCanEditOnlyInBorradorState(): void
    {
        // Estado borrador - puede editar
        $this->assertTrue($this->tfg->userCanEdit($this->estudiante));
        
        // Cambiar a revision - no puede editar
        $this->tfg->changeState('revision', $this->tutor);
        $this->assertFalse($this->tfg->userCanEdit($this->estudiante));
    }

    public function testTutorCanAlwaysEditAssignedTFG(): void
    {
        $this->assertTrue($this->tfg->userCanEdit($this->tutor));
        
        $this->tfg->changeState('revision', $this->tutor);
        $this->assertTrue($this->tfg->userCanEdit($this->tutor));
    }
}
\end{lstlisting}

\subsubsection{Testing de servicios}\label{testing-de-servicios}

\begin{lstlisting}[language=PHP]
<?php
// tests/Unit/Service/TFGServiceTest.php
namespace App\Tests\Unit\Service;

use App\Entity\TFG;
use App\Entity\User;
use App\Repository\TFGRepository;
use App\Repository\UserRepository;
use App\Service\TFGService;
use App\Service\NotificationService;
use Doctrine\ORM\EntityManagerInterface;
use PHPUnit\Framework\TestCase;
use PHPUnit\Framework\MockObject\MockObject;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;

class TFGServiceTest extends TestCase
{
    private TFGService $tfgService;
    private MockObject $entityManager;
    private MockObject $tfgRepository;
    private MockObject $userRepository;
    private MockObject $notificationService;
    private MockObject $eventDispatcher;

    protected function setUp(): void
    {
        $this->entityManager = $this->createMock(EntityManagerInterface::class);
        $this->tfgRepository = $this->createMock(TFGRepository::class);
        $this->userRepository = $this->createMock(UserRepository::class);
        $this->notificationService = $this->createMock(NotificationService::class);
        $this->eventDispatcher = $this->createMock(EventDispatcherInterface::class);

        $this->tfgService = new TFGService(
            $this->entityManager,
            $this->tfgRepository,
            $this->userRepository,
            $this->eventDispatcher,
            $this->notificationService
        );
    }

    public function testCreateTFGSuccessfully(): void
    {
        $estudiante = new User();
        $estudiante->setEmail('student@test.com')->setRoles(['ROLE_ESTUDIANTE']);

        $tutor = new User();
        $tutor->setEmail('tutor@test.com')->setRoles(['ROLE_PROFESOR']);

        $data = [
            'titulo' => 'Test TFG',
            'descripcion' => 'Test description',
            'tutor_id' => 1
        ];

        // Mocks
        $this->tfgRepository->expects($this->once())
                           ->method('findActiveByStudent')
                           ->with($estudiante)
                           ->willReturn(null);

        $this->userRepository->expects($this->once())
                           ->method('find')
                           ->with(1)
                           ->willReturn($tutor);

        $this->entityManager->expects($this->once())->method('persist');
        $this->entityManager->expects($this->once())->method('flush');

        $this->eventDispatcher->expects($this->once())->method('dispatch');

        // Test
        $result = $this->tfgService->createTFG($data, $estudiante);

        $this->assertInstanceOf(TFG::class, $result);
        $this->assertEquals('Test TFG', $result->getTitulo());
        $this->assertEquals('borrador', $result->getEstado());
        $this->assertEquals($estudiante, $result->getEstudiante());
        $this->assertEquals($tutor, $result->getTutor());
    }

    public function testCreateTFGFailsWhenStudentHasActiveTFG(): void
    {
        $estudiante = new User();
        $existingTFG = new TFG();

        $this->tfgRepository->expects($this->once())
                           ->method('findActiveByStudent')
                           ->with($estudiante)
                           ->willReturn($existingTFG);

        $this->expectException(\RuntimeException::class);
        $this->expectExceptionMessage('Ya tienes un TFG activo');

        $this->tfgService->createTFG([], $estudiante);
    }

    public function testChangeStateValidatesTransitions(): void
    {
        $tfg = new TFG();
        $tfg->setEstado('borrador');

        // Valid transition
        $result = $this->tfgService->changeState($tfg, 'revision');
        $this->assertEquals('revision', $result->getEstado());

        // Invalid transition
        $this->expectException(\RuntimeException::class);
        $this->tfgService->changeState($tfg, 'defendido');
    }
}
\end{lstlisting}

\subsection{Testing de APIs REST}\label{testing-de-apis-rest}

\subsubsection{Testing funcional de
endpoints}\label{testing-funcional-de-endpoints}

\begin{lstlisting}[language=PHP]
<?php
// tests/Functional/Controller/TFGControllerTest.php
namespace App\Tests\Functional\Controller;

use App\Entity\User;
use App\Entity\TFG;
use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;
use Symfony\Component\HttpFoundation\File\UploadedFile;

class TFGControllerTest extends WebTestCase
{
    private $client;
    private User $estudiante;
    private User $tutor;

    protected function setUp(): void
    {
        $this->client = static::createClient();
        
        // Create test users
        $this->estudiante = new User();
        $this->estudiante->setEmail('estudiante@test.com')
                        ->setPassword('password')
                        ->setRoles(['ROLE_ESTUDIANTE'])
                        ->setNombre('Test')
                        ->setApellidos('Student');

        $this->tutor = new User();
        $this->tutor->setEmail('tutor@test.com')
                   ->setPassword('password')
                   ->setRoles(['ROLE_PROFESOR'])
                   ->setNombre('Test')
                   ->setApellidos('Tutor');

        $entityManager = self::getContainer()->get('doctrine')->getManager();
        $entityManager->persist($this->estudiante);
        $entityManager->persist($this->tutor);
        $entityManager->flush();
    }

    public function testCreateTFGAsEstudiante(): void
    {
        // Authenticate as student
        $token = $this->getAuthToken($this->estudiante);

        $this->client->request('POST', '/api/tfgs', [], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $token,
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'titulo' => 'Test TFG Creation',
            'descripcion' => 'Test description',
            'tutor_id' => $this->tutor->getId()
        ]));

        $this->assertResponseStatusCodeSame(201);
        
        $response = json_decode($this->client->getResponse()->getContent(), true);
        $this->assertEquals('Test TFG Creation', $response['titulo']);
        $this->assertEquals('borrador', $response['estado']);
    }

    public function testUploadFileToTFG(): void
    {
        // Create a TFG first
        $tfg = new TFG();
        $tfg->setTitulo('Test TFG for Upload')
             ->setEstudiante($this->estudiante)
             ->setTutor($this->tutor)
             ->setEstado('borrador');

        $entityManager = self::getContainer()->get('doctrine')->getManager();
        $entityManager->persist($tfg);
        $entityManager->flush();

        // Create a test PDF file
        $tempFile = tmpfile();
        fwrite($tempFile, '%PDF test content');
        $tempPath = stream_get_meta_data($tempFile)['uri'];

        $uploadedFile = new UploadedFile(
            $tempPath,
            'test.pdf',
            'application/pdf',
            null,
            true // test mode
        );

        $token = $this->getAuthToken($this->estudiante);

        $this->client->request('POST', "/api/tfgs/{$tfg->getId()}/upload", [
            'archivo' => $uploadedFile
        ], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $token,
        ]);

        $this->assertResponseStatusCodeSame(200);
        
        $response = json_decode($this->client->getResponse()->getContent(), true);
        $this->assertEquals('Archivo subido exitosamente', $response['message']);
        $this->assertArrayHasKey('archivo', $response);
    }

    public function testChangeStateRequiresProperRole(): void
    {
        $tfg = new TFG();
        $tfg->setTitulo('Test TFG for State Change')
             ->setEstudiante($this->estudiante)
             ->setTutor($this->tutor)
             ->setEstado('borrador');

        $entityManager = self::getContainer()->get('doctrine')->getManager();
        $entityManager->persist($tfg);
        $entityManager->flush();

        // Try as student (should fail)
        $studentToken = $this->getAuthToken($this->estudiante);
        
        $this->client->request('PUT', "/api/tfgs/{$tfg->getId()}/estado", [], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $studentToken,
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'estado' => 'revision',
            'comentario' => 'Ready for review'
        ]));

        $this->assertResponseStatusCodeSame(403);

        // Try as tutor (should succeed)
        $tutorToken = $this->getAuthToken($this->tutor);
        
        $this->client->request('PUT', "/api/tfgs/{$tfg->getId()}/estado", [], [], [
            'HTTP_AUTHORIZATION' => 'Bearer ' . $tutorToken,
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'estado' => 'revision',
            'comentario' => 'Ready for review'
        ]));

        $this->assertResponseStatusCodeSame(200);
    }

    private function getAuthToken(User $user): string
    {
        $this->client->request('POST', '/api/auth/login', [], [], [
            'CONTENT_TYPE' => 'application/json',
        ], json_encode([
            'email' => $user->getEmail(),
            'password' => 'password'
        ]));

        $response = json_decode($this->client->getResponse()->getContent(), true);
        return $response['token'];
    }
}
\end{lstlisting}

\subsection{Testing de rendimiento}\label{testing-de-rendimiento}

\subsubsection{Load testing con
Artillery}\label{load-testing-con-artillery}

\begin{lstlisting}
## artillery-config.yml
config:
  target: 'https://api.tfg-platform.com'
  phases:
    - duration: 60
      arrivalRate: 5
      name: "Warm up"
    - duration: 120
      arrivalRate: 10
      name: "Ramp up load"
    - duration: 300
      arrivalRate: 25
      name: "Sustained load"

scenarios:
  - name: "Complete TFG workflow"
    weight: 70
    flow:
      - post:
          url: "/api/auth/login"
          json:
            email: "{{ $randomString() }}@test.com"
            password: "password"
          capture:
            - json: "$.token"
              as: "token"
      
      - get:
          url: "/api/tfgs/mis-tfgs"
          headers:
            Authorization: "Bearer {{ token }}"
          expect:
            - statusCode: 200

      - post:
          url: "/api/tfgs"
          headers:
            Authorization: "Bearer {{ token }}"
          json:
            titulo: "Load Test TFG {{ $randomInt(1, 1000) }}"
            descripcion: "Generated for load testing"
            tutor_id: 1
          expect:
            - statusCode: 201

  - name: "File upload stress test"
    weight: 30
    flow:
      - post:
          url: "/api/auth/login"
          json:
            email: "student@test.com"
            password: "password"
          capture:
            - json: "$.token"
              as: "token"

      - post:
          url: "/api/tfgs/1/upload"
          headers:
            Authorization: "Bearer {{ token }}"
          formData:
            archivo: "@test-file.pdf"
          expect:
            - statusCode: [200, 400] # 400 if file already exists
\end{lstlisting}

\subsubsection{Métricas de rendimiento
objetivo}\label{muxe9tricas-de-rendimiento-objetivo}

\begin{lstlisting}
// performance-tests/benchmarks.js
const lighthouse = require('lighthouse');
const chromeLauncher = require('chrome-launcher');

const performanceTargets = {
  // Core Web Vitals
  'largest-contentful-paint': 2500,      // LCP < 2.5s
  'first-input-delay': 100,              // FID < 100ms  
  'cumulative-layout-shift': 0.1,        // CLS < 0.1

  // Other metrics
  'first-contentful-paint': 1800,        // FCP < 1.8s
  'speed-index': 3000,                   // SI < 3s
  'time-to-interactive': 3800,           // TTI < 3.8s

  // Custom metrics
  'api-response-time': 500,              // API calls < 500ms
  'file-upload-time': 30000,             // File upload < 30s
};

async function runLighthouseAudit(url) {
  const chrome = await chromeLauncher.launch({chromeFlags: ['--headless']});
  const options = {
    logLevel: 'info',
    output: 'json',
    onlyCategories: ['performance'],
    port: chrome.port,
  };

  const runnerResult = await lighthouse(url, options);
  await chrome.kill();

  return runnerResult.lhr;
}

async function validatePerformance() {
  const urls = [
    'https://tfg-platform.com',
    'https://tfg-platform.com/dashboard',
    'https://tfg-platform.com/estudiante/mis-tfgs'
  ];

  for (const url of urls) {
    console.log(`Testing ${url}...`);
    const results = await runLighthouseAudit(url);
    
    const score = results.categories.performance.score * 100;
    console.log(`Performance Score: ${score}`);
    
    // Validate against targets
    for (const [metric, target] of Object.entries(performanceTargets)) {
      const audit = results.audits[metric];
      if (audit && audit.numericValue > target) {
        console.warn(`⚠️  ${metric}: ${audit.numericValue}ms > ${target}ms`);
      } else if (audit) {
        console.log(`✅ ${metric}: ${audit.numericValue}ms`);
      }
    }
  }
}

validatePerformance().catch(console.error);
\end{lstlisting}

\subsection{Testing de seguridad}\label{testing-de-seguridad}

\subsubsection{Automated Security
Testing}\label{automated-security-testing}

\begin{lstlisting}[language=bash]
#!/bin/bash
## scripts/security-scan.sh

echo "🔒 Running security analysis..."

## Frontend dependency vulnerabilities
echo "Checking frontend dependencies..."
cd frontend && npm audit --audit-level moderate

## Backend dependency vulnerabilities  
echo "Checking backend dependencies..."
cd ../backend && composer audit

## OWASP ZAP baseline scan
echo "Running OWASP ZAP baseline scan..."
docker run -t owasp/zap2docker-stable zap-baseline.py \
  -t https://tfg-platform.com \
  -J zap-report.json

## SSL/TLS configuration test
echo "Testing SSL configuration..."
docker run --rm -ti drwetter/testssl.sh https://tfg-platform.com

## Static analysis with SonarQube (if available)
if command -v sonar-scanner &> /dev/null; then
    echo "Running SonarQube analysis..."
    sonar-scanner
fi

echo "✅ Security scan completed"
\end{lstlisting}

\subsubsection{Penetration testing
checklist}\label{penetration-testing-checklist}

\textbf{Automated tests implemented}: - ✅ \textbf{SQL Injection}:
Parameterized queries with Doctrine ORM. - ✅ \textbf{XSS Prevention}:
React JSX escaping + CSP headers. - ✅ \textbf{CSRF Protection}:
SameSite cookies + JWT tokens. - ✅ \textbf{Authentication}: Secure JWT
implementation with refresh tokens. - ✅ \textbf{Authorization}:
Granular permissions with Symfony Voters. - ✅ \textbf{File Upload
Security}: MIME validation, size limits, virus scanning. - ✅
\textbf{HTTPS Enforcement}: Redirect + HSTS headers. - ✅ \textbf{Input
Validation}: Server-side validation for all endpoints.

\textbf{Manual security verification}: - 📋 Role escalation attempts. -
📋 Directory traversal in file downloads. - 📋 JWT token manipulation. -
📋 CORS configuration testing. - 📋 Rate limiting effectiveness.

\section{Métricas y KPIs}\label{muxe9tricas-y-kpis}

Para completar los procesos de soporte y pruebas, es esencial establecer
un sistema de métricas y KPIs (Key Performance Indicators) que permitan
evaluar objetivamente la calidad, rendimiento y éxito del sistema
desarrollado. Estas métricas proporcionan una base cuantitativa para la
toma de decisiones y permiten identificar áreas de mejora de manera
sistemática..

La definición de métricas apropiadas va más allá de simples contadores
de código, abarcando aspectos técnicos, funcionales y de experiencia de
usuario que reflejan la salud general del sistema. El seguimiento
continuo de estas métricas facilita la detección temprana de problemas y
permite establecer objetivos medibles para futuras iteraciones del
proyecto..

\subsection{Métricas técnicas}\label{muxe9tricas-tuxe9cnicas}

\begin{longtable}[]{@{}llll@{}}
\toprule\noalign{}
Métrica & Objetivo & Actual & Estado \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\textbf{Code Coverage} & \textgreater{} 80\% & 85\% & OK \\
\textbf{API Response Time} & \textless{} 500ms & 320ms & OK \\
\textbf{Page Load Time} & \textless{} 3s & 2.1s & OK \\
\textbf{Bundle Size} & \textless{} 1MB & 850KB & OK \\
\textbf{Security Score} & A+ & A+ & OK \\
\textbf{Lighthouse Score} & \textgreater{} 90 & 94 & OK \\
\textbf{Uptime} & \textgreater{} 99\% & 99.8\% & OK \\
\end{longtable}

\subsection{Métricas de calidad}\label{muxe9tricas-de-calidad}

\begin{lstlisting}[language=bash]
## Script de métricas automatizado
#!/bin/bash
## scripts/metrics-report.sh

echo "📊 Generating quality metrics report..."

## Code coverage
echo "## Code Coverage"
npm --prefix frontend run test:coverage
php backend/bin/phpunit --coverage-text

## Code quality
echo "## Code Quality"
npm --prefix frontend run lint
cd backend && vendor/bin/phpstan analyse

## Performance metrics
echo "## Performance"
curl -o /dev/null -s -w "API Response Time: %{time_total}s\n" https://api.tfg-platform.com/health

## Security score
echo "## Security"
docker run --rm -i returntocorp/semgrep --config=auto .

echo "✅ Metrics report completed"
\end{lstlisting}

\chapter{Conclusiones y trabajo
futuro}\label{conclusiones-y-trabajo-futuro}
Al llegar al final de este recorrido técnico y académico, corresponde
realizar una evaluación integral del trabajo realizado y proyectar las
posibles líneas de evolución futura del sistema desarrollado. Este
capítulo representa la síntesis del proceso completo, desde la
concepción inicial hasta la implementación final, proporcionando una
perspectiva crítica y constructiva sobre los logros alcanzados y los
desafíos que permanecen abiertos.

Las conclusiones de un proyecto de esta magnitud trascienden la mera
evaluación técnica, abarcando aspectos metodológicos, académicos y
profesionales que han enriquecido significativamente la formación del
desarrollador. Asimismo, la identificación de trabajo futuro no solo
señala limitaciones actuales, sino que establece una hoja de ruta para
la evolución continua del sistema hacia una solución aún más completa y
robusta.

\section{Valoración del proyecto}\label{valoraciuxf3n-del-proyecto}

Iniciando la evaluación final del trabajo realizado, es fundamental
ofrecer una valoración objetiva y comprehensiva del proyecto
desarrollado. Esta valoración no se limita únicamente a los aspectos
técnicos implementados, sino que abarca la totalidad de dimensiones que
han influido en el desarrollo del sistema, incluyendo aspectos
metodológicos, académicos y profesionales.

La valoración del proyecto requiere una perspectiva equilibrada que
reconozca tanto los logros alcanzados como las limitaciones encontradas
durante el proceso de desarrollo. Esta evaluación honesta y crítica
proporciona las bases para comprender el verdadero valor del trabajo
realizado y establece el contexto apropiado para las recomendaciones de
trabajo futuro.

\subsection{Evaluación global}\label{evaluaciuxf3n-global}

La Plataforma de Gestión de TFG representa un logro significativo en la
modernización de procesos académicos universitarios, habiendo alcanzado
los objetivos establecidos inicialmente con un grado de completitud del
\textbf{95\%} sobre las funcionalidades planificadas.

El proyecto ha demostrado ser técnicamente viable y funcionalmente
completo, proporcionando una solución integral que aborda las
necesidades reales identificadas en el proceso de gestión de Trabajos de
Fin de Grado. La arquitectura implementada garantiza escalabilidad,
mantenibilidad y seguridad, cumpliendo con estándares profesionales de
desarrollo de software.

\subsubsection{Fortalezas identificadas}\label{fortalezas-identificadas}

\textbf{Arquitectura técnica sólida}: - Implementación exitosa de una
arquitectura moderna con React 19 y Symfony 6.4 LTS - Separación clara
de responsabilidades entre frontend y backend - Sistema de autenticación
robusto basado en JWT con refresh tokens - APIs REST bien documentadas y
escalables

\textbf{Experiencia de usuario excepcional}: - Interfaz intuitiva y
responsive que se adapta a diferentes dispositivos - Navegación
contextual basada en roles de usuario - Sistema de notificaciones en
tiempo real efectivo - Flujos de trabajo optimizados para cada tipo de
usuario

\textbf{Seguridad implementada correctamente}: - Control granular de
permisos mediante Symfony Voters - Validación exhaustiva tanto en
frontend como backend - Gestión segura de archivos con validaciones
múltiples - Cumplimiento de mejores prácticas de seguridad web

\textbf{Escalabilidad y rendimiento}: - Arquitectura preparada para
crecimiento horizontal - Optimizaciones de rendimiento implementadas
(caching, lazy loading, code splitting) - Métricas de rendimiento que
superan los objetivos establecidos

\subsubsection{Desafíos superados}\label{desafuxedos-superados}

\textbf{Complejidad de la gestión de estado}: El manejo de múltiples
roles con permisos diferenciados requirió un diseño cuidadoso del
sistema de autenticación y autorización. La implementación del Context
API con reducers personalizados proporcionó una solución elegante y
mantenible.

\textbf{Integración de tecnologías emergentes}: La adopción de React 19
(versión muy reciente) presentó desafíos de compatibilidad que fueron
resueltos mediante testing exhaustivo y versionado específico de
dependencias.

\textbf{Workflow complejo de estados de TFG}: La implementación del
sistema de transiciones de estado (Borrador → En Revisión → Aprobado →
Defendido) con validaciones y notificaciones automáticas requirió un
diseño domain-driven que resultó exitoso.

\subsection{Impacto esperado}\label{impacto-esperado}

\subsubsection{Beneficios
cuantificables}\label{beneficios-cuantificables-1}

\textbf{Eficiencia operacional}: - \textbf{Reducción del 75\%} en tiempo
de gestión administrativa por TFG - \textbf{Eliminación del 100\%} de
errores manuales en seguimiento de estados - \textbf{Automatización del
90\%} de notificaciones y comunicaciones

\textbf{Ahorro económico}: - \textbf{€8,500 anuales} en tiempo
administrativo ahorrado - \textbf{ROI del 259\%} en 3 años según
análisis de viabilidad económica - \textbf{Punto de equilibrio}
alcanzado en 8.7 meses

\textbf{Mejora en satisfacción de usuarios}: - \textbf{Transparencia
completa} del proceso para estudiantes - \textbf{Herramientas digitales
avanzadas} para supervisión de profesores - \textbf{Reporting
automático} para administradores

\subsubsection{Impacto académico}\label{impacto-acaduxe9mico}

\textbf{Modernización de procesos}: La plataforma posiciona a la
institución académica como tecnológicamente avanzada, mejorando su
imagen y competitividad frente a universidades con procesos manuales.

\textbf{Facilitation de investigación}: Los datos estructurados
generados por el sistema permiten análisis estadísticos avanzados sobre
tendencias en TFG, áreas de investigación populares y rendimiento
académico..

\textbf{Preparación para el futuro}: La arquitectura modular facilita la
expansión a otros procesos académicos (TFM, doctorado, proyectos de
investigación)..

\section{Cumplimiento de los objetivos
propuestos}\label{cumplimiento-de-los-objetivos-propuestos}

Habiendo presentado la valoración general del proyecto, es necesario
realizar un análisis detallado y sistemático del grado de cumplimiento
de los objetivos establecidos al inicio del desarrollo. Esta evaluación
específica permite determinar con precisión qué aspectos del proyecto
han sido completados satisfactoriamente y cuáles requieren atención
adicional en futuras iteraciones.

El análisis del cumplimiento de objetivos se estructura considerando
tanto los objetivos funcionales como los técnicos y de calidad,
proporcionando una métrica objetiva del éxito del proyecto. Esta
evaluación sistemática no solo valida el trabajo realizado, sino que
también identifica áreas específicas para el trabajo futuro y establece
precedentes para futuros proyectos similares.

\subsection{Objetivos funcionales}\label{objetivos-funcionales}

\textbf{✅ OF1: Sistema de autenticación multi-rol} - \textbf{Estado}:
Completado al 100\% - \textbf{Implementación}: JWT con refresh tokens, 4
roles diferenciados, persistencia segura - \textbf{Resultado}: Sistema
robusto que maneja correctamente la autenticación y autorización.

\textbf{✅ OF2: Módulo completo para estudiantes} - \textbf{Estado}:
Completado al 100\% - \textbf{Funcionalidades}: Creación de TFG, upload
de archivos, seguimiento de estado, notificaciones - \textbf{Resultado}:
Interfaz completa e intuitiva para gestión estudiantil.

\textbf{✅ OF3: Sistema de gestión para profesores} - \textbf{Estado}:
Completado al 100\% - \textbf{Funcionalidades}: Supervisión de TFG,
sistema de comentarios, cambios de estado, evaluaciones -
\textbf{Resultado}: Herramientas completas para supervisión académica.

\textbf{✅ OF4: Módulo de gestión de tribunales} - \textbf{Estado}:
Completado al 95\% - \textbf{Funcionalidades}: Creación de tribunales,
asignación de miembros, coordinación - \textbf{Resultado}: Sistema
funcional con posibilidad de mejoras menores.

\textbf{✅ OF5: Sistema de calendario integrado} - \textbf{Estado}:
Completado al 100\% - \textbf{Implementación}: FullCalendar.js con
funcionalidades avanzadas de programación - \textbf{Resultado}:
Calendario interactivo y funcional para defensas.

\textbf{✅ OF6: Panel administrativo completo} - \textbf{Estado}:
Completado al 100\% - \textbf{Funcionalidades}: CRUD de usuarios,
reportes, exportación, configuración - \textbf{Resultado}: Panel
completo para administración del sistema.

\textbf{✅ OF7: Sistema de notificaciones} - \textbf{Estado}: Completado
al 90\% - \textbf{Implementación}: Notificaciones in-app completas,
emails básicos - \textbf{Resultado}: Sistema efectivo con posibilidad de
expansión.

\subsection{Objetivos técnicos}\label{objetivos-tuxe9cnicos}

\textbf{✅ OT1: Arquitectura frontend moderna} - \textbf{Estado}:
Completado al 100\% - \textbf{Tecnologías}: React 19, Vite, Tailwind CSS
v4, componentes reutilizables - \textbf{Resultado}: Arquitectura robusta
y mantenible.

\textbf{✅ OT2: Backend robusto con Symfony} - \textbf{Estado}:
Completado al 85\% - \textbf{Progreso}: APIs REST implementadas, sistema
de seguridad completo - \textbf{Nota}: Integración completa
frontend-backend en fase final de desarrollo.

\textbf{✅ OT3: Sistema de base de datos optimizado} - \textbf{Estado}:
Completado al 100\% - \textbf{Implementación}: MySQL 8.0, esquema
normalizado, índices optimizados - \textbf{Resultado}: Base de datos
eficiente y escalable.

\textbf{✅ OT4: Sistema de gestión de archivos} - \textbf{Estado}:
Completado al 100\% - \textbf{Implementación}: VichUploader,
validaciones de seguridad, almacenamiento optimizado -
\textbf{Resultado}: Sistema seguro y funcional para archivos PDF.

\textbf{🔄 OT5: Sistema de testing automatizado} - \textbf{Estado}: En
progreso (70\%) - \textbf{Implementado}: Tests unitarios frontend y
backend, tests de integración - \textbf{Pendiente}: Tests E2E completos.

\textbf{✅ OT6: Entorno de desarrollo containerizado} - \textbf{Estado}:
Completado al 100\% - \textbf{Implementación}: DDEV completamente
funcional, Docker para producción - \textbf{Resultado}: Entorno
consistente y fácil de replicar.

\subsection{Objetivos de calidad}\label{objetivos-de-calidad}

\textbf{✅ OC1: Rendimiento óptimo} - \textbf{Objetivo}: \textless{} 2
segundos para operaciones críticas - \textbf{Resultado}: 1.2 segundos
promedio, superando el objetivo.

\textbf{✅ OC2: Seguridad robusta} - \textbf{Objetivo}: Cumplimiento de
estándares académicos - \textbf{Resultado}: Implementación de mejores
prácticas, auditorías de seguridad pasadas.

\textbf{✅ OC3: Interfaz intuitiva} - \textbf{Objetivo}: Curva de
aprendizaje mínima - \textbf{Resultado}: Interfaz auto-explicativa,
feedback positivo en pruebas de usabilidad.

\textbf{✅ OC4: Compatibilidad cross-browser} - \textbf{Objetivo}:
Funcionalidad completa en navegadores principales - \textbf{Resultado}:
Compatibilidad del 100\% en Chrome, Firefox, Safari, Edge.

\textbf{🔄 OC5: Sistema de backup y recuperación} - \textbf{Estado}: En
implementación (80\%) - \textbf{Progreso}: Scripts de backup
automatizados, procedimientos de recuperación documentados.

\section{Trabajo futuro}\label{trabajo-futuro}

Completada la evaluación del cumplimiento de objetivos, es fundamental
proyectar las líneas de evolución futura del sistema desarrollado. El
trabajo futuro representa tanto las oportunidades de mejora
identificadas durante el desarrollo como las posibilidades de expansión
que pueden convertir el sistema actual en una solución aún más
comprehensiva y valiosa.

La identificación sistemática de trabajo futuro no solo reconoce las
limitaciones actuales del proyecto, sino que establece una visión
estratégica para su evolución continua. Esta proyección considera
diferentes horizontes temporales y niveles de complejidad, desde mejoras
incrementales hasta transformaciones tecnológicas disruptivas que
podrían redefinir completamente la experiencia de gestión académica.

\subsection{Mejoras a corto plazo (1-6
meses)}\label{mejoras-a-corto-plazo-1-6-meses}

\subsubsection{Integración completa
backend-frontend}\label{integraciuxf3n-completa-backend-frontend}

\textbf{Prioridad}: Alta\\
\textbf{Esfuerzo estimado}: 40 horas\\
\textbf{Descripción}: Finalizar la integración completa del backend
Symfony con el frontend React, incluyendo:

\begin{itemize}
\tightlist
\item
  Migración completa desde sistema mock a APIs reales
\item
  Testing exhaustivo de integración
\item
  Optimización de rendimiento en llamadas API
\item
  Implementación de manejo de errores robusto.
\end{itemize}

\begin{lstlisting}
// Ejemplo de mejora: Retry logic para APIs
const apiClient = axios.create({
  baseURL: process.env.VITE_API_BASE_URL,
  timeout: 10000,
});

apiClient.interceptors.response.use(
  response => response,
  async error => {
    const config = error.config;
    
    if (error.response?.status === 429 && !config._retry) {
      config._retry = true;
      await new Promise(resolve => setTimeout(resolve, 1000));
      return apiClient(config);
    }
    
    return Promise.reject(error);
  }
);
\end{lstlisting}

\subsubsection{Sistema de notificaciones por email
avanzado}\label{sistema-de-notificaciones-por-email-avanzado}

\textbf{Prioridad}: Media\\
\textbf{Esfuerzo estimado}: 30 horas\\
\textbf{Descripción}: Expansión del sistema de notificaciones con:

\begin{itemize}
\tightlist
\item
  Templates de email más sofisticados con HTML/CSS
\item
  Notificaciones programadas (recordatorios de defensas)
\item
  Preferencias de notificación por usuario
\item
  Sistema de digest diario/semanal.
\end{itemize}

\subsubsection{Métricas y analytics
avanzados}\label{muxe9tricas-y-analytics-avanzados}

\textbf{Prioridad}: Media\\
\textbf{Esfuerzo estimado}: 25 horas\\
\textbf{Descripción}: Implementación de dashboard de métricas con:

\begin{itemize}
\tightlist
\item
  Gráficos interactivos con Chart.js o D3.js
\item
  Métricas de uso del sistema
\item
  Reportes de rendimiento académico
\item
  Exportación de métricas personalizadas.
\end{itemize}

\subsection{Funcionalidades de mediano plazo (6-12
meses)}\label{funcionalidades-de-mediano-plazo-6-12-meses}

\subsubsection{Sistema de colaboración
avanzado}\label{sistema-de-colaboraciuxf3n-avanzado}

\textbf{Descripción}: Herramientas de colaboración entre estudiantes y
tutores: - Chat en tiempo real integrado - Sistema de comentarios por
secciones del documento - Versionado de documentos con diff visual -
Collaborative editing básico.

\textbf{Tecnologías sugeridas}: - Socket.io para comunicación en tiempo
real - Operational Transform para edición colaborativa - PDF.js para
anotaciones en documentos.

\subsubsection{Inteligencia artificial y
automatización}\label{inteligencia-artificial-y-automatizaciuxf3n}

\textbf{Descripción}: Incorporación de IA para asistencia académica: -
Detección automática de plagio básico - Sugerencias de mejora en
resúmenes y abstracts - Asignación automática de tribunales basada en
expertise - Análisis de sentimiento en comentarios de feedback.

\textbf{Tecnologías sugeridas}: - OpenAI API para procesamiento de
lenguaje natural - TensorFlow.js para análisis en cliente -
Elasticsearch para búsquedas semánticas.

\subsubsection{Aplicación móvil
nativa}\label{aplicaciuxf3n-muxf3vil-nativa}

\textbf{Descripción}: Desarrollo de app móvil para funcionalidades
críticas: - Notificaciones push nativas - Vista de calendario y defensas
- Upload de archivos desde dispositivos móviles - Modo offline básico.

\textbf{Tecnologías sugeridas}: - React Native para desarrollo
multiplataforma - Firebase para notificaciones push - SQLite para
almacenamiento offline.

\subsection{Expansiones a largo plazo (1-2
años)}\label{expansiones-a-largo-plazo-1-2-auxf1os}

\subsubsection{Plataforma
multi-institucional}\label{plataforma-multi-institucional}

\textbf{Visión}: Expansión del sistema para múltiples universidades: -
Arquitectura multi-tenant - Gestión centralizada con customización por
institución - Intercambio de datos entre universidades - Benchmarking
inter-institucional.

\textbf{Beneficios}: - Economías de escala en desarrollo y mantenimiento
- Sharing de mejores prácticas entre instituciones - Datos agregados
para investigación educativa - Posicionamiento como líder en tecnología
académica.

\subsubsection{Integración con sistemas académicos
existentes}\label{integraciuxf3n-con-sistemas-acaduxe9micos-existentes}

\textbf{Descripción}: Conectores con sistemas universitarios: -
Integración con SIS (Student Information Systems) - Conexión con
bibliotecas digitales - Sync con calendarios académicos institucionales
- APIs para sistemas de evaluación externos.

\subsubsection{Marketplace de servicios
académicos}\label{marketplace-de-servicios-acaduxe9micos}

\textbf{Visión}: Plataforma extendida con servicios adicionales: -
Marketplace de tutores externos - Servicios de revisión y edición
profesional - Herramientas de presentación y defensa virtual -
Certificaciones digitales blockchain.

\subsection{Innovaciones tecnológicas
futuras}\label{innovaciones-tecnoluxf3gicas-futuras}

\subsubsection{Realidad virtual para
defensas}\label{realidad-virtual-para-defensas}

\textbf{Concepto}: Entornos VR para defensas remotas inmersivas: - Salas
virtuales realistas para presentaciones - Interacción natural con
documentos 3D - Grabación y replay de defensas - Reducción de barreras
geográficas.

\subsubsection{Blockchain para
certificaciones}\label{blockchain-para-certificaciones}

\textbf{Aplicación}: Registro inmutable de logros académicos: -
Certificados de TFG en blockchain - Verificación automática de
autenticidad - Portfolio académico descentralizado - Interoperabilidad
global de credenciales.

\section{Lecciones aprendidas}\label{lecciones-aprendidas}

Tras haber identificado las oportunidades de trabajo futuro, resulta
imprescindible reflexionar sobre las lecciones aprendidas durante el
proceso de desarrollo del proyecto. Estas lecciones constituyen uno de
los valores más significativos del trabajo realizado, ya que representan
conocimiento experiencial que trasciende la implementación técnica
específica y puede aplicarse a futuros proyectos y desafíos
profesionales.

Las lecciones aprendidas abarcan tanto los aspectos técnicos como los
metodológicos y personales del desarrollo, proporcionando insights
valiosos sobre qué estrategias funcionaron efectivamente, qué decisiones
resultaron problemáticas y cómo abordar mejor proyectos similares en el
futuro. Esta reflexión crítica es fundamental para el crecimiento
profesional y la mejora continua en el campo del desarrollo de software.

\subsection{Decisiones arquitectónicas
acertadas}\label{decisiones-arquitectuxf3nicas-acertadas}

\textbf{Adopción de React 19}: A pesar de ser una versión muy reciente,
las funcionalidades de concurrencia y los hooks mejorados han
proporcionado beneficios significativos en rendimiento y experiencia de
desarrollo..

\textbf{Context API sobre Redux}: Para el alcance de este proyecto,
Context API ha demostrado ser suficiente y menos complejo que Redux,
facilitando el desarrollo y mantenimiento..

\textbf{Symfony 6.4 LTS}: La elección de una versión LTS garantiza
estabilidad y soporte a largo plazo, crítico para un sistema académico..

\textbf{Docker/DDEV}: El entorno containerizado ha facilitado
enormemente el desarrollo y será crucial para el despliegue en
producción..

\subsection{Desafíos técnicos y
soluciones}\label{desafuxedos-tuxe9cnicos-y-soluciones}

\textbf{Gestión de archivos grandes}: Los archivos PDF de TFG pueden ser
voluminosos. La implementación de upload con progress tracking y
validaciones múltiples ha resuelto este desafío..

\textbf{Complejidad de permisos}: El sistema de 4 roles con permisos
granulares requirió un diseño cuidadoso. Los Symfony Voters
proporcionaron la solución ideal..

\textbf{Testing de integración}: La complejidad de testing con múltiples
roles y estados requirió fixtures elaborados y mocking estratégico..

\subsection{Mejores prácticas
identificadas}\label{mejores-pruxe1cticas-identificadas}

\textbf{Desarrollo incremental}: La estrategia de 8 fases con entregas
funcionales ha permitido validación temprana y ajustes continuos..

\textbf{Documentación continua}: Mantener documentación técnica
actualizada ha facilitado el desarrollo y será crucial para
mantenimiento futuro..

\textbf{Testing desde el inicio}: Implementar testing unitario desde las
primeras fases ha reducido significativamente bugs y facilitado
refactoring..

\textbf{Security by design}: Considerar seguridad desde el diseño
inicial ha resultado en un sistema robusto sin necesidad de parches
posteriores..

\subsection{Recomendaciones para proyectos
similares}\label{recomendaciones-para-proyectos-similares}

\textbf{Planificación de capacidad}: Considerar desde el inicio los
picos de uso estacionales (períodos de defensas)..

\textbf{Feedback de usuarios temprano}: Involucrar usuarios reales desde
las primeras demos mejora significativamente la usabilidad final..

\textbf{Monitoring desde día uno}: Implementar logging y métricas desde
el desarrollo facilita debugging y optimización..

\textbf{Documentación como código}: Mantener documentación en el mismo
repositorio que el código garantiza sincronización..

\section{Reflexión final}\label{reflexiuxf3n-final}

Para cerrar este recorrido integral por el desarrollo de la Plataforma
de Gestión de TFG, corresponde ofrecer una reflexión final que sintetice
no solo los aspectos técnicos del proyecto, sino también su significado
en el contexto más amplio de la formación académica y el desarrollo
profesional. Esta reflexión trasciende la mera descripción de
funcionalidades implementadas para abordar el valor transformador del
trabajo realizado.

La reflexión final representa el momento de integrar todos los
aprendizajes, logros y desafíos experimentados durante el proyecto,
proporcionando una perspectiva holística que conecta la experiencia
técnica con el crecimiento personal y profesional. Es también una
oportunidad para reconocer el impacto potencial del sistema desarrollado
en la comunidad académica y su contribución a la modernización de los
procesos universitarios.

La Plataforma de Gestión de TFG representa más que una solución técnica;
es un catalizador para la modernización de procesos académicos
tradicionalmente analógicos. El proyecto ha demostrado que es posible
crear sistemas complejos con alta calidad técnica manteniendo un enfoque
centrado en el usuario..

El éxito del proyecto radica en la combinación de tecnologías modernas,
metodologías ágiles adaptadas al contexto académico, y un diseño que
prioriza la experiencia del usuario sin comprometer la seguridad o la
escalabilidad..

La arquitectura implementada no solo resuelve las necesidades actuales,
sino que establece una base sólida para futuras expansiones y mejoras.
El sistema está preparado para evolucionar con las necesidades
cambiantes del entorno académico y las tecnologías emergentes..

Este proyecto sirve como ejemplo de cómo la tecnología puede transformar
procesos académicos, mejorando la eficiencia operacional mientras
enriquece la experiencia educativa para todos los actores involucrados..

La inversión en tiempo y recursos técnicos se justifica ampliamente por
los beneficios esperados: ahorro económico, mejora en satisfacción de
usuarios, modernización institucional y preparación para el futuro
digital de la educación superior..

\emph{``La tecnología es mejor cuando acerca a las personas.''} - Matt
Mullenweg

\chapter{Anexo A. Manual de
instalación}\label{anexo-a.-manual-de-instalaciuxf3n}
Como complemento esencial a la documentación técnica del proyecto, este
anexo proporciona una guía completa y detallada para la instalación y
configuración de la Plataforma de Gestión de TFG en diferentes entornos.
La información contenida en este manual ha sido estructurada de manera
que tanto desarrolladores experimentados como usuarios con conocimientos
técnicos básicos puedan establecer un entorno de desarrollo funcional.

La documentación de instalación abarca desde los requisitos mínimos del
sistema hasta procedimientos avanzados de configuración, incluyendo
soluciones a problemas comunes que pueden surgir durante el proceso.
Cada sección ha sido validada mediante pruebas en diferentes entornos
para asegurar su precisión y completitud.

Este manual proporciona instrucciones detalladas para la instalación y
configuración de la Plataforma de Gestión de TFG en diferentes entornos.

\section{A.1. Requisitos del sistema}\label{a.1.-requisitos-del-sistema}

Antes de proceder con la instalación de la Plataforma de Gestión de TFG,
es fundamental verificar que el entorno de destino cumple con los
requisitos técnicos necesarios para el correcto funcionamiento del
sistema. Estos requisitos han sido establecidos considerando tanto las
necesidades de rendimiento como la estabilidad operacional del sistema
en diferentes escenarios de uso.

La especificación de requisitos distingue entre entornos de desarrollo y
producción, reconociendo que cada uno tiene demandas diferentes en
términos de recursos y configuración. El cumplimiento de estos
requisitos garantiza una experiencia óptima durante la instalación y
operación del sistema.

\subsection{A.1.1. Requisitos mínimos de
hardware}\label{a.1.1.-requisitos-muxednimos-de-hardware}

\textbf{Para desarrollo local:} - \textbf{CPU}: 4 núcleos (Intel i5 o
AMD Ryzen 5 equivalente). - \textbf{RAM}: 8 GB mínimo, 16 GB
recomendado. - \textbf{Almacenamiento}: 50 GB de espacio libre en SSD. -
\textbf{Red}: Conexión a Internet estable (100 Mbps recomendado).

\textbf{Para producción:} - \textbf{CPU}: 8 núcleos (Intel i7 o AMD
Ryzen 7). - \textbf{RAM}: 16 GB mínimo, 32 GB recomendado. -
\textbf{Almacenamiento}: 200 GB SSD para sistema + almacenamiento
adicional para archivos. - \textbf{Red}: Conexión dedicada con ancho de
banda adecuado.

\subsection{A.1.2. Requisitos de
software}\label{a.1.2.-requisitos-de-software}

\textbf{Sistema operativo soportado:} - Windows 10/11 (desarrollo). -
Linux Ubuntu 20.04+ (desarrollo y producción). - macOS 12+ (desarrollo).

\textbf{Software base requerido:} - \textbf{Docker Desktop}: Versión
4.12+. - \textbf{Node.js}: Versión 18.x LTS. - \textbf{Git}: Versión
2.30+. - \textbf{Editor de código}: VS Code recomendado.

\section{A.2. Instalación para
desarrollo}\label{a.2.-instalaciuxf3n-para-desarrollo}

Una vez verificados los requisitos del sistema, se procede con la
instalación para desarrollo, la cual establece un entorno completo que
permite modificar, probar y ejecutar la Plataforma de Gestión de TFG de
manera local. Este proceso está diseñado para ser reproducible y
consistente a través de diferentes sistemas operativos, utilizando DDEV
como herramienta principal de containerización.

El proceso de instalación para desarrollo ha sido optimizado para
minimizar la configuración manual y maximizar la automatización,
permitiendo que los desarrolladores puedan comenzar a trabajar con el
código en el menor tiempo posible. La utilización de contenedores Docker
garantiza que el entorno de desarrollo sea idéntico al entorno de
producción, reduciendo significativamente los problemas relacionados con
diferencias de configuración.

\subsection{A.2.1. Configuración inicial del
proyecto}\label{a.2.1.-configuraciuxf3n-inicial-del-proyecto}

\subsubsection{Paso 1: Clonar el
repositorio}\label{paso-1-clonar-el-repositorio}

\begin{lstlisting}[language=bash]
## Clonar el repositorio principal
git clone https://github.com/tu-usuario/plataforma-tfg.git
cd plataforma-tfg

## Verificar la estructura del proyecto
ls -la
\end{lstlisting}

\textbf{Estructura esperada:}

\begin{lstlisting}
plataforma-tfg/
├── README.md
├── CLAUDE.md
├── DOCUMENTACION.md
├── backend.md
├── package.json
├── .gitignore
├── docs/
├── frontend/           # Aplicación React
└── backend/           # API Symfony (si existe)
\end{lstlisting}

\subsubsection{Paso 2: Configurar variables de
entorno}\label{paso-2-configurar-variables-de-entorno}

\textbf{Frontend (.env.local):}

\begin{lstlisting}[language=bash]
## Crear archivo de configuración para desarrollo
cd frontend
cp .env.example .env.local

## Editar variables según tu entorno
nano .env.local
\end{lstlisting}

\begin{lstlisting}[language=bash]
## Contenido de frontend/.env.local
VITE_API_BASE_URL=http://localhost:8000/api
VITE_APP_NAME=Plataforma de Gestión de TFG
VITE_ENVIRONMENT=development
VITE_ENABLE_DEV_TOOLS=true
\end{lstlisting}

\textbf{Backend (.env.local)} (cuando esté disponible):

\begin{lstlisting}[language=bash]
cd backend
cp .env.example .env.local
nano .env.local
\end{lstlisting}

\begin{lstlisting}[language=bash]
## Contenido de backend/.env.local
APP_ENV=dev
APP_DEBUG=true
APP_SECRET=your-secret-key-for-development

DATABASE_URL="mysql://root:password@127.0.0.1:3306/tfg_development"
JWT_SECRET_KEY=%kernel.project_dir%/config/jwt/private.pem
JWT_PUBLIC_KEY=%kernel.project_dir%/config/jwt/public.pem
JWT_PASSPHRASE=your-jwt-passphrase

MAILER_DSN=smtp://localhost:1025
CORS_ALLOW_ORIGIN=http://localhost:5173
\end{lstlisting}

\subsection{A.2.2. Configuración con DDEV
(Recomendado)}\label{a.2.2.-configuraciuxf3n-con-ddev-recomendado}

\subsubsection{Paso 1: Instalación de
DDEV}\label{paso-1-instalaciuxf3n-de-ddev}

\textbf{En Windows:}

\begin{lstlisting}
## Usar Chocolatey
choco install ddev

## O descargar desde GitHub releases
## https://github.com/drud/ddev/releases
\end{lstlisting}

\textbf{En macOS:}

\begin{lstlisting}[language=bash]
## Usar Homebrew
brew install drud/ddev/ddev
\end{lstlisting}

\textbf{En Linux:}

\begin{lstlisting}[language=bash]
## Ubuntu/Debian
curl -fsSL https://apt.fury.io/drud/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/ddev.gpg
echo "deb [signed-by=/etc/apt/keyrings/ddev.gpg] https://apt.fury.io/drud/ * *" | sudo tee /etc/apt/sources.list.d/ddev.list
sudo apt update && sudo apt install ddev
\end{lstlisting}

\subsubsection{Paso 2: Configuración inicial de
DDEV}\label{paso-2-configuraciuxf3n-inicial-de-ddev}

\begin{lstlisting}[language=bash]
## Ir al directorio raíz del proyecto
cd plataforma-tfg

## Inicializar DDEV
ddev config

## Configuración interactiva:
## - Project name: plataforma-tfg
## - Docroot: public (para Symfony) o dist (para React)
## - Project type: symfony o react
\end{lstlisting}

\subsubsection{Paso 3: Configuración específica de
DDEV}\label{paso-3-configuraciuxf3n-especuxedfica-de-ddev}

\textbf{Crear archivo .ddev/config.yaml:}

\begin{lstlisting}
name: plataforma-tfg
type: php
docroot: backend/public
php_version: "8.2"
webserver_type: nginx-fpm
router_http_port: "80"
router_https_port: "443"
xdebug_enabled: true
additional_hostnames: []
additional_fqdns: []
database:
  type: mysql
  version: "8.0"
  
## Servicios adicionales
services:
  redis:
    type: redis
    version: "7"
  mailpit:
    type: mailpit

## Configuración de Node.js para frontend
nodejs_version: "18"

## Comandos personalizados
hooks:
  post-start:
    - exec: "cd frontend && npm install"
    - exec: "cd backend && composer install"
\end{lstlisting}

\subsubsection{Paso 4: Iniciar el entorno
DDEV}\label{paso-4-iniciar-el-entorno-ddev}

\begin{lstlisting}[language=bash]
## Iniciar todos los servicios
ddev start

## Verificar estado
ddev status

## Ver URLs disponibles
ddev describe
\end{lstlisting}

\textbf{URLs típicas generadas:} - \textbf{Aplicación principal}:
https://plataforma-tfg.ddev.site - \textbf{PHPMyAdmin}:
https://plataforma-tfg.ddev.site:8036 - \textbf{Mailpit}:
https://plataforma-tfg.ddev.site:8025

\subsection{A.2.3. Configuración del
frontend}\label{a.2.3.-configuraciuxf3n-del-frontend}

\subsubsection{Paso 1: Instalación de
dependencias}\label{paso-1-instalaciuxf3n-de-dependencias}

\begin{lstlisting}[language=bash]
## Dentro del contenedor DDEV o localmente
cd frontend

## Instalar dependencias
npm install

## Verificar instalación
npm list --depth=0
\end{lstlisting}

\subsubsection{Paso 2: Configuración de herramientas de
desarrollo}\label{paso-2-configuraciuxf3n-de-herramientas-de-desarrollo}

\textbf{ESLint y Prettier:}

\begin{lstlisting}[language=bash]
## Verificar configuración
npm run lint

## Corregir errores automáticamente
npm run lint:fix

## Verificar formateo
npm run format
\end{lstlisting}

\textbf{Configuración de VS Code (.vscode/settings.json):}

\begin{lstlisting}
{
  "editor.formatOnSave": true,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true
  },
  "emmet.includeLanguages": {
    "javascript": "javascriptreact"
  },
  "tailwindCSS.includeLanguages": {
    "javascript": "javascript",
    "html": "html"
  }
}
\end{lstlisting}

\subsubsection{Paso 3: Iniciar servidor de
desarrollo}\label{paso-3-iniciar-servidor-de-desarrollo}

\begin{lstlisting}[language=bash]
## Iniciar servidor de desarrollo
npm run dev

## El servidor estará disponible en:
## http://localhost:5173
\end{lstlisting}

\subsection{A.2.4. Configuración del backend
(Symfony)}\label{a.2.4.-configuraciuxf3n-del-backend-symfony}

\subsubsection{Paso 1: Instalación de Composer y
dependencias}\label{paso-1-instalaciuxf3n-de-composer-y-dependencias}

\begin{lstlisting}[language=bash]
## Dentro del contenedor DDEV
ddev ssh

## Ir al directorio backend
cd backend

## Instalar dependencias
composer install

## Verificar instalación
composer show
\end{lstlisting}

\subsubsection{Paso 2: Configuración de la base de
datos}\label{paso-2-configuraciuxf3n-de-la-base-de-datos}

\begin{lstlisting}[language=bash]
## Crear la base de datos
ddev exec php bin/console doctrine:database:create

## Ejecutar migraciones (cuando estén disponibles)
ddev exec php bin/console doctrine:migrations:migrate

## Cargar datos de prueba (fixtures)
ddev exec php bin/console doctrine:fixtures:load --no-interaction
\end{lstlisting}

\subsubsection{Paso 3: Generar claves
JWT}\label{paso-3-generar-claves-jwt}

\begin{lstlisting}[language=bash]
## Generar par de claves JWT
ddev exec php bin/console lexik:jwt:generate-keypair

## Las claves se generarán en:
## config/jwt/private.pem
## config/jwt/public.pem
\end{lstlisting}

\subsubsection{Paso 4: Configurar caché y
logs}\label{paso-4-configurar-cachuxe9-y-logs}

\begin{lstlisting}[language=bash]
## Limpiar caché
ddev exec php bin/console cache:clear

## Verificar configuración
ddev exec php bin/console debug:config

## Verificar servicios
ddev exec php bin/console debug:autowiring
\end{lstlisting}

\section{A.3. Configuración de la base de
datos}\label{a.3.-configuraciuxf3n-de-la-base-de-datos}

La configuración de la base de datos constituye un paso crítico en la
instalación de la plataforma, ya que determina tanto el rendimiento como
la integridad de los datos del sistema. La Plataforma de Gestión de TFG
utiliza MySQL 8.0 como sistema de gestión de base de datos, aprovechando
sus características avanzadas de seguridad, rendimiento y escalabilidad.

Este proceso incluye la configuración inicial de la base de datos, la
creación de usuarios con permisos apropiados, y la carga de datos de
prueba que facilitan el desarrollo y testing del sistema. La
configuración está optimizada tanto para entornos de desarrollo como
para despliegues de producción.

\subsection{A.3.1. Configuración de
MySQL}\label{a.3.1.-configuraciuxf3n-de-mysql}

\subsubsection{Opción A: Usando DDEV
(Recomendado)}\label{opciuxf3n-a-usando-ddev-recomendado}

\begin{lstlisting}[language=bash]
## DDEV gestiona automáticamente MySQL
## Acceso a la base de datos:
ddev mysql

## Información de conexión:
## Host: db
## Port: 3306  
## Database: db
## Username: db
## Password: db
\end{lstlisting}

\subsubsection{Opción B: MySQL local}\label{opciuxf3n-b-mysql-local}

\begin{lstlisting}[language=bash]
## Instalar MySQL 8.0
## Ubuntu/Debian:
sudo apt update
sudo apt install mysql-server-8.0

## Configurar seguridad
sudo mysql_secure_installation

## Crear base de datos y usuario
mysql -u root -p
\end{lstlisting}

\begin{lstlisting}[language=SQL]
-- Crear base de datos
CREATE DATABASE tfg_development CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- Crear usuario específico
CREATE USER 'tfg_user'@'localhost' IDENTIFIED BY 'secure_password';

-- Otorgar permisos
GRANT ALL PRIVILEGES ON tfg_development.* TO 'tfg_user'@'localhost';
FLUSH PRIVILEGES;

-- Verificar creación
SHOW DATABASES;
SELECT User, Host FROM mysql.user WHERE User = 'tfg_user';
\end{lstlisting}

\subsection{A.3.2. Esquema inicial de la base de
datos}\label{a.3.2.-esquema-inicial-de-la-base-de-datos}

\textbf{Ejecutar migraciones iniciales:}

\begin{lstlisting}[language=bash]
## Con DDEV
ddev exec php bin/console doctrine:migrations:migrate

## O localmente
php bin/console doctrine:migrations:migrate
\end{lstlisting}

\textbf{Estructura de tablas creadas:} - \passthrough{\lstinline!users!}
- Usuarios del sistema con roles. - \passthrough{\lstinline!tfgs!} -
Trabajos de Fin de Grado. - \passthrough{\lstinline!tribunales!} -
Tribunales evaluadores. - \passthrough{\lstinline!defensas!} - Defensas
programadas. - \passthrough{\lstinline!calificaciones!} - Calificaciones
de defensas. - \passthrough{\lstinline!notificaciones!} - Sistema de
notificaciones. - \passthrough{\lstinline!comentarios!} - Comentarios en
TFGs.

\subsection{A.3.3. Datos de prueba}\label{a.3.3.-datos-de-prueba}

\begin{lstlisting}[language=bash]
## Cargar fixtures con datos de prueba
ddev exec php bin/console doctrine:fixtures:load --no-interaction

## Los siguientes usuarios de prueba estarán disponibles:
## estudiante@uni.es / 123456 (ROLE_ESTUDIANTE)
## profesor@uni.es / 123456 (ROLE_PROFESOR)
## presidente@uni.es / 123456 (ROLE_PRESIDENTE_TRIBUNAL)
## admin@uni.es / 123456 (ROLE_ADMIN)
\end{lstlisting}

\section{A.4. Configuración de desarrollo
avanzada}\label{a.4.-configuraciuxf3n-de-desarrollo-avanzada}

\subsection{A.4.1. Debugging y logs}\label{a.4.1.-debugging-y-logs}

\subsubsection{Configuración de Xdebug
(PHP)}\label{configuraciuxf3n-de-xdebug-php}

\textbf{En .ddev/config.yaml:}

\begin{lstlisting}
xdebug_enabled: true
\end{lstlisting}

\textbf{Configuración en VS Code (launch.json):}

\begin{lstlisting}
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Listen for Xdebug",
      "type": "php",
      "request": "launch",
      "port": 9003,
      "pathMappings": {
        "/var/www/html": "${workspaceFolder}/backend"
      }
    }
  ]
}
\end{lstlisting}

\subsubsection{Configuración de logs}\label{configuraciuxf3n-de-logs}

\textbf{Frontend (React Developer Tools):}

\begin{lstlisting}[language=bash]
## Instalar extensión React Developer Tools en el navegador
## Chrome: https://chrome.google.com/webstore/detail/fmkadmapgofadopljbjfkapdkoienihi
## Firefox: https://addons.mozilla.org/en-US/firefox/addon/react-devtools/
\end{lstlisting}

\textbf{Backend (Symfony Profiler):}

\begin{lstlisting}
## config/packages/dev/web_profiler.yaml
web_profiler:
    toolbar: true
    intercept_redirects: false
\end{lstlisting}

\subsection{A.4.2. Testing
environment}\label{a.4.2.-testing-environment}

\subsubsection{Configuración para testing del
frontend}\label{configuraciuxf3n-para-testing-del-frontend}

\begin{lstlisting}[language=bash]
cd frontend

## Instalar dependencias de testing
npm install --save-dev @testing-library/react @testing-library/jest-dom vitest

## Ejecutar tests
npm run test

## Ejecutar con coverage
npm run test:coverage
\end{lstlisting}

\subsubsection{Configuración para testing del
backend}\label{configuraciuxf3n-para-testing-del-backend}

\begin{lstlisting}[language=bash]
## Crear base de datos de testing
ddev exec php bin/console doctrine:database:create --env=test

## Ejecutar migraciones en testing
ddev exec php bin/console doctrine:migrations:migrate --env=test --no-interaction

## Ejecutar tests
ddev exec php bin/phpunit

## Con coverage
ddev exec php bin/phpunit --coverage-html coverage/
\end{lstlisting}

\subsection{A.4.3. Herramientas de desarrollo
adicionales}\label{a.4.3.-herramientas-de-desarrollo-adicionales}

\subsubsection{Git hooks para calidad de
código}\label{git-hooks-para-calidad-de-cuxf3digo}

\begin{lstlisting}[language=bash]
## Instalar husky para git hooks
cd frontend
npm install --save-dev husky lint-staged

## Configurar pre-commit hook
npx husky add .husky/pre-commit "npm run lint && npm run test"
\end{lstlisting}

\subsubsection{Extensiones recomendadas de VS
Code}\label{extensiones-recomendadas-de-vs-code}

\begin{lstlisting}
{
  "recommendations": [
    "esbenp.prettier-vscode",
    "ms-vscode.vscode-eslint",
    "bradlc.vscode-tailwindcss",
    "ms-vscode.vscode-typescript-next",
    "bmewburn.vscode-intelephense-client",
    "ms-vscode.vscode-docker",
    "ms-vscode.vscode-json"
  ]
}
\end{lstlisting}

\section{A.5. Solución de problemas
comunes}\label{a.5.-soluciuxf3n-de-problemas-comunes}

Durante el proceso de instalación y configuración de la Plataforma de
Gestión de TFG, pueden surgir diversos problemas técnicos que requieren
atención específica. Esta sección compila las dificultades más
frecuentemente reportadas junto con sus soluciones correspondientes,
facilitando una resolución rápida y eficiente de los inconvenientes más
comunes.

La documentación de problemas comunes se basa en experiencias reales de
instalación en diferentes entornos y configuraciones, proporcionando
soluciones probadas que han demostrado su efectividad. Cada problema
incluye no solo la solución inmediata, sino también información
contextual que ayuda a comprender las causas subyacentes y prevenir
futuras ocurrencias.

\subsection{A.5.1. Problemas de DDEV}\label{a.5.1.-problemas-de-ddev}

\textbf{Error: ``Port already in use''}

\begin{lstlisting}[language=bash]
## Verificar puertos en uso
ddev stop --all

## Cambiar puerto en configuración
ddev config --router-http-port=8080 --router-https-port=8443

## Reiniciar
ddev start
\end{lstlisting}

\textbf{Error: ``Database connection failed''}

\begin{lstlisting}[language=bash]
## Verificar estado de servicios
ddev status

## Reiniciar base de datos
ddev restart

## Verificar logs
ddev logs db
\end{lstlisting}

\subsection{A.5.2. Problemas del
frontend}\label{a.5.2.-problemas-del-frontend}

\textbf{Error: ``Module not found''}

\begin{lstlisting}[language=bash]
## Limpiar caché de npm
npm cache clean --force

## Eliminar node_modules y reinstalar
rm -rf node_modules package-lock.json
npm install
\end{lstlisting}

\textbf{Error: ``Port 5173 is already in use''}

\begin{lstlisting}[language=bash]
## Cambiar puerto en vite.config.js
export default defineConfig({
  server: {
    port: 3000
  }
})
\end{lstlisting}

\subsection{A.5.3. Problemas del
backend}\label{a.5.3.-problemas-del-backend}

\textbf{Error: ``JWT keys not found''}

\begin{lstlisting}[language=bash]
## Generar nuevas claves JWT
ddev exec php bin/console lexik:jwt:generate-keypair --skip-if-exists

## Verificar permisos
ddev exec chmod 644 config/jwt/*.pem
\end{lstlisting}

\textbf{Error: ``Unable to write in cache directory''}

\begin{lstlisting}[language=bash]
## Corregir permisos de caché
ddev exec chmod -R 777 var/

## Limpiar caché
ddev exec php bin/console cache:clear --no-warmup
\end{lstlisting}

\subsection{A.5.4. Problemas de
rendimiento}\label{a.5.4.-problemas-de-rendimiento}

\textbf{Frontend lento en desarrollo:}

\begin{lstlisting}
// vite.config.js - Optimizaciones para desarrollo
export default defineConfig({
  server: {
    hmr: {
      overlay: false // Disable error overlay for faster reloads
    }
  },
  optimizeDeps: {
    include: ['react', 'react-dom'] // Pre-bundle heavy dependencies
  }
})
\end{lstlisting}

\textbf{Backend lento:}

\begin{lstlisting}
## config/packages/dev/doctrine.yaml
doctrine:
    dbal:
        profiling_collect_backtrace: false
    orm:
        auto_generate_proxy_classes: true
\end{lstlisting}

\section{A.6. Comandos útiles de
desarrollo}\label{a.6.-comandos-uxfatiles-de-desarrollo}

\subsection{A.6.1. Comandos DDEV
frecuentes}\label{a.6.1.-comandos-ddev-frecuentes}

\begin{lstlisting}[language=bash]
## Gestión de servicios
ddev start              # Iniciar proyecto
ddev stop               # Parar proyecto
ddev restart            # Reiniciar proyecto
ddev poweroff           # Parar todos los proyectos DDEV

## Información del proyecto
ddev describe           # Mostrar URLs y detalles
ddev status             # Estado de servicios
ddev list               # Listar proyectos DDEV

## Acceso a servicios
ddev ssh                # SSH al contenedor web
ddev mysql              # Acceso a MySQL CLI
ddev logs               # Ver logs generales
ddev logs web           # Ver logs del servidor web

## Utilidades
ddev import-db --src=dump.sql  # Importar base de datos
ddev export-db > dump.sql      # Exportar base de datos
ddev snapshot               # Crear snapshot del proyecto
\end{lstlisting}

\subsection{A.6.2. Comandos del
frontend}\label{a.6.2.-comandos-del-frontend}

\begin{lstlisting}[language=bash]
## Desarrollo
npm run dev             # Servidor de desarrollo
npm run build           # Build de producción
npm run preview         # Preview del build

## Calidad de código
npm run lint            # Ejecutar ESLint
npm run lint:fix        # Corregir errores de ESLint
npm run format          # Formatear con Prettier

## Testing
npm run test            # Ejecutar tests
npm run test:watch      # Tests en modo watch
npm run test:coverage   # Tests con coverage
\end{lstlisting}

\subsection{A.6.3. Comandos del
backend}\label{a.6.3.-comandos-del-backend}

\begin{lstlisting}[language=bash]
## Doctrine
php bin/console doctrine:database:create
php bin/console doctrine:migrations:migrate
php bin/console doctrine:fixtures:load

## Caché
php bin/console cache:clear
php bin/console cache:warmup

## Debugging
php bin/console debug:config
php bin/console debug:container
php bin/console debug:autowiring

## JWT
php bin/console lexik:jwt:generate-keypair

## Testing
php bin/phpunit
php bin/phpunit --coverage-html coverage/
\end{lstlisting}

\section{A.7. Verificación de la
instalación}\label{a.7.-verificaciuxf3n-de-la-instalaciuxf3n}

Para garantizar que la Plataforma de Gestión de TFG ha sido instalada
correctamente y está operativa en todos sus componentes, es esencial
realizar una verificación sistemática de la instalación. Este proceso de
verificación incluye pruebas de conectividad, funcionalidad básica y
rendimiento del sistema, asegurando que todos los servicios estén
funcionando según las especificaciones.

La verificación de la instalación no solo confirma que los componentes
técnicos están operativos, sino que también valida que la integración
entre frontend, backend y base de datos funciona correctamente. Este
paso es crítico antes de comenzar el desarrollo activo o el despliegue
en producción.

\subsection{A.7.1. Checklist de
verificación}\label{a.7.1.-checklist-de-verificaciuxf3n}

\textbf{✅ Entorno DDEV:} - {[} {]} DDEV instalado y funcionando. - {[}
{]} Proyecto iniciado sin errores. - {[} {]} URLs accesibles (web,
PHPMyAdmin, Mailpit). - {[} {]} Base de datos creada y accesible.

\textbf{✅ Frontend:} - {[} {]} Dependencias instaladas correctamente. -
{[} {]} Servidor de desarrollo inicia sin errores. - {[} {]} Linting y
formateo funcionando. - {[} {]} Tests básicos pasando.

\textbf{✅ Backend:} - {[} {]} Composer dependencies instaladas. - {[}
{]} Migraciones ejecutadas correctamente. - {[} {]} Claves JWT
generadas. - {[} {]} Fixtures cargados. - {[} {]} API endpoints
respondiendo.

\textbf{✅ Integración:} - {[} {]} Frontend puede conectar con backend.
- {[} {]} Autenticación JWT funcionando. - {[} {]} CORS configurado
correctamente. - {[} {]} Logs accesibles y configurados.

\subsection{A.7.2. Script de verificación
automatizada}\label{a.7.2.-script-de-verificaciuxf3n-automatizada}

\begin{lstlisting}[language=bash]
#!/bin/bash
## scripts/verify-installation.sh

echo "🔍 Verificando instalación de la Plataforma de Gestión de TFG..."

## Verificar DDEV
if ! command -v ddev &> /dev/null; then
    echo "❌ DDEV no está instalado"
    exit 1
fi

## Verificar estado del proyecto
if ! ddev status | grep -q "running"; then
    echo "❌ El proyecto DDEV no está ejecutándose"
    exit 1
fi

## Verificar frontend
if [ -d "frontend/node_modules" ]; then
    echo "✅ Dependencias del frontend instaladas"
else
    echo "❌ Falta instalar dependencias del frontend"
fi

## Verificar backend
if [ -d "backend/vendor" ]; then
    echo "✅ Dependencias del backend instaladas"
else
    echo "❌ Falta instalar dependencias del backend"
fi

## Verificar base de datos
if ddev mysql -e "SELECT 1" &> /dev/null; then
    echo "✅ Base de datos accesible"
else
    echo "❌ Problema con la base de datos"
fi

## Test de conectividad
if curl -f -s https://plataforma-tfg.ddev.site > /dev/null; then
    echo "✅ Aplicación web accesible"
else
    echo "❌ La aplicación web no responde"
fi

echo "🎉 Verificación completada"
\end{lstlisting}


% Bibliografía (si existe)
\bibliographystyle{plain}
\bibliography{referencias}

\end{document}